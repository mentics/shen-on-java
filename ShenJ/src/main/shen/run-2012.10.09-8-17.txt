
C:\dev\Shen\Shen-6.1\Platforms\CLisp>lisp.exe -m 300MB -M Shen.mem -q

Shen 2010, copyright (C) 2010 Mark Tarver
www.shenlanguage.org, version 6.1
running under Common Lisp, implementation: CLisp
port 1.2 ported by Mark Tarver


(0-) (cd "C:/dev/workspace/ShenJ/src/main/shen")
"C:/dev/workspace/ShenJ/src/main/shen/"

(1-) (load "util.shen")
"C:/dev/workspace/ShenJ/src/main/shen/"
"C:/dev/workspace/ShenJ/src/main/shen/string/"
false
ustring

run time: 0.14040090143680573 secs
loaded
macro
let-macro
macro
max-macro
macro
min-macro
macro
gcd-macro
macro
lcm-macro
cf
macro
round-macro
sqrt
macro
string-list-macro
macro
strlen-macro
macro
string->integer-macro

run time: 0.06240040063858032 secs
loaded
true

!= : (A --> (A --> boolean))
aux-maxL : ((list number) --> number)
aux-minL : ((list number) --> number)
aux-max' : (number --> (number --> number))
aux-min' : (number --> (number --> number))
run time: 0.07800048589706421 secs

typechecked in 803 inferences
loaded


ustring? : (string --> boolean)
digit? : (ustring --> boolean)
letter? : (ustring --> boolean)
ustring-uppercase? : (ustring --> boolean)
ustring-lowercase? : (ustring --> boolean)
whitespace? : (ustring --> boolean)
ustring-inrange? : (number --> (number --> (number --> boolean)))
ustring-upcase : (ustring --> ustring)
ustring-downcase : (ustring --> ustring)
<ustr : (ustring --> (ustring --> boolean))
<=ustr : (ustring --> (ustring --> boolean))
>ustr : (ustring --> (ustring --> boolean))
>=ustr : (ustring --> (ustring --> boolean))
run time: 0.1872011423110962 secs

typechecked in 2783 inferences
loaded : symbol
string-every? : ((ustring --> boolean) --> (string --> boolean))
string-any? : ((ustring --> boolean) --> (string --> boolean))
digit-string? : (string --> boolean)
string-prefix? : (string --> (string --> boolean))
string-prefix-length : (string --> (string --> number))
string-suffix-length : (string --> (string --> number))
string-prefix-length-h : (string --> (string --> (number --> number)))
string-suffix? : (string --> (string --> boolean))
substring? : (string --> (string --> boolean))
string-map : ((ustring --> string) --> (string --> string))
string-map-h : ((ustring --> string) --> (string --> (string --> string)))
string-downcase : (string --> string)
string-upcase : (string --> string)
<=str : (string --> (string --> boolean))
>=str : (string --> (string --> boolean))
<str : (string --> (string --> boolean))
>str : (string --> (string --> boolean))
string-ref : (number --> (string --> ustring))
string-length : (string --> number)
string-length-h : (string --> (number --> number))
string-index : (string --> (string --> number))
string-index-h : (string --> (string --> (number --> number)))
string-index-last : (string --> (string --> number))
string-index-last-h : (string --> (string --> (number --> (number --> number))))

string-insert : (number --> (string --> (string --> string)))
string-split : (number --> (string --> (string * string)))
string-split-h : (number --> (string --> (string --> (string * string))))
string-take : (number --> (string --> string))
string-drop : (number --> (string --> string))
string-take-right : (number --> (string --> string))
string-drop-right : (number --> (string --> string))
substring : (number --> (number --> (string --> string)))
string-pad : (ustring --> (number --> (string --> string)))
string-count : (string --> (string --> number))
string-count-h : (string --> (string --> (number --> (number --> number))))
string-replace-all : (string --> (string --> (string --> string)))
string-replace-all-h : (string --> (string --> (string --> (number --> (string -
-> string)))))
string-replace : (string --> (string --> (number --> (string --> string))))
string-replace-h : (string --> (string --> (string --> (number --> (string --> s
tring)))))
string-delete-all : (string --> (string --> string))
delete-substring : (number --> (number --> (string --> string)))
string-n-copy : (number --> (string --> string))
string-n-copy-h : (number --> (string --> (string --> string)))
string-trim-left : ((ustring --> boolean) --> (string --> string))
string-trim-right : ((ustring --> boolean) --> (string --> string))
string-trim : ((ustring --> boolean) --> (string --> string))
string-reverse : (string --> string)
string-reverse-h : (string --> (string --> string))
string-tokenise : ((ustring --> boolean) --> (string --> (list string)))
string-tokenise-h : ((ustring --> boolean) --> (string --> (string --> ((list st
ring) --> (list string)))))
string-interpose : (string --> (string --> string))
string-interpose-h : (string --> (string --> (string --> string)))
string-join : (string --> ((list string) --> string))
string-join-h : (string --> ((list string) --> (string --> string)))
string-filter : ((ustring --> boolean) --> (string --> string))
string-filter-h : ((ustring --> boolean) --> (string --> (string --> string)))
string-count-ustrings : ((ustring --> boolean) --> (string --> number))
string-reduce : ((ustring --> (B --> B)) --> (B --> (string --> B)))
string-reduce' : ((ustring --> (B --> B)) --> (B --> (string --> B)))
string-reduce-h : ((ustring --> (B --> B)) --> (B --> (string --> (B --> B))))
string-foldl : ((ustring --> (B --> B)) --> (B --> (string --> B)))
list->string : ((list string) --> string)
string-list->str-h : ((list string) --> (string --> string))
string->number : (string --> number)
string-->decimal : (string --> number)
string-exptL : (string --> number)
string-->fraction : (string --> number)
string-->fraction-h : (string --> number)
string-str->int : (string --> number)
string-str->uint : (string --> number)
string-str->uint-h : (string --> (number --> number))
string-str->digit : (string --> number)
string-trim0s : (string --> string)
string-simplify : (string --> string)
string-radixBdigit->decimal : (ustring --> (number --> number))
string-adjust : (number --> number)
string-digit->str : (number --> string)
radixB->decimal : (string --> (number --> number))
string-hex' : (string --> number)
string-radixB->decimal-h : (string --> (number --> (number --> number)))
string-oct-hex->decimal : (string --> number)
string-oct-hex-dec->decimal : (string --> number)
decimal->radixB : (number --> (number --> string))
string-decimal->radixB-h : (number --> (number --> (string --> string)))
string-radixB->radixC : (string --> (number --> (number --> string)))
string-pow10+ : (number --> number)
string-pow10 : (number --> number)
string-abs : (number --> number)
string-/-pos : (number --> (number --> (number * number)))
string-div-w : (number --> (number --> (number --> (number --> (number * number)
))))
string-pow-2div : (number --> (number --> (number --> number)))
run time: 1.8720120787620544 secs

typechecked in 26614 inferences
loaded

run time: 2.1528138667345047 secs

typechecked in 26614 inferences
loaded
false
"C:/dev/workspace/ShenJ/src/main/shen//"
;;  Loading file C:\dev\workspace\ShenJ\src\main\shen\sys.lsp ...
;;  Loaded file C:\dev\workspace\ShenJ\src\main\shen\sys.lspT
stream->string
shell
write-string-to-file
tointlist
to-intlist
["byte" "char" "int" "long" "float" "double" "switch" "case" "public" "protected
" "private"]
ensure-not-reserved
name->method-name
name->class-name
javify-loop
ensure-valid-char
escape-java-ustring
escape-java-string
second
third
type-of
flip
flip3
assert
assertEquals
assert-test
string-pair?
string-empty?
traverse-result-type?
list-matches
foldl
foldr

run time: 2.3244148045778275 secs
loaded

(2-) (load "gen-java.shen")
write-source
parse-shen
method-sig
java-class-file
to-var-pair
to-var
kl-to-java-traverse
clean-whitespace
find-first?
get-second
parsed-kl-to-java
to-java-unit
java-compile-and-run
java-run
java-eval
java-primitive?
primitive-type?
single-param
two-params
arithmetic
comparison
logic
logic-to-java
combine-types
handle-unreachable-return
handle-unreachable-assignment
handle-cases
handle-case
kl-to-java
kl-file-to-java

run time: 0.6708042621612549 secs
loaded

(3-) (map (kl-file-to-java) ["kl/sys.kl" "kl/writer.kl" "kl/core.kl" "kl/prolog.
kl" "kl/yacc.kl"
"kl/declarations.kl" "kl/load.kl" "kl/macros.kl" "kl/reader.kl" "kl/sequent.kl"
"kl/t-star.kl"
"kl/toplevel.kl" "kl/track.kl" "kl/types.kl"])



Evaluating: [defun thaw [V650] [V650]]

null



Evaluating: [defun eval [V651] [let Macroexpand [shen-walk [lambda V652 [macroex
pand V652]] V651] [if [shen-packaged? Macroexpand] [map [lambda V653 [shen-eval-
without-macros V653]] [shen-package-contents Macroexpand]] [shen-eval-without-ma
cros Macroexpand]]]]

null



Evaluating: [defun shen-eval-without-macros [V654] [eval-kl [shen-elim-define [s
hen-proc-input+ V654]]]]

null



Evaluating: [defun shen-proc-input+ [V655] [cond [[and [cons? V655] [and [= inpu
t+ [hd V655]] [and [cons? [tl V655]] [and [cons? [tl [tl V655]]] [= [] [tl [tl [
tl V655]]]]]]]] [cons input+ [cons [hd [tl V655]] [cons [shen-rcons_form [hd [tl
 [tl V655]]]] []]]]] [[cons? V655] [map [lambda V656 [shen-proc-input+ V656]] V6
55]] [true V655]]]

null



Evaluating: [defun shen-elim-define [V657] [cond [[and [cons? V657] [and [= defi
ne [hd V657]] [cons? [tl V657]]]] [shen-shen->kl [hd [tl V657]] [tl [tl V657]]]]
 [[cons? V657] [map [lambda V658 [shen-elim-define V658]] V657]] [true V657]]]

null



Evaluating: [defun shen-packaged? [V665] [cond [[and [cons? V665] [and [= packag
e [hd V665]] [and [cons? [tl V665]] [cons? [tl [tl V665]]]]]] true] [true false]
]]

null



Evaluating: [defun external [V666] [trap-error [get V666 shen-external-symbols [
value shen-*property-vector*]] [lambda E [interror package ~A has not been used.
~ []]]]]

null



Evaluating: [defun shen-package-contents [V669] [cond [[and [cons? V669] [and [=
 package [hd V669]] [and [cons? [tl V669]] [and [= null [hd [tl V669]]] [cons? [
tl [tl V669]]]]]]] [tl [tl [tl V669]]]] [[and [cons? V669] [and [= package [hd V
669]] [and [cons? [tl V669]] [cons? [tl [tl V669]]]]]] [shen-packageh [hd [tl V6
69]] [hd [tl [tl V669]]] Code]] [true [shen-sys-error shen-package-contents]]]]

null



Evaluating: [defun shen-walk [V670 V671] [cond [[cons? V671] [V670 [map [lambda
Z [shen-walk V670 Z]] V671]]] [true [V670 V671]]]]

null



Evaluating: [defun compile [V672 V673 V674] [let O [V672 [@p V673 []]] [if [or [
= [fail] O] [not [empty? [fst O]]]] [shen-compile-error O V674] [snd O]]]]

null



Evaluating: [defun shen-compile-error [V687 V688] [cond [[= [] V688] [fail]] [[a
nd [tuple? V687] [cons? [fst V687]]] [V688 [fst V687]]] [true [interror syntax e
rror
 []]]]]

null



Evaluating: [defun <e> [V693] [cond [[tuple? V693] [@p [fst V693] []]] [true [sh
en-sys-error <e>]]]]

null



Evaluating: [defun fail-if [V694 V695] [if [V694 V695] [fail] V695]]

null



Evaluating: [defun @s [V696 V697] [cn V696 V697]]

null



Evaluating: [defun tc? [V702] [value shen-*tc*]]

null



Evaluating: [defun ps [V703] [trap-error [get V703 shen-source [value shen-*prop
erty-vector*]] [lambda E [interror ~A not found.
 [@p V703 []]]]]]

null



Evaluating: [defun explode [V704] [if [string? V704] [shen-explode-string V704]
[explode [intmake-string ~A [@p V704 []]]]]]

null



Evaluating: [defun shen-explode-string [V705] [cond [[=  V705] []] [true [let S
[pos V705 0] [let Ss [tlstr V705] [if [= Ss shen-eos] [] [cons S [shen-explode-s
tring Ss]]]]]]]]

null



Evaluating: [defun stinput [V710] [value *stinput*]]

null



Evaluating: [defun shen-+vector? [V711] [and [absvector? V711] [> [<-address V71
1 0] 0]]]

null



Evaluating: [defun vector [V712] [let Vector [absvector [+ V712 1]] [let ZeroSta
mp [address-> Vector 0 V712] [let Standard [if [= V712 0] ZeroStamp [shen-fillve
ctor ZeroStamp 1 V712 [fail]]] Standard]]]]

null



Evaluating: [defun shen-fillvector [V713 V714 V715 V716] [cond [[= V715 V714] [a
ddress-> V713 V715 V716]] [true [shen-fillvector [address-> V713 V714 V716] [+ 1
 V714] V715 V716]]]]

null



Evaluating: [defun vector? [V718] [and [absvector? V718] [trap-error [>= [<-addr
ess V718 0] 0] [lambda E false]]]]

null



Evaluating: [defun vector-> [V719 V720 V721] [if [= V720 0] [interror cannot acc
ess 0th element of a vector
 []] [address-> V719 V720 V721]]]

null



Evaluating: [defun <-vector [V722 V723] [if [= V723 0] [interror cannot access 0
th element of a vector
 []] [let VectorElement [<-address V722 V723] [if [= VectorElement [fail]] [inte
rror vector element not found
 []] VectorElement]]]]

null



Evaluating: [defun shen-posint? [V724] [and [integer? V724] [>= V724 0]]]

null



Evaluating: [defun limit [V725] [<-address V725 0]]

null



Evaluating: [defun symbol? [V726] [cond [[or [boolean? V726] [or [number? V726]
[string? V726]]] false] [true [trap-error [let Explode [explode V726] [shen-anal
yse-symbol? Explode]] [lambda E false]]]]]

null



Evaluating: [defun shen-analyse-symbol? [V727] [cond [[cons? V727] [and [shen-al
pha? [hd V727]] [shen-alphanums? [tl V727]]]] [true [shen-sys-error shen-analyse
-symbol?]]]]

null



Evaluating: [defun shen-alpha? [V728] [element? V728 [cons A [cons B [cons C [co
ns D [cons E [cons F [cons G [cons H [cons I [cons J [cons K [cons L [cons M [co
ns N [cons O [cons P [cons Q [cons R [cons S [cons T [cons U [cons V [cons W [co
ns X [cons Y [cons Z [cons a [cons b [cons c [cons d [cons e [cons f [cons g [co
ns h [cons i [cons j [cons k [cons l [cons m [cons n [cons o [cons p [cons q [co
ns r [cons s [cons t [cons u [cons v [cons w [cons x [cons y [cons z [cons = [co
ns * [cons / [cons + [cons - [cons _ [cons ? [cons $ [cons ! [cons @ [cons ~ [co
ns > [cons < [cons & [cons % [cons { [cons } [cons : [cons ; [cons ` [cons # [co
ns ' [cons . []]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]
]]]]]]]]]]]]

null



Evaluating: [defun shen-alphanums? [V729] [cond [[= [] V729] true] [[cons? V729]
 [and [shen-alphanum? [hd V729]] [shen-alphanums? [tl V729]]]] [true [shen-sys-e
rror shen-alphanums?]]]]

null



Evaluating: [defun shen-alphanum? [V730] [or [shen-alpha? V730] [shen-digit? V73
0]]]

null



Evaluating: [defun shen-digit? [V731] [element? V731 [cons 1 [cons 2 [cons 3 [co
ns 4 [cons 5 [cons 6 [cons 7 [cons 8 [cons 9 [cons 0 []]]]]]]]]]]]]

null



Evaluating: [defun variable? [V732] [cond [[or [boolean? V732] [or [number? V732
] [string? V732]]] false] [true [trap-error [let Explode [explode V732] [shen-an
alyse-variable? Explode]] [lambda E false]]]]]

null



Evaluating: [defun shen-analyse-variable? [V733] [cond [[cons? V733] [and [shen-
uppercase? [hd V733]] [shen-alphanums? [tl V733]]]] [true [shen-sys-error shen-a
nalyse-variable?]]]]

null



Evaluating: [defun shen-uppercase? [V734] [element? V734 [cons A [cons B [cons C
 [cons D [cons E [cons F [cons G [cons H [cons I [cons J [cons K [cons L [cons M
 [cons N [cons O [cons P [cons Q [cons R [cons S [cons T [cons U [cons V [cons W
 [cons X [cons Y [cons Z []]]]]]]]]]]]]]]]]]]]]]]]]]]]]

null



Evaluating: [defun gensym [V735] [concat V735 [set shen-*gensym* [+ 1 [value she
n-*gensym*]]]]]

null



Evaluating: [defun concat [V736 V737] [intern [cn [str V736] [str V737]]]]

null



Evaluating: [defun @p [V738 V739] [let Vector [absvector 3] [let Tag [address->
Vector 0 shen-tuple] [let Fst [address-> Vector 1 V738] [let Snd [address-> Vect
or 2 V739] Vector]]]]]

null



Evaluating: [defun fst [V740] [<-address V740 1]]

null



Evaluating: [defun snd [V741] [<-address V741 2]]

null



Evaluating: [defun tuple? [V742] [trap-error [and [absvector? V742] [= shen-tupl
e [<-address V742 0]]] [lambda E false]]]

null



Evaluating: [defun append [V743 V744] [cond [[= [] V743] V744] [[cons? V743] [co
ns [hd V743] [append [tl V743] V744]]] [true [shen-sys-error append]]]]

null



Evaluating: [defun @v [V745 V746] [let Limit [limit V746] [let NewVector [vector
 [+ Limit 1]] [let X+NewVector [vector-> NewVector 1 V745] [if [= Limit 0] X+New
Vector [shen-@v-help V746 1 Limit X+NewVector]]]]]]

null



Evaluating: [defun shen-@v-help [V747 V748 V749 V750] [cond [[= V749 V748] [shen
-copyfromvector V747 V750 V749 [+ V749 1]]] [true [shen-@v-help V747 [+ V748 1]
V749 [shen-copyfromvector V747 V750 V748 [+ V748 1]]]]]]

null



Evaluating: [defun shen-copyfromvector [V752 V753 V754 V755] [trap-error [vector
-> V753 V755 [<-vector V752 V754]] [lambda E V753]]]

null



Evaluating: [defun hdv [V756] [trap-error [<-vector V756 1] [lambda E [interror
hdv needs a non-empty vector as an argument; not ~S
 [@p V756 []]]]]]

null



Evaluating: [defun tlv [V757] [let Limit [limit V757] [if [= Limit 0] [interror
cannot take the tail of the empty vector
 []] [if [= Limit 1] [vector 0] [let NewVector [vector [- Limit 1]] [shen-tlv-he
lp V757 2 Limit [vector [- Limit 1]]]]]]]]

null



Evaluating: [defun shen-tlv-help [V758 V759 V760 V761] [cond [[= V760 V759] [she
n-copyfromvector V758 V761 V760 [- V760 1]]] [true [shen-tlv-help V758 [+ V759 1
] V760 [shen-copyfromvector V758 V761 V759 [- V759 1]]]]]]

null



Evaluating: [defun assoc [V771 V772] [cond [[= [] V772] []] [[and [cons? V772] [
and [cons? [hd V772]] [= [hd [hd V772]] V771]]] [hd V772]] [[cons? V772] [assoc
V771 [tl V772]]] [true [shen-sys-error assoc]]]]

null



Evaluating: [defun boolean? [V778] [cond [[= true V778] true] [[= false V778] tr
ue] [true false]]]

null



Evaluating: [defun nl [V779] [cond [[= 0 V779] 0] [true [do [intoutput
 []] [nl [- V779 1]]]]]]

null



Evaluating: [defun difference [V782 V783] [cond [[= [] V782] []] [[cons? V782] [
if [element? [hd V782] V783] [difference [tl V782] V783] [cons [hd V782] [differ
ence [tl V782] V783]]]] [true [shen-sys-error difference]]]]

null



Evaluating: [defun do [V784 V785] V785]

null



Evaluating: [defun element? [V794 V795] [cond [[= [] V795] false] [[and [cons? V
795] [= [hd V795] V794]] true] [[cons? V795] [element? V794 [tl V795]]] [true [s
hen-sys-error element?]]]]

null



Evaluating: [defun empty? [V801] [cond [[= [] V801] true] [true false]]]

null



Evaluating: [defun fix [V802 V803] [shen-fix-help V802 V803 [V802 V803]]]

null



Evaluating: [defun shen-fix-help [V810 V811 V812] [cond [[= V812 V811] V812] [tr
ue [shen-fix-help V810 V812 [V810 V812]]]]]

null



Evaluating: [defun put [V814 V815 V816 V817] [let N [hash V814 [limit V817]] [le
t Entry [trap-error [<-vector V817 N] [lambda E []]] [let Change [vector-> V817
N [shen-change-pointer-value V814 V815 V816 Entry]] V816]]]]

null



Evaluating: [defun shen-change-pointer-value [V820 V821 V822 V823] [cond [[= []
V823] [cons [cons [cons V820 [cons V821 []]] V822] []]] [[and [cons? V823] [and
[cons? [hd V823]] [and [cons? [hd [hd V823]]] [and [cons? [tl [hd [hd V823]]]] [
and [= [] [tl [tl [hd [hd V823]]]]] [and [= [hd [tl [hd [hd V823]]]] V821] [= [h
d [hd [hd V823]]] V820]]]]]]] [cons [cons [hd [hd V823]] V822] [tl V823]]] [[con
s? V823] [cons [hd V823] [shen-change-pointer-value V820 V821 V822 [tl V823]]]]
[true [shen-sys-error shen-change-pointer-value]]]]

null



Evaluating: [defun get [V826 V827 V828] [let N [hash V826 [limit V828]] [let Ent
ry [trap-error [<-vector V828 N] [lambda E [interror pointer not found
 []]]] [let Result [assoc [cons V826 [cons V827 []]] Entry] [if [empty? Result]
[interror value not found
 []] [tl Result]]]]]]

null



Evaluating: [defun hash [V829 V830] [let Hash [shen-mod [sum [map [lambda V831 [
string->n V831]] [explode V829]]] V830] [if [= 0 Hash] 1 Hash]]]

null



Evaluating: [defun shen-mod [V832 V833] [shen-modh V832 [shen-multiples V832 [co
ns V833 []]]]]

null



Evaluating: [defun shen-multiples [V834 V835] [cond [[and [cons? V835] [> [hd V8
35] V834]] [tl V835]] [[cons? V835] [shen-multiples V834 [cons [* 2 [hd V835]] V
835]]] [true [shen-sys-error shen-multiples]]]]

null



Evaluating: [defun shen-modh [V838 V839] [cond [[= 0 V838] 0] [[= [] V839] V838]
 [[and [cons? V839] [> [hd V839] V838]] [if [empty? [tl V839]] V838 [shen-modh V
838 [tl V839]]]] [[cons? V839] [shen-modh [- V838 [hd V839]] V839]] [true [shen-
sys-error shen-modh]]]]

null



Evaluating: [defun sum [V840] [cond [[= [] V840] 0] [[cons? V840] [+ [hd V840] [
sum [tl V840]]]] [true [shen-sys-error sum]]]]

null



Evaluating: [defun head [V847] [cond [[cons? V847] [hd V847]] [true [interror he
ad expects a non-empty list []]]]]

null



Evaluating: [defun tail [V854] [cond [[cons? V854] [tl V854]] [true [interror ta
il expects a non-empty list []]]]]

null



Evaluating: [defun hdstr [V855] [pos V855 0]]

null



Evaluating: [defun intersection [V858 V859] [cond [[= [] V858] []] [[cons? V858]
 [if [element? [hd V858] V859] [cons [hd V858] [intersection [tl V858] V859]] [i
ntersection [tl V858] V859]]] [true [shen-sys-error intersection]]]]

null



Evaluating: [defun reverse [V860] [shen-reverse_help V860 []]]

null



Evaluating: [defun shen-reverse_help [V861 V862] [cond [[= [] V861] V862] [[cons
? V861] [shen-reverse_help [tl V861] [cons [hd V861] V862]]] [true [shen-sys-err
or shen-reverse_help]]]]

null



Evaluating: [defun union [V863 V864] [cond [[= [] V863] V864] [[cons? V863] [if
[element? [hd V863] V864] [union [tl V863] V864] [cons [hd V863] [union [tl V863
] V864]]]] [true [shen-sys-error union]]]]

null



Evaluating: [defun y-or-n? [V865] [let Message [intoutput V865 []] [let Y-or-N [
intoutput  (y/n)  []] [let Input [intmake-string ~S [@p [input] []]] [if [= y In
put] true [if [= n Input] false [do [intoutput please answer y or n
 []] [y-or-n? V865]]]]]]]]

null



Evaluating: [defun not [V866] [if V866 false true]]

null



Evaluating: [defun subst [V875 V876 V877] [cond [[= V877 V876] V875] [[cons? V87
7] [cons [subst V875 V876 [hd V877]] [subst V875 V876 [tl V877]]]] [true V877]]]


null



Evaluating: [defun cd [V879] [set *home-directory* [if [= V879 ]  [intmake-strin
g ~A/ [@p V879 []]]]]]

null



Evaluating: [defun map [V880 V881] [shen-map-h V880 V881 []]]

null



Evaluating: [defun shen-map-h [V884 V885 V886] [cond [[= [] V885] [reverse V886]
] [[cons? V885] [shen-map-h V884 [tl V885] [cons [V884 [hd V885]] V886]]] [true
[shen-sys-error shen-map-h]]]]

null



Evaluating: [defun length [V887] [shen-length-h V887 0]]

null



Evaluating: [defun shen-length-h [V888 V889] [cond [[= [] V888] V889] [true [she
n-length-h [tl V888] [+ V889 1]]]]]

null



Evaluating: [defun occurrences [V898 V899] [cond [[= V899 V898] 1] [[cons? V899]
 [+ [occurrences V898 [hd V899]] [occurrences V898 [tl V899]]]] [true 0]]]

null



Evaluating: [defun nth [V907 V908] [cond [[and [= 1 V907] [cons? V908]] [hd V908
]] [[cons? V908] [nth [- V907 1] [tl V908]]] [true [shen-sys-error nth]]]]

null



Evaluating: [defun integer? [V909] [and [number? V909] [let Abs [shen-abs V909]
[shen-integer-test? Abs [shen-magless Abs 1]]]]]

null



Evaluating: [defun shen-abs [V910] [if [> V910 0] V910 [- 0 V910]]]

null



Evaluating: [defun shen-magless [V911 V912] [let Nx2 [* V912 2] [if [> Nx2 V911]
 V912 [shen-magless V911 Nx2]]]]

null



Evaluating: [defun shen-integer-test? [V916 V917] [cond [[= 0 V916] true] [[> 1
V916] false] [true [let Abs-N [- V916 V917] [if [> 0 Abs-N] [integer? V916] [she
n-integer-test? Abs-N V917]]]]]]

null



Evaluating: [defun mapcan [V920 V921] [cond [[= [] V921] []] [[cons? V921] [appe
nd [V920 [hd V921]] [mapcan V920 [tl V921]]]] [true [shen-sys-error mapcan]]]]

null



Evaluating: [defun read-file-as-bytelist [V922] [let Stream [open file V922 in]
[let Byte [read-byte Stream] [let Bytes [shen-read-file-as-bytelist-help Stream
Byte []] [let Close [close Stream] [reverse Bytes]]]]]]

null



Evaluating: [defun shen-read-file-as-bytelist-help [V923 V924 V925] [cond [[= -1
 V924] V925] [true [shen-read-file-as-bytelist-help V923 [read-byte V923] [cons
V924 V925]]]]]

null



Evaluating: [defun read-file-as-string [V926] [let Stream [open file V926 in] [s
hen-rfas-h Stream [read-byte Stream] ]]]

null



Evaluating: [defun shen-rfas-h [V927 V928 V929] [cond [[= -1 V928] [do [close V9
27] V929]] [true [shen-rfas-h V927 [read-byte V927] [cn V929 [n->string V928]]]]
]]

null



Evaluating: [defun == [V938 V939] [cond [[= V939 V938] true] [true false]]]

null



Evaluating: [defun abort [] [simple-error ]]

null



Evaluating: [defun read [] [hd [lineread]]]

null



Evaluating: [defun input [] [eval [read]]]

null



Evaluating: [defun input+ [V945 V946] [let Input [read] [let Check [shen-typeche
ck Input V946] [if [= false Check] [do [intoutput input is not of type ~R: pleas
e re-enter  [@p V946 []]] [input+ : V946]] [eval Input]]]]]

null



Evaluating: [defun bound? [V947] [and [symbol? V947] [let Val [trap-error [value
 V947] [lambda E shen-this-symbol-is-unbound]] [if [= Val shen-this-symbol-is-un
bound] false true]]]]

null



Evaluating: [defun shen-string->bytes [V948] [cond [[=  V948] []] [true [cons [s
tring->n [pos V948 0]] [shen-string->bytes [tlstr V948]]]]]]

null



Evaluating: [defun maxinferences [V949] [set shen-*maxinferences* V949]]

null



Evaluating: [defun inferences [V954] [value shen-*infs*]]

null



Evaluating: [defun shen-hush [V959] [cond [[= + V959] [set shen-*hush* shen-hush
ed]] [[= - V959] [set shen-*hush* shen-unhushed]] [true [interror 'hush' expects
 a + or a -
 []]]]]

null



Evaluating: [defun protect [V960] V960]

null



Evaluating: [defun shen-stoutput [V965] [value *stoutput*]]

null



Evaluating: [defun print [V1081] [do [pr [shen-ms-h [cons ~ [cons S []]] [@p V10
81 shen-skip]] [shen-stoutput 0]] V1081]]

null



Evaluating: [defun format [V1082 V1083 V1084] [cond [[= true V1082] [intoutput V
1083 [@p V1084 []]]] [[= false V1082] [intmake-string V1083 [@p V1084 []]]] [tru
e [pr [shen-ms-h [explode V1083] V1084] V1082]]]]

null



Evaluating: [defun intoutput [V1085 V1086] [pr [shen-ms-h [shen-explode-string V
1085] V1086] [shen-stoutput 0]]]

null



Evaluating: [defun interror [V1087 V1088] [simple-error [shen-ms-h [shen-explode
-string V1087] V1088]]]

null



Evaluating: [defun intmake-string [V1089 V1090] [shen-ms-h [shen-explode-string
V1089] V1090]]

null



Evaluating: [defun shen-ms-h [V1093 V1094] [cond [[= [] V1093] ] [[and [cons? V1
093] [and [= ~ [hd V1093]] [and [cons? [tl V1093]] [= % [hd [tl V1093]]]]]] [cn
[n->string 10] [shen-ms-h [tl [tl V1093]] V1094]]] [[and [cons? V1093] [and [= ~
 [hd V1093]] [and [cons? [tl V1093]] [and [tuple? V1094] [element? [hd [tl V1093
]] [cons A [cons S [cons R []]]]]]]]] [cn [shen-ob->str [hd [tl V1093]] [fst V10
94]] [shen-ms-h [tl [tl V1093]] [snd V1094]]]] [[cons? V1093] [cn [hd V1093] [sh
en-ms-h [tl V1093] V1094]]] [true [shen-sys-error shen-ms-h]]]]

null



Evaluating: [defun shen-ob->str [V1098 V1099] [cond [[= V1099 [fail]] ...] [[= [
] V1099] [if [= V1098 R] () []]] [[= V1099 [vector 0]] <>] [[cons? V1099] [shen-
cn-all [append [if [= V1098 R] [cons ( []] [cons [ []]] [append [cons [shen-ob->
str V1098 [hd V1099]] []] [append [shen-xmapcan [value *maximum-print-sequence-s
ize*] [lambda Z [cons   [cons [shen-ob->str V1098 Z] []]]] [tl V1099]] [if [= V1
098 R] [cons ) []] [cons ] []]]]]]]] [[vector? V1099] [let L [shen-vector->list
V1099 1] [let E [tlstr [shen-cn-all [shen-xmapcan [- [value *maximum-print-seque
nce-size*] 1] [lambda Z [cons   [cons [shen-ob->str V1098 [shen-blank-fail Z]] [
]]]] L]]] [let V [cn < [cn E >]] V]]]] [[and [not [string? V1099]] [absvector? V
1099]] [trap-error [shen-ob->str A [[<-address V1099 0] V1099]] [lambda Ignore [
let L [shen-vector->list V1099 0] [let E [tlstr [shen-cn-all [shen-xmapcan [- [v
alue *maximum-print-sequence-size*] 1] [lambda Z [cons   [cons [shen-ob->str V10
98 Z] []]]] L]]] [let V [cn < [cn E >]] V]]]]]] [[= ... V1099] ...] [true [if [a
nd [= V1098 A] [string? V1099]] V1099 [str V1099]]]]]

null



Evaluating: [defun shen-blank-fail [V1100] [cond [[= V1100 [fail]] ...] [true V1
100]]]

null



Evaluating: [defun shen-tuple [V1101] [intmake-string (@p ~S ~S) [@p [fst V1101]
 [@p [snd V1101] []]]]]

null



Evaluating: [defun shen-cn-all [V1102] [cond [[= [] V1102] ] [[cons? V1102] [cn
[hd V1102] [shen-cn-all [tl V1102]]]] [true [shen-sys-error shen-cn-all]]]]

null



Evaluating: [defun shen-xmapcan [V1115 V1116 V1117] [cond [[= [] V1117] []] [[=
0 V1115] [cons ... etc []]] [[cons? V1117] [append [V1116 [hd V1117]] [shen-xmap
can [- V1115 1] V1116 [tl V1117]]]] [true [cons  | [V1116 V1117]]]]]

null



Evaluating: [defun shen-vector->list [V1118 V1119] [shen-vector->listh V1118 V11
19 []]]

null



Evaluating: [defun shen-vector->listh [V1120 V1121 V1122] [let Y [trap-error [<-
address V1120 V1121] [lambda E shen-out-of-range]] [if [= Y shen-out-of-range] [
reverse V1122] [shen-vector->listh V1120 [+ V1121 1] [cons Y V1122]]]]]

null



Evaluating:                                                    The License

 The user is free to produce commercial applications with the software, to distr
ibute these applications in source or binary  form, and to charge monies for the
m as he sees fit and in concordance with the laws of the land subject to the fol
lowing  license.

 1. The license applies to all the software and all derived software and must ap
pear on such.
 2. It is illegal to distribute the software without this license attached to it
 and use of the software implies agreement
    with the license as such. It is illegal for anyone who is not the copyright
holder to tamper with or change the license.
 3. Neither the names of Lambda Associates or the copyright holder may be used t
o endorse or promote products built using
     the software without specific prior written permission from the copyright h
older.
 4. That possession of this license does not confer on the copyright holder any
special contractual obligation towards the    user. That in no event shall the c
opyright holder be liable for any direct, indirect, incidental, special, exempla
ry or   consequential damages (including but not limited to procurement of subst
itute goods or services, loss of use, data, or    profits; or business interrupt
ion), however caused and on any theory of liability, whether in contract, strict
 liability   or tort (including negligence) arising in any way out of the use of
 the software, even if advised of the possibility of   such damage.
5. It is permitted for the user to change the software, for the purpose of impro
ving performance, correcting an error, or    porting to a new platform, and dist
ribute the modified version of Shen (hereafter the modified version) provided th
e     resulting program conforms in all respects to the Shen standard and is iss
ued under that title. The user must make it clear   with his distribution that h
e/she is the author of the changes and what these changes are and why.
6. Derived versions of this software in whatever form are subject to the same re
strictions. In particular it is not          permitted to make derived copies of
 this software which do not conform to the Shen standard or appear under a diffe
rent title.
7. It is permitted to distribute versions of Shen which incorporate libraries, g
raphics or other facilities which are not    part of the Shen standard.

For an explication of this license see http://www.lambdassociates.org/News/june1
1/license.htm which explains this license in full.

                                                   The License

 The user is free to produce comm




Evaluating: [defun shen-shen->kl [V380 V381] [compile [lambda V382 [shen-<define
> V382]] [cons V380 V381] [lambda X [shen-shen-syntax-error V380 X]]]]

null



Evaluating: [defun shen-shen-syntax-error [V383 V384] [interror syntax error in
~A here:

 ~A
 [@p V383 [@p [shen-next-50 50 V384] []]]]]

null



Evaluating: [defun shen-<define> [V385] [let Result [let Parse_<name> [shen-<nam
e> V385] [if [not [= [fail] Parse_<name>]] [let Parse_<signature> [shen-<signatu
re> Parse_<name>] [if [not [= [fail] Parse_<signature>]] [let Parse_<rules> [she
n-<rules> Parse_<signature>] [if [not [= [fail] Parse_<rules>]] [shen-reassemble
 [fst Parse_<rules>] [shen-compile_to_machine_code [snd Parse_<name>] [snd Parse
_<rules>]]] [fail]]] [fail]]] [fail]]] [if [= Result [fail]] [let Result [let Pa
rse_<name> [shen-<name> V385] [if [not [= [fail] Parse_<name>]] [let Parse_<rule
s> [shen-<rules> Parse_<name>] [if [not [= [fail] Parse_<rules>]] [shen-reassemb
le [fst Parse_<rules>] [shen-compile_to_machine_code [snd Parse_<name>] [snd Par
se_<rules>]]] [fail]]] [fail]]] [if [= Result [fail]] [fail] Result]] Result]]]

null



Evaluating: [defun shen-<name> [V386] [let Result [if [cons? [fst V386]] [shen-r
eassemble [fst [shen-reassemble [tl [fst V386]] [snd V386]]] [if [and [symbol? [
hd [fst V386]]] [not [shen-sysfunc? [hd [fst V386]]]]] [hd [fst V386]] [interror
 ~A is not a legitimate function name.
 [@p [hd [fst V386]] []]]]] [fail]] [if [= Result [fail]] [fail] Result]]]

null



Evaluating: [defun shen-sysfunc? [V387] [element? V387 [value shen-*system*]]]

null



Evaluating: [defun shen-<signature> [V388] [let Result [if [and [cons? [fst V388
]] [= { [hd [fst V388]]]] [let Parse_<signature-help> [shen-<signature-help> [sh
en-reassemble [tl [fst V388]] [snd V388]]] [if [not [= [fail] Parse_<signature-h
elp>]] [if [and [cons? [fst Parse_<signature-help>]] [= } [hd [fst Parse_<signat
ure-help>]]]] [shen-reassemble [fst [shen-reassemble [tl [fst Parse_<signature-h
elp>]] [snd Parse_<signature-help>]]] [shen-normalise-type [shen-curry-type [snd
 Parse_<signature-help>]]]] [fail]] [fail]]] [fail]] [if [= Result [fail]] [fail
] Result]]]

null



Evaluating: [defun shen-curry-type [V391] [cond [[and [cons? V391] [and [cons? [
tl V391]] [and [= --> [hd [tl V391]]] [and [cons? [tl [tl V391]]] [and [cons? [t
l [tl [tl V391]]]] [= --> [hd [tl [tl [tl V391]]]]]]]]]] [shen-curry-type [cons
[hd V391] [cons --> [cons [tl [tl V391]] []]]]]] [[and [cons? V391] [and [= cons
 [hd V391]] [and [cons? [tl V391]] [and [cons? [tl [tl V391]]] [= [] [tl [tl [tl
 V391]]]]]]]] [cons list [cons [shen-curry-type [hd [tl V391]]] []]]] [[and [con
s? V391] [and [cons? [tl V391]] [and [= * [hd [tl V391]]] [and [cons? [tl [tl V3
91]]] [and [cons? [tl [tl [tl V391]]]] [= * [hd [tl [tl [tl V391]]]]]]]]]] [shen
-curry-type [cons [hd V391] [cons * [cons [tl [tl V391]] []]]]]] [[cons? V391] [
map [lambda V392 [shen-curry-type V392]] V391]] [true V391]]]

null



Evaluating: [defun shen-<signature-help> [V393] [let Result [if [cons? [fst V393
]] [let Parse_<signature-help> [shen-<signature-help> [shen-reassemble [tl [fst
V393]] [snd V393]]] [if [not [= [fail] Parse_<signature-help>]] [shen-reassemble
 [fst Parse_<signature-help>] [if [element? [hd [fst V393]] [cons { [cons } []]]
] [fail] [cons [hd [fst V393]] [snd Parse_<signature-help>]]]] [fail]]] [fail]]
[if [= Result [fail]] [let Result [let Parse_<e> [<e> V393] [if [not [= [fail] P
arse_<e>]] [shen-reassemble [fst Parse_<e>] []] [fail]]] [if [= Result [fail]] [
fail] Result]] Result]]]

null



Evaluating: [defun shen-<rules> [V394] [let Result [let Parse_<rule> [shen-<rule
> V394] [if [not [= [fail] Parse_<rule>]] [let Parse_<rules> [shen-<rules> Parse
_<rule>] [if [not [= [fail] Parse_<rules>]] [shen-reassemble [fst Parse_<rules>]
 [cons [snd Parse_<rule>] [snd Parse_<rules>]]] [fail]]] [fail]]] [if [= Result
[fail]] [let Result [let Parse_<rule> [shen-<rule> V394] [if [not [= [fail] Pars
e_<rule>]] [shen-reassemble [fst Parse_<rule>] [cons [snd Parse_<rule>] []]] [fa
il]]] [if [= Result [fail]] [fail] Result]] Result]]]

null



Evaluating: [defun shen-<rule> [V395] [let Result [let Parse_<patterns> [shen-<p
atterns> V395] [if [not [= [fail] Parse_<patterns>]] [if [and [cons? [fst Parse_
<patterns>]] [= -> [hd [fst Parse_<patterns>]]]] [let Parse_<action> [shen-<acti
on> [shen-reassemble [tl [fst Parse_<patterns>]] [snd Parse_<patterns>]]] [if [n
ot [= [fail] Parse_<action>]] [if [and [cons? [fst Parse_<action>]] [= where [hd
 [fst Parse_<action>]]]] [let Parse_<guard> [shen-<guard> [shen-reassemble [tl [
fst Parse_<action>]] [snd Parse_<action>]]] [if [not [= [fail] Parse_<guard>]] [
shen-reassemble [fst Parse_<guard>] [cons [snd Parse_<patterns>] [cons [cons whe
re [cons [snd Parse_<guard>] [cons [snd Parse_<action>] []]]] []]]] [fail]]] [fa
il]] [fail]]] [fail]] [fail]]] [if [= Result [fail]] [let Result [let Parse_<pat
terns> [shen-<patterns> V395] [if [not [= [fail] Parse_<patterns>]] [if [and [co
ns? [fst Parse_<patterns>]] [= -> [hd [fst Parse_<patterns>]]]] [let Parse_<acti
on> [shen-<action> [shen-reassemble [tl [fst Parse_<patterns>]] [snd Parse_<patt
erns>]]] [if [not [= [fail] Parse_<action>]] [shen-reassemble [fst Parse_<action
>] [cons [snd Parse_<patterns>] [cons [snd Parse_<action>] []]]] [fail]]] [fail]
] [fail]]] [if [= Result [fail]] [let Result [let Parse_<patterns> [shen-<patter
ns> V395] [if [not [= [fail] Parse_<patterns>]] [if [and [cons? [fst Parse_<patt
erns>]] [= <- [hd [fst Parse_<patterns>]]]] [let Parse_<action> [shen-<action> [
shen-reassemble [tl [fst Parse_<patterns>]] [snd Parse_<patterns>]]] [if [not [=
 [fail] Parse_<action>]] [if [and [cons? [fst Parse_<action>]] [= where [hd [fst
 Parse_<action>]]]] [let Parse_<guard> [shen-<guard> [shen-reassemble [tl [fst P
arse_<action>]] [snd Parse_<action>]]] [if [not [= [fail] Parse_<guard>]] [shen-
reassemble [fst Parse_<guard>] [cons [snd Parse_<patterns>] [cons [cons where [c
ons [snd Parse_<guard>] [cons [cons shen-choicepoint! [cons [snd Parse_<action>]
 []]] []]]] []]]] [fail]]] [fail]] [fail]]] [fail]] [fail]]] [if [= Result [fail
]] [let Result [let Parse_<patterns> [shen-<patterns> V395] [if [not [= [fail] P
arse_<patterns>]] [if [and [cons? [fst Parse_<patterns>]] [= <- [hd [fst Parse_<
patterns>]]]] [let Parse_<action> [shen-<action> [shen-reassemble [tl [fst Parse
_<patterns>]] [snd Parse_<patterns>]]] [if [not [= [fail] Parse_<action>]] [shen
-reassemble [fst Parse_<action>] [cons [snd Parse_<patterns>] [cons [cons shen-c
hoicepoint! [cons [snd Parse_<action>] []]] []]]] [fail]]] [fail]] [fail]]] [if
[= Result [fail]] [fail] Result]] Result]] Result]] Result]]]

null



Evaluating: [defun shen-fail_if [V396 V397] [if [V396 V397] [fail] V397]]

null



Evaluating: [defun shen-succeeds? [V402] [cond [[= V402 [fail]] false] [true tru
e]]]

null



Evaluating: [defun shen-<patterns> [V403] [let Result [let Parse_<pattern> [shen
-<pattern> V403] [if [not [= [fail] Parse_<pattern>]] [let Parse_<patterns> [she
n-<patterns> Parse_<pattern>] [if [not [= [fail] Parse_<patterns>]] [shen-reasse
mble [fst Parse_<patterns>] [cons [snd Parse_<pattern>] [snd Parse_<patterns>]]]
 [fail]]] [fail]]] [if [= Result [fail]] [let Result [let Parse_<e> [<e> V403] [
if [not [= [fail] Parse_<e>]] [shen-reassemble [fst Parse_<e>] []] [fail]]] [if
[= Result [fail]] [fail] Result]] Result]]]

null



Evaluating: [defun shen-<pattern> [V404] [let Result [if [and [cons? [fst V404]]
 [cons? [hd [fst V404]]]] [shen-snd-or-fail [if [and [cons? [fst [shen-reassembl
e [hd [fst V404]] [snd V404]]]] [= @p [hd [fst [shen-reassemble [hd [fst V404]]
[snd V404]]]]]] [let Parse_<pattern1> [shen-<pattern1> [shen-reassemble [tl [fst
 [shen-reassemble [hd [fst V404]] [snd V404]]]] [snd [shen-reassemble [hd [fst V
404]] [snd V404]]]]] [if [not [= [fail] Parse_<pattern1>]] [let Parse_<pattern2>
 [shen-<pattern2> Parse_<pattern1>] [if [not [= [fail] Parse_<pattern2>]] [shen-
reassemble [fst Parse_<pattern2>] [shen-reassemble [fst [shen-reassemble [tl [fs
t V404]] [snd V404]]] [cons @p [cons [snd Parse_<pattern1>] [cons [snd Parse_<pa
ttern2>] []]]]]] [fail]]] [fail]]] [fail]]] [fail]] [if [= Result [fail]] [let R
esult [if [and [cons? [fst V404]] [cons? [hd [fst V404]]]] [shen-snd-or-fail [if
 [and [cons? [fst [shen-reassemble [hd [fst V404]] [snd V404]]]] [= cons [hd [fs
t [shen-reassemble [hd [fst V404]] [snd V404]]]]]] [let Parse_<pattern1> [shen-<
pattern1> [shen-reassemble [tl [fst [shen-reassemble [hd [fst V404]] [snd V404]]
]] [snd [shen-reassemble [hd [fst V404]] [snd V404]]]]] [if [not [= [fail] Parse
_<pattern1>]] [let Parse_<pattern2> [shen-<pattern2> Parse_<pattern1>] [if [not
[= [fail] Parse_<pattern2>]] [shen-reassemble [fst Parse_<pattern2>] [shen-reass
emble [fst [shen-reassemble [tl [fst V404]] [snd V404]]] [cons cons [cons [snd P
arse_<pattern1>] [cons [snd Parse_<pattern2>] []]]]]] [fail]]] [fail]]] [fail]]]
 [fail]] [if [= Result [fail]] [let Result [if [and [cons? [fst V404]] [cons? [h
d [fst V404]]]] [shen-snd-or-fail [if [and [cons? [fst [shen-reassemble [hd [fst
 V404]] [snd V404]]]] [= @v [hd [fst [shen-reassemble [hd [fst V404]] [snd V404]
]]]]] [let Parse_<pattern1> [shen-<pattern1> [shen-reassemble [tl [fst [shen-rea
ssemble [hd [fst V404]] [snd V404]]]] [snd [shen-reassemble [hd [fst V404]] [snd
 V404]]]]] [if [not [= [fail] Parse_<pattern1>]] [let Parse_<pattern2> [shen-<pa
ttern2> Parse_<pattern1>] [if [not [= [fail] Parse_<pattern2>]] [shen-reassemble
 [fst Parse_<pattern2>] [shen-reassemble [fst [shen-reassemble [tl [fst V404]] [
snd V404]]] [cons @v [cons [snd Parse_<pattern1>] [cons [snd Parse_<pattern2>] [
]]]]]] [fail]]] [fail]]] [fail]]] [fail]] [if [= Result [fail]] [let Result [if
[and [cons? [fst V404]] [cons? [hd [fst V404]]]] [shen-snd-or-fail [if [and [con
s? [fst [shen-reassemble [hd [fst V404]] [snd V404]]]] [= @s [hd [fst [shen-reas
semble [hd [fst V404]] [snd V404]]]]]] [let Parse_<pattern1> [shen-<pattern1> [s
hen-reassemble [tl [fst [shen-reassemble [hd [fst V404]] [snd V404]]]] [snd [she
n-reassemble [hd [fst V404]] [snd V404]]]]] [if [not [= [fail] Parse_<pattern1>]
] [let Parse_<pattern2> [shen-<pattern2> Parse_<pattern1>] [if [not [= [fail] Pa
rse_<pattern2>]] [shen-reassemble [fst Parse_<pattern2>] [shen-reassemble [fst [
shen-reassemble [tl [fst V404]] [snd V404]]] [cons @s [cons [snd Parse_<pattern1
>] [cons [snd Parse_<pattern2>] []]]]]] [fail]]] [fail]]] [fail]]] [fail]] [if [
= Result [fail]] [let Result [if [and [cons? [fst V404]] [cons? [hd [fst V404]]]
] [shen-snd-or-fail [if [and [cons? [fst [shen-reassemble [hd [fst V404]] [snd V
404]]]] [= vector [hd [fst [shen-reassemble [hd [fst V404]] [snd V404]]]]]] [if
[and [cons? [fst [shen-reassemble [tl [fst [shen-reassemble [hd [fst V404]] [snd
 V404]]]] [snd [shen-reassemble [hd [fst V404]] [snd V404]]]]]] [= 0 [hd [fst [s
hen-reassemble [tl [fst [shen-reassemble [hd [fst V404]] [snd V404]]]] [snd [she
n-reassemble [hd [fst V404]] [snd V404]]]]]]]] [shen-reassemble [fst [shen-reass
emble [tl [fst [shen-reassemble [tl [fst [shen-reassemble [hd [fst V404]] [snd V
404]]]] [snd [shen-reassemble [hd [fst V404]] [snd V404]]]]]] [snd [shen-reassem
ble [tl [fst [shen-reassemble [hd [fst V404]] [snd V404]]]] [snd [shen-reassembl
e [hd [fst V404]] [snd V404]]]]]]] [shen-reassemble [fst [shen-reassemble [tl [f
st V404]] [snd V404]]] [cons vector [cons 0 []]]]] [fail]] [fail]]] [fail]] [if
[= Result [fail]] [let Result [if [cons? [fst V404]] [shen-reassemble [fst [shen
-reassemble [tl [fst V404]] [snd V404]]] [if [cons? [hd [fst V404]]] [interror ~
A is not a legitimate constructor
 [@p [hd [fst V404]] []]] [fail]]] [fail]] [if [= Result [fail]] [let Result [le
t Parse_<simple_pattern> [shen-<simple_pattern> V404] [if [not [= [fail] Parse_<
simple_pattern>]] [shen-reassemble [fst Parse_<simple_pattern>] [snd Parse_<simp
le_pattern>]] [fail]]] [if [= Result [fail]] [fail] Result]] Result]] Result]] R
esult]] Result]] Result]] Result]]]

null



Evaluating: [defun shen-<simple_pattern> [V405] [let Result [if [cons? [fst V405
]] [shen-reassemble [fst [shen-reassemble [tl [fst V405]] [snd V405]]] [if [= [h
d [fst V405]] _] [gensym X] [fail]]] [fail]] [if [= Result [fail]] [let Result [
if [cons? [fst V405]] [shen-reassemble [fst [shen-reassemble [tl [fst V405]] [sn
d V405]]] [if [element? [hd [fst V405]] [cons -> [cons <- []]]] [fail] [hd [fst
V405]]]] [fail]] [if [= Result [fail]] [fail] Result]] Result]]]

null



Evaluating: [defun shen-<pattern1> [V406] [let Result [let Parse_<pattern> [shen
-<pattern> V406] [if [not [= [fail] Parse_<pattern>]] [shen-reassemble [fst Pars
e_<pattern>] [snd Parse_<pattern>]] [fail]]] [if [= Result [fail]] [fail] Result
]]]

null



Evaluating: [defun shen-<pattern2> [V407] [let Result [let Parse_<pattern> [shen
-<pattern> V407] [if [not [= [fail] Parse_<pattern>]] [shen-reassemble [fst Pars
e_<pattern>] [snd Parse_<pattern>]] [fail]]] [if [= Result [fail]] [fail] Result
]]]

null



Evaluating: [defun shen-<action> [V408] [let Result [if [cons? [fst V408]] [shen
-reassemble [fst [shen-reassemble [tl [fst V408]] [snd V408]]] [hd [fst V408]]]
[fail]] [if [= Result [fail]] [fail] Result]]]

null



Evaluating: [defun shen-<guard> [V409] [let Result [if [cons? [fst V409]] [shen-
reassemble [fst [shen-reassemble [tl [fst V409]] [snd V409]]] [hd [fst V409]]] [
fail]] [if [= Result [fail]] [fail] Result]]]

null



Evaluating: [defun shen-compile_to_machine_code [V410 V411] [let Lambda+ [shen-c
ompile_to_lambda+ V410 V411] [let KL [shen-compile_to_kl V410 Lambda+] [let Reco
rd [shen-record-source V410 KL] KL]]]]

null



Evaluating: [defun shen-record-source [V414 V415] [cond [[value shen-*installing
-kl*] shen-skip] [true [put V414 shen-source V415 [value shen-*property-vector*]
]]]]

null



Evaluating: [defun shen-compile_to_lambda+ [V416 V417] [let Arity [shen-arityche
ck V416 V417] [let Free [map [lambda Rule [shen-free_variable_check V416 Rule]]
V417] [let Variables [shen-parameters Arity] [let Linear [map [lambda V418 [shen
-linearise V418]] [shen-strip-protect V417]] [let Abstractions [map [lambda V419
 [shen-abstract_rule V419]] Linear] [let Applications [map [lambda X [shen-appli
cation_build Variables X]] Abstractions] [cons Variables [cons Applications []]]
]]]]]]]

null



Evaluating: [defun shen-free_variable_check [V420 V421] [cond [[and [cons? V421]
 [and [cons? [tl V421]] [= [] [tl [tl V421]]]]] [let Bound [shen-extract_vars [h
d V421]] [let Free [shen-extract_free_vars Bound [hd [tl V421]]] [shen-free_vari
able_warnings V420 Free]]]] [true [shen-sys-error shen-free_variable_check]]]]

null



Evaluating: [defun shen-extract_vars [V422] [cond [[variable? V422] [cons V422 [
]]] [[cons? V422] [union [shen-extract_vars [hd V422]] [shen-extract_vars [tl V4
22]]]] [true []]]]

null



Evaluating: [defun shen-extract_free_vars [V433 V434] [cond [[and [cons? V434] [
and [= protect [hd V434]] [and [cons? [tl V434]] [= [] [tl [tl V434]]]]]] []] [[
and [variable? V434] [not [element? V434 V433]]] [cons V434 []]] [[and [cons? V4
34] [and [= lambda [hd V434]] [and [cons? [tl V434]] [and [cons? [tl [tl V434]]]
 [= [] [tl [tl [tl V434]]]]]]]] [shen-extract_free_vars [cons [hd [tl V434]] V43
3] [hd [tl [tl V434]]]]] [[and [cons? V434] [and [= let [hd V434]] [and [cons? [
tl V434]] [and [cons? [tl [tl V434]]] [and [cons? [tl [tl [tl V434]]]] [= [] [tl
 [tl [tl [tl V434]]]]]]]]]] [union [shen-extract_free_vars V433 [hd [tl [tl V434
]]]] [shen-extract_free_vars [cons [hd [tl V434]] V433] [hd [tl [tl [tl V434]]]]
]]] [[cons? V434] [union [shen-extract_free_vars V433 [hd V434]] [shen-extract_f
ree_vars V433 [tl V434]]]] [true []]]]

null



Evaluating: [defun shen-free_variable_warnings [V437 V438] [cond [[= [] V438] _]
 [true [interror error: the following variables are free in ~A: ~A [@p V437 [@p
[shen-list_variables V438] []]]]]]]

null



Evaluating: [defun shen-list_variables [V439] [cond [[and [cons? V439] [= [] [tl
 V439]]] [cn [str [hd V439]] .]] [[cons? V439] [cn [str [hd V439]] [cn ,  [shen-
list_variables [tl V439]]]]] [true [shen-sys-error shen-list_variables]]]]

null



Evaluating: [defun shen-strip-protect [V440] [cond [[and [cons? V440] [and [= pr
otect [hd V440]] [and [cons? [tl V440]] [= [] [tl [tl V440]]]]]] [hd [tl V440]]]
 [[cons? V440] [cons [shen-strip-protect [hd V440]] [shen-strip-protect [tl V440
]]]] [true V440]]]

null



Evaluating: [defun shen-linearise [V441] [cond [[and [cons? V441] [and [cons? [t
l V441]] [= [] [tl [tl V441]]]]] [shen-linearise_help [shen-flatten [hd V441]] [
hd V441] [hd [tl V441]]]] [true [shen-sys-error shen-linearise]]]]

null



Evaluating: [defun shen-flatten [V442] [cond [[= [] V442] []] [[cons? V442] [app
end [shen-flatten [hd V442]] [shen-flatten [tl V442]]]] [true [cons V442 []]]]]

null



Evaluating: [defun shen-linearise_help [V443 V444 V445] [cond [[= [] V443] [cons
 V444 [cons V445 []]]] [[cons? V443] [if [and [variable? [hd V443]] [element? [h
d V443] [tl V443]]] [let Var [gensym [hd V443]] [let NewAction [cons where [cons
 [cons = [cons [hd V443] [cons Var []]]] [cons V445 []]]] [let NewPatts [shen-li
nearise_X [hd V443] Var V444] [shen-linearise_help [tl V443] NewPatts NewAction]
]]] [shen-linearise_help [tl V443] V444 V445]]] [true [shen-sys-error shen-linea
rise_help]]]]

null



Evaluating: [defun shen-linearise_X [V454 V455 V456] [cond [[= V456 V454] V455]
[[cons? V456] [let L [shen-linearise_X V454 V455 [hd V456]] [if [= L [hd V456]]
[cons [hd V456] [shen-linearise_X V454 V455 [tl V456]]] [cons L [tl V456]]]]] [t
rue V456]]]

null



Evaluating: [defun shen-aritycheck [V458 V459] [cond [[and [cons? V459] [and [co
ns? [hd V459]] [and [cons? [tl [hd V459]]] [and [= [] [tl [tl [hd V459]]]] [= []
 [tl V459]]]]]] [do [shen-aritycheck-action [hd [tl [hd V459]]]] [shen-aritychec
k-name V458 [arity V458] [length [hd [hd V459]]]]]] [[and [cons? V459] [and [con
s? [hd V459]] [and [cons? [tl [hd V459]]] [and [= [] [tl [tl [hd V459]]]] [and [
cons? [tl V459]] [and [cons? [hd [tl V459]]] [and [cons? [tl [hd [tl V459]]]] [=
 [] [tl [tl [hd [tl V459]]]]]]]]]]]] [if [= [length [hd [hd V459]]] [length [hd
[hd [tl V459]]]]] [do [shen-aritycheck-action Action] [shen-aritycheck V458 [tl
V459]]] [interror arity error in ~A
 [@p V458 []]]]] [true [shen-sys-error shen-aritycheck]]]]

null



Evaluating: [defun shen-aritycheck-name [V468 V469 V470] [cond [[= -1 V469] V470
] [[= V470 V469] V470] [true [do [intoutput
warning: changing the arity of ~A can cause errors.
 [@p V468 []]] V470]]]]

null



Evaluating: [defun shen-aritycheck-action [V476] [cond [[cons? V476] [do [shen-a
ah [hd V476] [tl V476]] [map [lambda V477 [shen-aritycheck-action V477]] V476]]]
 [true shen-skip]]]

null



Evaluating: [defun shen-aah [V478 V479] [let Arity [arity V478] [let Len [length
 V479] [if [and [> Arity -1] [> Len Arity]] [intoutput warning: ~A might not lik
e ~A argument~A.
 [@p V478 [@p Len [@p [if [> Len 1] s ] []]]]] shen-skip]]]]

null



Evaluating: [defun shen-abstract_rule [V480] [cond [[and [cons? V480] [and [cons
? [tl V480]] [= [] [tl [tl V480]]]]] [shen-abstraction_build [hd V480] [hd [tl V
480]]]] [true [shen-sys-error shen-abstract_rule]]]]

null



Evaluating: [defun shen-abstraction_build [V481 V482] [cond [[= [] V481] V482] [
[cons? V481] [cons /. [cons [hd V481] [cons [shen-abstraction_build [tl V481] V4
82] []]]]] [true [shen-sys-error shen-abstraction_build]]]]

null



Evaluating: [defun shen-parameters [V483] [cond [[= 0 V483] []] [true [cons [gen
sym V] [shen-parameters [- V483 1]]]]]]

null



Evaluating: [defun shen-application_build [V484 V485] [cond [[= [] V484] V485] [
[cons? V484] [shen-application_build [tl V484] [cons V485 [cons [hd V484] []]]]]
 [true [shen-sys-error shen-application_build]]]]

null



Evaluating: [defun shen-compile_to_kl [V486 V487] [cond [[and [cons? V487] [and
[cons? [tl V487]] [= [] [tl [tl V487]]]]] [let Arity [shen-store-arity V486 [len
gth [hd V487]]] [let Reduce [map [lambda V488 [shen-reduce V488]] [hd [tl V487]]
] [let CondExpression [shen-cond-expression V486 [hd V487] Reduce] [let KL [cons
 defun [cons V486 [cons [hd V487] [cons CondExpression []]]]] KL]]]]] [true [she
n-sys-error shen-compile_to_kl]]]]

null



Evaluating: [defun shen-store-arity [V491 V492] [cond [[value shen-*installing-k
l*] shen-skip] [true [put V491 arity V492 [value shen-*property-vector*]]]]]

null



Evaluating: [defun shen-reduce [V493] [do [set shen-*teststack* []] [let Result
[shen-reduce_help V493] [cons [cons shen-tests [reverse [value shen-*teststack*]
]] [cons Result []]]]]]

null



Evaluating: [defun shen-reduce_help [V494] [cond [[and [cons? V494] [and [cons?
[hd V494]] [and [= /. [hd [hd V494]]] [and [cons? [tl [hd V494]]] [and [cons? [h
d [tl [hd V494]]]] [and [= cons [hd [hd [tl [hd V494]]]]] [and [cons? [tl [hd [t
l [hd V494]]]]] [and [cons? [tl [tl [hd [tl [hd V494]]]]]] [and [= [] [tl [tl [t
l [hd [tl [hd V494]]]]]]] [and [cons? [tl [tl [hd V494]]]] [and [= [] [tl [tl [t
l [hd V494]]]]] [and [cons? [tl V494]] [= [] [tl [tl V494]]]]]]]]]]]]]]] [do [sh
en-add_test [cons cons? [tl V494]]] [let Abstraction [cons /. [cons [hd [tl [hd
[tl [hd V494]]]]] [cons [cons /. [cons [hd [tl [tl [hd [tl [hd V494]]]]]] [cons
[shen-ebr [hd [tl V494]] [hd [tl [hd V494]]] [hd [tl [tl [hd V494]]]]] []]]] []]
]] [let Application [cons [cons Abstraction [cons [cons hd [tl V494]] []]] [cons
 [cons tl [tl V494]] []]] [shen-reduce_help Application]]]]] [[and [cons? V494]
[and [cons? [hd V494]] [and [= /. [hd [hd V494]]] [and [cons? [tl [hd V494]]] [a
nd [cons? [hd [tl [hd V494]]]] [and [= @p [hd [hd [tl [hd V494]]]]] [and [cons?
[tl [hd [tl [hd V494]]]]] [and [cons? [tl [tl [hd [tl [hd V494]]]]]] [and [= []
[tl [tl [tl [hd [tl [hd V494]]]]]]] [and [cons? [tl [tl [hd V494]]]] [and [= []
[tl [tl [tl [hd V494]]]]] [and [cons? [tl V494]] [= [] [tl [tl V494]]]]]]]]]]]]]
]] [do [shen-add_test [cons tuple? [tl V494]]] [let Abstraction [cons /. [cons [
hd [tl [hd [tl [hd V494]]]]] [cons [cons /. [cons [hd [tl [tl [hd [tl [hd V494]]
]]]] [cons [shen-ebr [hd [tl V494]] [hd [tl [hd V494]]] [hd [tl [tl [hd V494]]]]
] []]]] []]]] [let Application [cons [cons Abstraction [cons [cons fst [tl V494]
] []]] [cons [cons snd [tl V494]] []]] [shen-reduce_help Application]]]]] [[and
[cons? V494] [and [cons? [hd V494]] [and [= /. [hd [hd V494]]] [and [cons? [tl [
hd V494]]] [and [cons? [hd [tl [hd V494]]]] [and [= @v [hd [hd [tl [hd V494]]]]]
 [and [cons? [tl [hd [tl [hd V494]]]]] [and [cons? [tl [tl [hd [tl [hd V494]]]]]
] [and [= [] [tl [tl [tl [hd [tl [hd V494]]]]]]] [and [cons? [tl [tl [hd V494]]]
] [and [= [] [tl [tl [tl [hd V494]]]]] [and [cons? [tl V494]] [= [] [tl [tl V494
]]]]]]]]]]]]]]] [do [shen-add_test [cons shen-+vector? [tl V494]]] [let Abstract
ion [cons /. [cons [hd [tl [hd [tl [hd V494]]]]] [cons [cons /. [cons [hd [tl [t
l [hd [tl [hd V494]]]]]] [cons [shen-ebr [hd [tl V494]] [hd [tl [hd V494]]] [hd
[tl [tl [hd V494]]]]] []]]] []]]] [let Application [cons [cons Abstraction [cons
 [cons hdv [tl V494]] []]] [cons [cons tlv [tl V494]] []]] [shen-reduce_help App
lication]]]]] [[and [cons? V494] [and [cons? [hd V494]] [and [= /. [hd [hd V494]
]] [and [cons? [tl [hd V494]]] [and [cons? [hd [tl [hd V494]]]] [and [= @s [hd [
hd [tl [hd V494]]]]] [and [cons? [tl [hd [tl [hd V494]]]]] [and [cons? [tl [tl [
hd [tl [hd V494]]]]]] [and [= [] [tl [tl [tl [hd [tl [hd V494]]]]]]] [and [cons?
 [tl [tl [hd V494]]]] [and [= [] [tl [tl [tl [hd V494]]]]] [and [cons? [tl V494]
] [= [] [tl [tl V494]]]]]]]]]]]]]]] [do [shen-add_test [cons shen-+string? [tl V
494]]] [let Abstraction [cons /. [cons [hd [tl [hd [tl [hd V494]]]]] [cons [cons
 /. [cons [hd [tl [tl [hd [tl [hd V494]]]]]] [cons [shen-ebr [hd [tl V494]] [hd
[tl [hd V494]]] [hd [tl [tl [hd V494]]]]] []]]] []]]] [let Application [cons [co
ns Abstraction [cons [cons pos [cons [hd [tl V494]] [cons 0 []]]] []]] [cons [co
ns tlstr [tl V494]] []]] [shen-reduce_help Application]]]]] [[and [cons? V494] [
and [cons? [hd V494]] [and [= /. [hd [hd V494]]] [and [cons? [tl [hd V494]]] [an
d [cons? [tl [tl [hd V494]]]] [and [= [] [tl [tl [tl [hd V494]]]]] [and [cons? [
tl V494]] [and [= [] [tl [tl V494]]] [not [variable? [hd [tl [hd V494]]]]]]]]]]]
]] [do [shen-add_test [cons = [cons [hd [tl [hd V494]]] [tl V494]]]] [shen-reduc
e_help [hd [tl [tl [hd V494]]]]]]] [[and [cons? V494] [and [cons? [hd V494]] [an
d [= /. [hd [hd V494]]] [and [cons? [tl [hd V494]]] [and [cons? [tl [tl [hd V494
]]]] [and [= [] [tl [tl [tl [hd V494]]]]] [and [cons? [tl V494]] [= [] [tl [tl V
494]]]]]]]]]] [shen-reduce_help [shen-ebr [hd [tl V494]] [hd [tl [hd V494]]] [hd
 [tl [tl [hd V494]]]]]]] [[and [cons? V494] [and [= where [hd V494]] [and [cons?
 [tl V494]] [and [cons? [tl [tl V494]]] [= [] [tl [tl [tl V494]]]]]]]] [do [shen
-add_test [hd [tl V494]]] [shen-reduce_help [hd [tl [tl V494]]]]]] [[and [cons?
V494] [and [cons? [tl V494]] [= [] [tl [tl V494]]]]] [let Z [shen-reduce_help [h
d V494]] [if [= [hd V494] Z] V494 [shen-reduce_help [cons Z [tl V494]]]]]] [true
 V494]]]

null



Evaluating: [defun shen-+string? [V495] [cond [[=  V495] false] [true [string? V
495]]]]

null



Evaluating: [defun shen-+vector [V496] [cond [[= V496 [vector 0]] false] [true [
vector? V496]]]]

null



Evaluating: [defun shen-ebr [V505 V506 V507] [cond [[= V507 V506] V505] [[and [c
ons? V507] [and [= /. [hd V507]] [and [cons? [tl V507]] [and [cons? [tl [tl V507
]]] [and [= [] [tl [tl [tl V507]]]] [> [occurrences V506 [hd [tl V507]]] 0]]]]]]
 V507] [[and [cons? V507] [and [= let [hd V507]] [and [cons? [tl V507]] [and [co
ns? [tl [tl V507]]] [and [cons? [tl [tl [tl V507]]]] [and [= [] [tl [tl [tl [tl
V507]]]]] [= [hd [tl V507]] V506]]]]]]] [cons let [cons [hd [tl V507]] [cons [sh
en-ebr V505 [hd [tl V507]] [hd [tl [tl V507]]]] [tl [tl [tl V507]]]]]]] [[cons?
V507] [cons [shen-ebr V505 V506 [hd V507]] [shen-ebr V505 V506 [tl V507]]]] [tru
e V507]]]

null



Evaluating: [defun shen-add_test [V510] [set shen-*teststack* [cons V510 [value
shen-*teststack*]]]]

null



Evaluating: [defun shen-cond-expression [V511 V512 V513] [let Err [shen-err-cond
ition V511] [let Cases [shen-case-form V513 Err] [let EncodeChoices [shen-encode
-choices Cases V511] [shen-cond-form EncodeChoices]]]]]

null



Evaluating: [defun shen-cond-form [V516] [cond [[and [cons? V516] [and [cons? [h
d V516]] [and [= true [hd [hd V516]]] [and [cons? [tl [hd V516]]] [= [] [tl [tl
[hd V516]]]]]]]] [hd [tl [hd V516]]]] [true [cons cond V516]]]]

null



Evaluating: [defun shen-encode-choices [V519 V520] [cond [[= [] V519] []] [[and
[cons? V519] [and [cons? [hd V519]] [and [= true [hd [hd V519]]] [and [cons? [tl
 [hd V519]]] [and [cons? [hd [tl [hd V519]]]] [and [= shen-choicepoint! [hd [hd
[tl [hd V519]]]]] [and [cons? [tl [hd [tl [hd V519]]]]] [and [= [] [tl [tl [hd [
tl [hd V519]]]]]] [and [= [] [tl [tl [hd V519]]]] [= [] [tl V519]]]]]]]]]]] [con
s [cons true [cons [cons let [cons Result [cons [hd [tl [hd [tl [hd V519]]]]] [c
ons [cons if [cons [cons = [cons Result [cons [cons fail []] []]]] [cons [if [va
lue shen-*installing-kl*] [cons shen-sys-error [cons V520 []]] [cons shen-f_erro
r [cons V520 []]]] [cons Result []]]]] []]]]] []]] []]] [[and [cons? V519] [and
[cons? [hd V519]] [and [= true [hd [hd V519]]] [and [cons? [tl [hd V519]]] [and
[cons? [hd [tl [hd V519]]]] [and [= shen-choicepoint! [hd [hd [tl [hd V519]]]]]
[and [cons? [tl [hd [tl [hd V519]]]]] [and [= [] [tl [tl [hd [tl [hd V519]]]]]]
[= [] [tl [tl [hd V519]]]]]]]]]]]] [cons [cons true [cons [cons let [cons Result
 [cons [hd [tl [hd [tl [hd V519]]]]] [cons [cons if [cons [cons = [cons Result [
cons [cons fail []] []]]] [cons [shen-cond-form [shen-encode-choices [tl V519] V
520]] [cons Result []]]]] []]]]] []]] []]] [[and [cons? V519] [and [cons? [hd V5
19]] [and [cons? [tl [hd V519]]] [and [cons? [hd [tl [hd V519]]]] [and [= shen-c
hoicepoint! [hd [hd [tl [hd V519]]]]] [and [cons? [tl [hd [tl [hd V519]]]]] [and
 [= [] [tl [tl [hd [tl [hd V519]]]]]] [= [] [tl [tl [hd V519]]]]]]]]]]] [cons [c
ons true [cons [cons let [cons Freeze [cons [cons freeze [cons [shen-cond-form [
shen-encode-choices [tl V519] V520]] []]] [cons [cons if [cons [hd [hd V519]] [c
ons [cons let [cons Result [cons [hd [tl [hd [tl [hd V519]]]]] [cons [cons if [c
ons [cons = [cons Result [cons [cons fail []] []]]] [cons [cons thaw [cons Freez
e []]] [cons Result []]]]] []]]]] [cons [cons thaw [cons Freeze []]] []]]]] []]]
]] []]] []]] [[and [cons? V519] [and [cons? [hd V519]] [and [cons? [tl [hd V519]
]] [= [] [tl [tl [hd V519]]]]]]] [cons [hd V519] [shen-encode-choices [tl V519]
V520]]] [true [shen-sys-error shen-encode-choices]]]]

null



Evaluating: [defun shen-case-form [V525 V526] [cond [[= [] V525] [cons V526 []]]
 [[and [cons? V525] [and [cons? [hd V525]] [and [cons? [hd [hd V525]]] [and [= s
hen-tests [hd [hd [hd V525]]]] [and [= [] [tl [hd [hd V525]]]] [and [cons? [tl [
hd V525]]] [and [cons? [hd [tl [hd V525]]]] [and [= shen-choicepoint! [hd [hd [t
l [hd V525]]]]] [and [cons? [tl [hd [tl [hd V525]]]]] [and [= [] [tl [tl [hd [tl
 [hd V525]]]]]] [= [] [tl [tl [hd V525]]]]]]]]]]]]]] [cons [cons true [tl [hd V5
25]]] [shen-case-form [tl V525] V526]]] [[and [cons? V525] [and [cons? [hd V525]
] [and [cons? [hd [hd V525]]] [and [= shen-tests [hd [hd [hd V525]]]] [and [= []
 [tl [hd [hd V525]]]] [and [cons? [tl [hd V525]]] [= [] [tl [tl [hd V525]]]]]]]]
]] [cons [cons true [tl [hd V525]]] []]] [[and [cons? V525] [and [cons? [hd V525
]] [and [cons? [hd [hd V525]]] [and [= shen-tests [hd [hd [hd V525]]]] [and [con
s? [tl [hd V525]]] [= [] [tl [tl [hd V525]]]]]]]]] [cons [cons [shen-embed-and [
tl [hd [hd V525]]]] [tl [hd V525]]] [shen-case-form [tl V525] V526]]] [true [she
n-sys-error shen-case-form]]]]

null



Evaluating: [defun shen-embed-and [V527] [cond [[and [cons? V527] [= [] [tl V527
]]] [hd V527]] [[cons? V527] [cons and [cons [hd V527] [cons [shen-embed-and [tl
 V527]] []]]]] [true [shen-sys-error shen-embed-and]]]]

null



Evaluating: [defun shen-err-condition [V528] [cond [[value shen-*installing-kl*]
 [cons true [cons [cons shen-sys-error [cons V528 []]] []]]] [true [cons true [c
ons [cons shen-f_error [cons V528 []]] []]]]]]

null



Evaluating: [defun shen-sys-error [V529] [interror system function ~A: unexpecte
d argument
 [@p V529 []]]]

null



Evaluating:                                                    The License

 The user is free to produce commercial applications with the software, to distr
ibute these applications in source or binary  form, and to charge monies for the
m as he sees fit and in concordance with the laws of the land subject to the fol
lowing  license.

 1. The license applies to all the software and all derived software and must ap
pear on such.
 2. It is illegal to distribute the software without this license attached to it
 and use of the software implies agreement
    with the license as such. It is illegal for anyone who is not the copyright
holder to tamper with or change the license.
 3. Neither the names of Lambda Associates or the copyright holder may be used t
o endorse or promote products built using
     the software without specific prior written permission from the copyright h
older.
 4. That possession of this license does not confer on the copyright holder any
special contractual obligation towards the    user. That in no event shall the c
opyright holder be liable for any direct, indirect, incidental, special, exempla
ry or   consequential damages (including but not limited to procurement of subst
itute goods or services, loss of use, data, or    profits; or business interrupt
ion), however caused and on any theory of liability, whether in contract, strict
 liability   or tort (including negligence) arising in any way out of the use of
 the software, even if advised of the possibility of   such damage.
5. It is permitted for the user to change the software, for the purpose of impro
ving performance, correcting an error, or    porting to a new platform, and dist
ribute the modified version of Shen (hereafter the modified version) provided th
e     resulting program conforms in all respects to the Shen standard and is iss
ued under that title. The user must make it clear   with his distribution that h
e/she is the author of the changes and what these changes are and why.
6. Derived versions of this software in whatever form are subject to the same re
strictions. In particular it is not          permitted to make derived copies of
 this software which do not conform to the Shen standard or appear under a diffe
rent title.
7. It is permitted to distribute versions of Shen which incorporate libraries, g
raphics or other facilities which are not    part of the Shen standard.

For an explication of this license see http://www.lambdassociates.org/News/june1
1/license.htm which explains this license in full.

                                                   The License

 The user is free to produce comm




Evaluating: [defun shen-<defprolog> [V1168] [let Result [let Parse_<predicate*>
[shen-<predicate*> V1168] [if [not [= [fail] Parse_<predicate*>]] [let Parse_<cl
auses*> [shen-<clauses*> Parse_<predicate*>] [if [not [= [fail] Parse_<clauses*>
]] [shen-reassemble [fst Parse_<clauses*>] [hd [shen-prolog->shen [map [lambda X
 [shen-insert-predicate [snd Parse_<predicate*>] X]] [snd Parse_<clauses*>]]]]]
[fail]]] [fail]]] [if [= Result [fail]] [fail] Result]]]

null



Evaluating: [defun shen-prolog-error [V1169 V1170] [interror prolog syntax error
 in ~A here:

 ~A
 [@p V1169 [@p [shen-next-50 50 V1170] []]]]]

null



Evaluating: [defun shen-next-50 [V1175 V1176] [cond [[= [] V1176] ] [[= 0 V1175]
 ] [[cons? V1176] [cn [shen-decons-string [hd V1176]] [shen-next-50 [- V1175 1]
[tl V1176]]]] [true [shen-sys-error shen-next-50]]]]

null



Evaluating: [defun shen-decons-string [V1177] [cond [[and [cons? V1177] [and [=
cons [hd V1177]] [and [cons? [tl V1177]] [and [cons? [tl [tl V1177]]] [= [] [tl
[tl [tl V1177]]]]]]]] [intmake-string ~S  [@p [shen-eval-cons V1177] []]]] [true
 [intmake-string ~R  [@p V1177 []]]]]]

null



Evaluating: [defun shen-insert-predicate [V1178 V1179] [cond [[and [cons? V1179]
 [and [cons? [tl V1179]] [= [] [tl [tl V1179]]]]] [cons [cons V1178 [hd V1179]]
[cons :- [tl V1179]]]] [true [shen-sys-error shen-insert-predicate]]]]

null



Evaluating: [defun shen-<predicate*> [V1180] [let Result [if [cons? [fst V1180]]
 [shen-reassemble [fst [shen-reassemble [tl [fst V1180]] [snd V1180]]] [hd [fst
V1180]]] [fail]] [if [= Result [fail]] [fail] Result]]]

null



Evaluating: [defun shen-<clauses*> [V1181] [let Result [let Parse_<clause*> [she
n-<clause*> V1181] [if [not [= [fail] Parse_<clause*>]] [let Parse_<clauses*> [s
hen-<clauses*> Parse_<clause*>] [if [not [= [fail] Parse_<clauses*>]] [shen-reas
semble [fst Parse_<clauses*>] [cons [snd Parse_<clause*>] [snd Parse_<clauses*>]
]] [fail]]] [fail]]] [if [= Result [fail]] [let Result [let Parse_<e> [<e> V1181
] [if [not [= [fail] Parse_<e>]] [shen-reassemble [fst Parse_<e>] [snd Parse_<e>
]] [fail]]] [if [= Result [fail]] [fail] Result]] Result]]]

null



Evaluating: [defun shen-<clause*> [V1182] [let Result [let Parse_<head*> [shen-<
head*> V1182] [if [not [= [fail] Parse_<head*>]] [if [and [cons? [fst Parse_<hea
d*>]] [= <-- [hd [fst Parse_<head*>]]]] [let Parse_<body*> [shen-<body*> [shen-r
eassemble [tl [fst Parse_<head*>]] [snd Parse_<head*>]]] [if [not [= [fail] Pars
e_<body*>]] [let Parse_<end*> [shen-<end*> Parse_<body*>] [if [not [= [fail] Par
se_<end*>]] [shen-reassemble [fst Parse_<end*>] [cons [snd Parse_<head*>] [cons
[snd Parse_<body*>] []]]] [fail]]] [fail]]] [fail]] [fail]]] [if [= Result [fail
]] [fail] Result]]]

null



Evaluating: [defun shen-<head*> [V1183] [let Result [let Parse_<term*> [shen-<te
rm*> V1183] [if [not [= [fail] Parse_<term*>]] [let Parse_<head*> [shen-<head*>
Parse_<term*>] [if [not [= [fail] Parse_<head*>]] [shen-reassemble [fst Parse_<h
ead*>] [cons [snd Parse_<term*>] [snd Parse_<head*>]]] [fail]]] [fail]]] [if [=
Result [fail]] [let Result [let Parse_<e> [<e> V1183] [if [not [= [fail] Parse_<
e>]] [shen-reassemble [fst Parse_<e>] [snd Parse_<e>]] [fail]]] [if [= Result [f
ail]] [fail] Result]] Result]]]

null



Evaluating: [defun shen-<term*> [V1184] [let Result [if [cons? [fst V1184]] [she
n-reassemble [fst [shen-reassemble [tl [fst V1184]] [snd V1184]]] [if [and [not
[= <-- [hd [fst V1184]]]] [shen-legitimate-term? [hd [fst V1184]]]] [shen-eval-c
ons [hd [fst V1184]]] [fail]]] [fail]] [if [= Result [fail]] [fail] Result]]]

null



Evaluating: [defun shen-legitimate-term? [V1189] [cond [[and [cons? V1189] [and
[= cons [hd V1189]] [and [cons? [tl V1189]] [and [cons? [tl [tl V1189]]] [= [] [
tl [tl [tl V1189]]]]]]]] [and [shen-legitimate-term? [hd [tl V1189]]] [shen-legi
timate-term? [hd [tl [tl V1189]]]]]] [[and [cons? V1189] [and [= mode [hd V1189]
] [and [cons? [tl V1189]] [and [cons? [tl [tl V1189]]] [and [= + [hd [tl [tl V11
89]]]] [= [] [tl [tl [tl V1189]]]]]]]]] [shen-legitimate-term? [hd [tl V1189]]]]
 [[and [cons? V1189] [and [= mode [hd V1189]] [and [cons? [tl V1189]] [and [cons
? [tl [tl V1189]]] [and [= - [hd [tl [tl V1189]]]] [= [] [tl [tl [tl V1189]]]]]]
]]] [shen-legitimate-term? [hd [tl V1189]]]] [[cons? V1189] false] [true true]]]


null



Evaluating: [defun shen-eval-cons [V1190] [cond [[and [cons? V1190] [and [= cons
 [hd V1190]] [and [cons? [tl V1190]] [and [cons? [tl [tl V1190]]] [= [] [tl [tl
[tl V1190]]]]]]]] [cons [shen-eval-cons [hd [tl V1190]]] [shen-eval-cons [hd [tl
 [tl V1190]]]]]] [[and [cons? V1190] [and [= mode [hd V1190]] [and [cons? [tl V1
190]] [and [cons? [tl [tl V1190]]] [= [] [tl [tl [tl V1190]]]]]]]] [cons mode [c
ons [shen-eval-cons [hd [tl V1190]]] [tl [tl V1190]]]]] [true V1190]]]

null



Evaluating: [defun shen-<body*> [V1191] [let Result [let Parse_<literal*> [shen-
<literal*> V1191] [if [not [= [fail] Parse_<literal*>]] [let Parse_<body*> [shen
-<body*> Parse_<literal*>] [if [not [= [fail] Parse_<body*>]] [shen-reassemble [
fst Parse_<body*>] [cons [snd Parse_<literal*>] [snd Parse_<body*>]]] [fail]]] [
fail]]] [if [= Result [fail]] [let Result [let Parse_<e> [<e> V1191] [if [not [=
 [fail] Parse_<e>]] [shen-reassemble [fst Parse_<e>] [snd Parse_<e>]] [fail]]] [
if [= Result [fail]] [fail] Result]] Result]]]

null



Evaluating: [defun shen-<literal*> [V1192] [let Result [if [and [cons? [fst V119
2]] [= ! [hd [fst V1192]]]] [shen-reassemble [fst [shen-reassemble [tl [fst V119
2]] [snd V1192]]] [cons cut [cons Throwcontrol []]]] [fail]] [if [= Result [fail
]] [let Result [if [cons? [fst V1192]] [shen-reassemble [fst [shen-reassemble [t
l [fst V1192]] [snd V1192]]] [if [cons? [hd [fst V1192]]] [hd [fst V1192]] [fail
]]] [fail]] [if [= Result [fail]] [fail] Result]] Result]]]

null



Evaluating: [defun shen-<end*> [V1193] [let Result [if [cons? [fst V1193]] [shen
-reassemble [fst [shen-reassemble [tl [fst V1193]] [snd V1193]]] [if [= [hd [fst
 V1193]] ;] shen-skip [fail]]] [fail]] [if [= Result [fail]] [fail] Result]]]

null



Evaluating: [defun cut [V1194 V1195 V1196] [let Result [thaw V1196] [if [= Resul
t false] V1194 Result]]]

null



Evaluating: [defun shen-insert_modes [V1197] [cond [[and [cons? V1197] [and [= m
ode [hd V1197]] [and [cons? [tl V1197]] [and [cons? [tl [tl V1197]]] [= [] [tl [
tl [tl V1197]]]]]]]] V1197] [[= [] V1197] []] [[cons? V1197] [cons [cons mode [c
ons [hd V1197] [cons + []]]] [cons mode [cons [shen-insert_modes [tl V1197]] [co
ns - []]]]]] [true V1197]]]

null



Evaluating: [defun shen-s-prolog [V1198] [map [lambda V1199 [eval V1199]] [shen-
prolog->shen V1198]]]

null



Evaluating: [defun shen-prolog->shen [V1200] [map [lambda V1201 [shen-compile_pr
olog_procedure V1201]] [shen-group_clauses [map [lambda V1202 [shen-s-prolog_cla
use V1202]] [mapcan [lambda V1203 [shen-head_abstraction V1203]] V1200]]]]]

null



Evaluating: [defun shen-s-prolog_clause [V1204] [cond [[and [cons? V1204] [and [
cons? [tl V1204]] [and [= :- [hd [tl V1204]]] [and [cons? [tl [tl V1204]]] [= []
 [tl [tl [tl V1204]]]]]]]] [cons [hd V1204] [cons :- [cons [map [lambda V1205 [s
hen-s-prolog_literal V1205]] [hd [tl [tl V1204]]]] []]]]] [true [shen-sys-error
shen-s-prolog_clause]]]]

null



Evaluating: [defun shen-head_abstraction [V1206] [cond [[and [cons? V1206] [and
[cons? [tl V1206]] [and [= :- [hd [tl V1206]]] [and [cons? [tl [tl V1206]]] [and
 [= [] [tl [tl [tl V1206]]]] [< [shen-complexity_head [hd V1206]] [value shen-*m
axcomplexity*]]]]]]] [cons V1206 []]] [[and [cons? V1206] [and [cons? [hd V1206]
] [and [cons? [tl V1206]] [and [= :- [hd [tl V1206]]] [and [cons? [tl [tl V1206]
]] [= [] [tl [tl [tl V1206]]]]]]]]] [let Terms [map [lambda Y [gensym V]] [tl [h
d V1206]]] [let XTerms [shen-rcons_form [shen-remove_modes [tl [hd V1206]]]] [le
t Literal [cons unify [cons [shen-cons_form Terms] [cons XTerms []]]] [let Claus
e [cons [cons [hd [hd V1206]] Terms] [cons :- [cons [cons Literal [hd [tl [tl V1
206]]]] []]]] [cons Clause []]]]]]] [true [shen-sys-error shen-head_abstraction]
]]]

null



Evaluating: [defun shen-complexity_head [V1211] [cond [[cons? V1211] [shen-produ
ct [map [lambda V1212 [shen-complexity V1212]] [tl V1211]]]] [true [shen-sys-err
or shen-complexity_head]]]]

null



Evaluating: [defun shen-complexity [V1220] [cond [[and [cons? V1220] [and [= mod
e [hd V1220]] [and [cons? [tl V1220]] [and [cons? [hd [tl V1220]]] [and [= mode
[hd [hd [tl V1220]]]] [and [cons? [tl [hd [tl V1220]]]] [and [cons? [tl [tl [hd
[tl V1220]]]]] [and [= [] [tl [tl [tl [hd [tl V1220]]]]]] [and [cons? [tl [tl V1
220]]] [= [] [tl [tl [tl V1220]]]]]]]]]]]]] [shen-complexity [hd [tl V1220]]]] [
[and [cons? V1220] [and [= mode [hd V1220]] [and [cons? [tl V1220]] [and [cons?
[hd [tl V1220]]] [and [cons? [tl [tl V1220]]] [and [= + [hd [tl [tl V1220]]]] [=
 [] [tl [tl [tl V1220]]]]]]]]]] [* 2 [* [shen-complexity [cons mode [cons [hd [h
d [tl V1220]]] [tl [tl V1220]]]]] [shen-complexity [cons mode [cons [tl [hd [tl
V1220]]] [tl [tl V1220]]]]]]]] [[and [cons? V1220] [and [= mode [hd V1220]] [and
 [cons? [tl V1220]] [and [cons? [hd [tl V1220]]] [and [cons? [tl [tl V1220]]] [a
nd [= - [hd [tl [tl V1220]]]] [= [] [tl [tl [tl V1220]]]]]]]]]] [* [shen-complex
ity [cons mode [cons [hd [hd [tl V1220]]] [tl [tl V1220]]]]] [shen-complexity [c
ons mode [cons [tl [hd [tl V1220]]] [tl [tl V1220]]]]]]] [[and [cons? V1220] [an
d [= mode [hd V1220]] [and [cons? [tl V1220]] [and [cons? [tl [tl V1220]]] [and
[= [] [tl [tl [tl V1220]]]] [variable? [hd [tl V1220]]]]]]]] 1] [[and [cons? V12
20] [and [= mode [hd V1220]] [and [cons? [tl V1220]] [and [cons? [tl [tl V1220]]
] [and [= + [hd [tl [tl V1220]]]] [= [] [tl [tl [tl V1220]]]]]]]]] 2] [[and [con
s? V1220] [and [= mode [hd V1220]] [and [cons? [tl V1220]] [and [cons? [tl [tl V
1220]]] [and [= - [hd [tl [tl V1220]]]] [= [] [tl [tl [tl V1220]]]]]]]]] 1] [tru
e [shen-complexity [cons mode [cons V1220 [cons + []]]]]]]]

null



Evaluating: [defun shen-product [V1221] [cond [[= [] V1221] 1] [[cons? V1221] [*
 [hd V1221] [shen-product [tl V1221]]]] [true [shen-sys-error shen-product]]]]

null



Evaluating: [defun shen-s-prolog_literal [V1222] [cond [[and [cons? V1222] [and
[= is [hd V1222]] [and [cons? [tl V1222]] [and [cons? [tl [tl V1222]]] [= [] [tl
 [tl [tl V1222]]]]]]]] [cons bind [cons [hd [tl V1222]] [cons [shen-insert_deref
 [hd [tl [tl V1222]]]] []]]]] [[and [cons? V1222] [and [= when [hd V1222]] [and
[cons? [tl V1222]] [= [] [tl [tl V1222]]]]]] [cons fwhen [cons [shen-insert_dere
f [hd [tl V1222]]] []]]] [[and [cons? V1222] [and [= bind [hd V1222]] [and [cons
? [tl V1222]] [and [cons? [tl [tl V1222]]] [= [] [tl [tl [tl V1222]]]]]]]] [cons
 bind [cons [hd [tl V1222]] [cons [shen-insert_lazyderef [hd [tl [tl V1222]]]] [
]]]]] [[and [cons? V1222] [and [= fwhen [hd V1222]] [and [cons? [tl V1222]] [= [
] [tl [tl V1222]]]]]] [cons fwhen [cons [shen-insert_lazyderef [hd [tl V1222]]]
[]]]] [[cons? V1222] [cons [shen-m_prolog_to_s-prolog_predicate [hd V1222]] [tl
V1222]]] [true [shen-sys-error shen-s-prolog_literal]]]]

null



Evaluating: [defun shen-insert_deref [V1223] [cond [[variable? V1223] [cons shen
-deref [cons V1223 [cons ProcessN []]]]] [[cons? V1223] [cons [shen-insert_deref
 [hd V1223]] [shen-insert_deref [tl V1223]]]] [true V1223]]]

null



Evaluating: [defun shen-insert_lazyderef [V1224] [cond [[variable? V1224] [cons
shen-lazyderef [cons V1224 [cons ProcessN []]]]] [[cons? V1224] [cons [shen-inse
rt_lazyderef [hd V1224]] [shen-insert_lazyderef [tl V1224]]]] [true V1224]]]

null



Evaluating: [defun shen-m_prolog_to_s-prolog_predicate [V1225] [cond [[= = V1225
] unify] [[= =! V1225] unify!] [[= == V1225] identical] [true V1225]]]

null



Evaluating: [defun shen-group_clauses [V1226] [cond [[= [] V1226] []] [[cons? V1
226] [let Group [shen-collect [lambda X [shen-same_predicate? [hd V1226] X]] V12
26] [let Rest [difference V1226 Group] [cons Group [shen-group_clauses Rest]]]]]
 [true [shen-sys-error shen-group_clauses]]]]

null



Evaluating: [defun shen-collect [V1229 V1230] [cond [[= [] V1230] []] [[cons? V1
230] [if [V1229 [hd V1230]] [cons [hd V1230] [shen-collect V1229 [tl V1230]]] [s
hen-collect V1229 [tl V1230]]]] [true [shen-sys-error shen-collect]]]]

null



Evaluating: [defun shen-same_predicate? [V1247 V1248] [cond [[and [cons? V1247]
[and [cons? [hd V1247]] [and [cons? V1248] [cons? [hd V1248]]]]] [= [hd [hd V124
7]] [hd [hd V1248]]]] [true [shen-sys-error shen-same_predicate?]]]]

null



Evaluating: [defun shen-compile_prolog_procedure [V1249] [let F [shen-procedure_
name V1249] [let Shen [shen-clauses-to-shen F V1249] Shen]]]

null



Evaluating: [defun shen-procedure_name [V1262] [cond [[and [cons? V1262] [and [c
ons? [hd V1262]] [cons? [hd [hd V1262]]]]] [hd [hd [hd V1262]]]] [true [shen-sys
-error shen-procedure_name]]]]

null



Evaluating: [defun shen-clauses-to-shen [V1263 V1264] [let Linear [map [lambda V
1265 [shen-linearise-clause V1265]] V1264] [let Arity [shen-prolog-aritycheck V1
263 [map [lambda V1266 [head V1266]] V1264]] [let Parameters [shen-parameters Ar
ity] [let AUM_instructions [map [lambda X [shen-aum X Parameters]] Linear] [let
Code [shen-catch-cut [shen-nest-disjunct [map [lambda V1267 [shen-aum_to_shen V1
267]] AUM_instructions]]] [let ShenDef [cons define [cons V1263 [append Paramete
rs [append [cons ProcessN [cons Continuation []]] [cons -> [cons Code []]]]]]] S
henDef]]]]]]]

null



Evaluating: [defun shen-catch-cut [V1268] [cond [[not [shen-occurs? cut V1268]]
V1268] [true [cons let [cons Throwcontrol [cons [cons shen-catchpoint []] [cons
[cons shen-cutpoint [cons Throwcontrol [cons V1268 []]]] []]]]]]]]

null



Evaluating: [defun shen-catchpoint [] [set shen-*catch* [+ 1 [value shen-*catch*
]]]]

null



Evaluating: [defun shen-cutpoint [V1273 V1274] [cond [[= V1274 V1273] false] [tr
ue V1274]]]

null



Evaluating: [defun shen-nest-disjunct [V1276] [cond [[and [cons? V1276] [= [] [t
l V1276]]] [hd V1276]] [[cons? V1276] [shen-lisp-or [hd V1276] [shen-nest-disjun
ct [tl V1276]]]] [true [shen-sys-error shen-nest-disjunct]]]]

null



Evaluating: [defun shen-lisp-or [V1277 V1278] [cons let [cons Case [cons V1277 [
cons [cons if [cons [cons = [cons Case [cons false []]]] [cons V1278 [cons Case
[]]]]] []]]]]]

null



Evaluating: [defun shen-prolog-aritycheck [V1281 V1282] [cond [[and [cons? V1282
] [= [] [tl V1282]]] [- [length [hd V1282]] 1]] [[and [cons? V1282] [cons? [tl V
1282]]] [if [= [length [hd V1282]] [length [hd [tl V1282]]]] [shen-prolog-arityc
heck V1281 [tl V1282]] [interror arity error in prolog procedure ~A
 [@p [cons V1281 []] []]]]] [true [shen-sys-error shen-prolog-aritycheck]]]]

null



Evaluating: [defun shen-linearise-clause [V1283] [cond [[and [cons? V1283] [and
[cons? [tl V1283]] [and [= :- [hd [tl V1283]]] [and [cons? [tl [tl V1283]]] [= [
] [tl [tl [tl V1283]]]]]]]] [let Linear [shen-linearise [cons [hd V1283] [tl [tl
 V1283]]]] [shen-clause_form Linear]]] [true [shen-sys-error shen-linearise-clau
se]]]]

null



Evaluating: [defun shen-clause_form [V1284] [cond [[and [cons? V1284] [and [cons
? [tl V1284]] [= [] [tl [tl V1284]]]]] [cons [shen-explicit_modes [hd V1284]] [c
ons :- [cons [shen-cf_help [hd [tl V1284]]] []]]]] [true [shen-sys-error shen-cl
ause_form]]]]

null



Evaluating: [defun shen-explicit_modes [V1285] [cond [[cons? V1285] [cons [hd V1
285] [map [lambda V1286 [shen-em_help V1286]] [tl V1285]]]] [true [shen-sys-erro
r shen-explicit_modes]]]]

null



Evaluating: [defun shen-em_help [V1287] [cond [[and [cons? V1287] [and [= mode [
hd V1287]] [and [cons? [tl V1287]] [and [cons? [tl [tl V1287]]] [= [] [tl [tl [t
l V1287]]]]]]]] V1287] [true [cons mode [cons V1287 [cons + []]]]]]]

null



Evaluating: [defun shen-cf_help [V1288] [cond [[and [cons? V1288] [and [= where
[hd V1288]] [and [cons? [tl V1288]] [and [cons? [hd [tl V1288]]] [and [= = [hd [
hd [tl V1288]]]] [and [cons? [tl [hd [tl V1288]]]] [and [cons? [tl [tl [hd [tl V
1288]]]]] [and [= [] [tl [tl [tl [hd [tl V1288]]]]]] [and [cons? [tl [tl V1288]]
] [= [] [tl [tl [tl V1288]]]]]]]]]]]]] [cons [cons [if [value shen-*occurs*] uni
fy! unify] [tl [hd [tl V1288]]]] [shen-cf_help [hd [tl [tl V1288]]]]]] [true V12
88]]]

null



Evaluating: [defun occurs-check [V1293] [cond [[= + V1293] [set shen-*occurs* tr
ue]] [[= - V1293] [set shen-*occurs* false]] [true [interror occurs-check expect
s + or -
 []]]]]

null



Evaluating: [defun shen-aum [V1294 V1295] [cond [[and [cons? V1294] [and [cons?
[hd V1294]] [and [cons? [tl V1294]] [and [= :- [hd [tl V1294]]] [and [cons? [tl
[tl V1294]]] [= [] [tl [tl [tl V1294]]]]]]]]] [let MuApplication [shen-make_mu_a
pplication [cons shen-mu [cons [tl [hd V1294]] [cons [shen-continuation_call [tl
 [hd V1294]] [hd [tl [tl V1294]]]] []]]] V1295] [shen-mu_reduction MuApplication
 +]]] [true [shen-sys-error shen-aum]]]]

null



Evaluating: [defun shen-continuation_call [V1296 V1297] [let VTerms [cons Proces
sN [shen-extract_vars V1296]] [let VBody [shen-extract_vars V1297] [let Free [re
move Throwcontrol [difference VBody VTerms]] [shen-cc_help Free V1297]]]]]

null



Evaluating: [defun remove [V1298 V1299] [shen-remove-h V1298 V1299 []]]

null



Evaluating: [defun shen-remove-h [V1302 V1303 V1304] [cond [[= [] V1303] [revers
e V1304]] [[and [cons? V1303] [= [hd V1303] V1302]] [shen-remove-h [hd V1303] [t
l V1303] V1304]] [[cons? V1303] [shen-remove-h V1302 [tl V1303] [cons [hd V1303]
 V1304]]] [true [shen-sys-error shen-remove-h]]]]

null



Evaluating: [defun shen-cc_help [V1306 V1307] [cond [[and [= [] V1306] [= [] V13
07]] [cons shen-pop [cons shen-the [cons shen-stack []]]]] [[= [] V1307] [cons s
hen-rename [cons shen-the [cons shen-variables [cons in [cons V1306 [cons and [c
ons shen-then [cons [cons shen-pop [cons shen-the [cons shen-stack []]]] []]]]]]
]]]] [[= [] V1306] [cons call [cons shen-the [cons shen-continuation [cons V1307
 []]]]]] [true [cons shen-rename [cons shen-the [cons shen-variables [cons in [c
ons V1306 [cons and [cons shen-then [cons [cons call [cons shen-the [cons shen-c
ontinuation [cons V1307 []]]]] []]]]]]]]]]]]

null



Evaluating: [defun shen-make_mu_application [V1308 V1309] [cond [[and [cons? V13
08] [and [= shen-mu [hd V1308]] [and [cons? [tl V1308]] [and [= [] [hd [tl V1308
]]] [and [cons? [tl [tl V1308]]] [and [= [] [tl [tl [tl V1308]]]] [= [] V1309]]]
]]]] [hd [tl [tl V1308]]]] [[and [cons? V1308] [and [= shen-mu [hd V1308]] [and
[cons? [tl V1308]] [and [cons? [hd [tl V1308]]] [and [cons? [tl [tl V1308]]] [an
d [= [] [tl [tl [tl V1308]]]] [cons? V1309]]]]]]] [cons [cons shen-mu [cons [hd
[hd [tl V1308]]] [cons [shen-make_mu_application [cons shen-mu [cons [tl [hd [tl
 V1308]]] [tl [tl V1308]]]] [tl V1309]] []]]] [cons [hd V1309] []]]] [true [shen
-sys-error shen-make_mu_application]]]]

null



Evaluating: [defun shen-mu_reduction [V1316 V1317] [cond [[and [cons? V1316] [an
d [cons? [hd V1316]] [and [= shen-mu [hd [hd V1316]]] [and [cons? [tl [hd V1316]
]] [and [cons? [hd [tl [hd V1316]]]] [and [= mode [hd [hd [tl [hd V1316]]]]] [an
d [cons? [tl [hd [tl [hd V1316]]]]] [and [cons? [tl [tl [hd [tl [hd V1316]]]]]]
[and [= [] [tl [tl [tl [hd [tl [hd V1316]]]]]]] [and [cons? [tl [tl [hd V1316]]]
] [and [= [] [tl [tl [tl [hd V1316]]]]] [and [cons? [tl V1316]] [= [] [tl [tl V1
316]]]]]]]]]]]]]]] [shen-mu_reduction [cons [cons shen-mu [cons [hd [tl [hd [tl
[hd V1316]]]]] [tl [tl [hd V1316]]]]] [tl V1316]] [hd [tl [tl [hd [tl [hd V1316]
]]]]]]] [[and [cons? V1316] [and [cons? [hd V1316]] [and [= shen-mu [hd [hd V131
6]]] [and [cons? [tl [hd V1316]]] [and [cons? [tl [tl [hd V1316]]]] [and [= [] [
tl [tl [tl [hd V1316]]]]] [and [cons? [tl V1316]] [and [= [] [tl [tl V1316]]] [=
 _ [hd [tl [hd V1316]]]]]]]]]]]] [shen-mu_reduction [hd [tl [tl [hd V1316]]]] V1
317]] [[and [cons? V1316] [and [cons? [hd V1316]] [and [= shen-mu [hd [hd V1316]
]] [and [cons? [tl [hd V1316]]] [and [cons? [tl [tl [hd V1316]]]] [and [= [] [tl
 [tl [tl [hd V1316]]]]] [and [cons? [tl V1316]] [and [= [] [tl [tl V1316]]] [she
n-ephemeral_variable? [hd [tl [hd V1316]]] [hd [tl V1316]]]]]]]]]]] [subst [hd [
tl V1316]] [hd [tl [hd V1316]]] [shen-mu_reduction [hd [tl [tl [hd V1316]]]] V13
17]]] [[and [cons? V1316] [and [cons? [hd V1316]] [and [= shen-mu [hd [hd V1316]
]] [and [cons? [tl [hd V1316]]] [and [cons? [tl [tl [hd V1316]]]] [and [= [] [tl
 [tl [tl [hd V1316]]]]] [and [cons? [tl V1316]] [and [= [] [tl [tl V1316]]] [var
iable? [hd [tl [hd V1316]]]]]]]]]]]] [cons let [cons [hd [tl [hd V1316]]] [cons
shen-be [cons [hd [tl V1316]] [cons in [cons [shen-mu_reduction [hd [tl [tl [hd
V1316]]]] V1317] []]]]]]]] [[and [cons? V1316] [and [cons? [hd V1316]] [and [= s
hen-mu [hd [hd V1316]]] [and [cons? [tl [hd V1316]]] [and [cons? [tl [tl [hd V13
16]]]] [and [= [] [tl [tl [tl [hd V1316]]]]] [and [cons? [tl V1316]] [and [= []
[tl [tl V1316]]] [and [= - V1317] [shen-prolog_constant? [hd [tl [hd V1316]]]]]]
]]]]]]] [let Z [gensym V] [cons let [cons Z [cons shen-be [cons [cons shen-the [
cons shen-result [cons shen-of [cons shen-dereferencing [tl V1316]]]]] [cons in
[cons [cons if [cons [cons Z [cons is [cons identical [cons shen-to [cons [hd [t
l [hd V1316]]] []]]]]] [cons shen-then [cons [shen-mu_reduction [hd [tl [tl [hd
V1316]]]] -] [cons shen-else [cons [fail] []]]]]]] []]]]]]]]] [[and [cons? V1316
] [and [cons? [hd V1316]] [and [= shen-mu [hd [hd V1316]]] [and [cons? [tl [hd V
1316]]] [and [cons? [tl [tl [hd V1316]]]] [and [= [] [tl [tl [tl [hd V1316]]]]]
[and [cons? [tl V1316]] [and [= [] [tl [tl V1316]]] [and [= + V1317] [shen-prolo
g_constant? [hd [tl [hd V1316]]]]]]]]]]]]] [let Z [gensym V] [cons let [cons Z [
cons shen-be [cons [cons shen-the [cons shen-result [cons shen-of [cons shen-der
eferencing [tl V1316]]]]] [cons in [cons [cons if [cons [cons Z [cons is [cons i
dentical [cons shen-to [cons [hd [tl [hd V1316]]] []]]]]] [cons shen-then [cons
[shen-mu_reduction [hd [tl [tl [hd V1316]]]] +] [cons shen-else [cons [cons if [
cons [cons Z [cons is [cons shen-a [cons shen-variable []]]]] [cons shen-then [c
ons [cons bind [cons Z [cons shen-to [cons [hd [tl [hd V1316]]] [cons in [cons [
shen-mu_reduction [hd [tl [tl [hd V1316]]]] +] []]]]]]] [cons shen-else [cons [f
ail] []]]]]]] []]]]]]] []]]]]]]]] [[and [cons? V1316] [and [cons? [hd V1316]] [a
nd [= shen-mu [hd [hd V1316]]] [and [cons? [tl [hd V1316]]] [and [cons? [hd [tl
[hd V1316]]]] [and [cons? [tl [tl [hd V1316]]]] [and [= [] [tl [tl [tl [hd V1316
]]]]] [and [cons? [tl V1316]] [and [= [] [tl [tl V1316]]] [= - V1317]]]]]]]]]] [
let Z [gensym V] [cons let [cons Z [cons shen-be [cons [cons shen-the [cons shen
-result [cons shen-of [cons shen-dereferencing [tl V1316]]]]] [cons in [cons [co
ns if [cons [cons Z [cons is [cons shen-a [cons shen-non-empty [cons list []]]]]
] [cons shen-then [cons [shen-mu_reduction [cons [cons shen-mu [cons [hd [hd [tl
 [hd V1316]]]] [cons [cons [cons shen-mu [cons [tl [hd [tl [hd V1316]]]] [tl [tl
 [hd V1316]]]]] [cons [cons shen-the [cons tail [cons shen-of [cons Z []]]]] []]
] []]]] [cons [cons shen-the [cons head [cons shen-of [cons Z []]]]] []]] -] [co
ns shen-else [cons [fail] []]]]]]] []]]]]]]]] [[and [cons? V1316] [and [cons? [h
d V1316]] [and [= shen-mu [hd [hd V1316]]] [and [cons? [tl [hd V1316]]] [and [co
ns? [hd [tl [hd V1316]]]] [and [cons? [tl [tl [hd V1316]]]] [and [= [] [tl [tl [
tl [hd V1316]]]]] [and [cons? [tl V1316]] [and [= [] [tl [tl V1316]]] [= + V1317
]]]]]]]]]] [let Z [gensym V] [cons let [cons Z [cons shen-be [cons [cons shen-th
e [cons shen-result [cons shen-of [cons shen-dereferencing [tl V1316]]]]] [cons
in [cons [cons if [cons [cons Z [cons is [cons shen-a [cons shen-non-empty [cons
 list []]]]]] [cons shen-then [cons [shen-mu_reduction [cons [cons shen-mu [cons
 [hd [hd [tl [hd V1316]]]] [cons [cons [cons shen-mu [cons [tl [hd [tl [hd V1316
]]]] [tl [tl [hd V1316]]]]] [cons [cons shen-the [cons tail [cons shen-of [cons
Z []]]]] []]] []]]] [cons [cons shen-the [cons head [cons shen-of [cons Z []]]]]
 []]] +] [cons shen-else [cons [cons if [cons [cons Z [cons is [cons shen-a [con
s shen-variable []]]]] [cons shen-then [cons [cons shen-rename [cons shen-the [c
ons shen-variables [cons in [cons [shen-extract_vars [hd [tl [hd V1316]]]] [cons
 and [cons shen-then [cons [cons bind [cons Z [cons shen-to [cons [shen-rcons_fo
rm [shen-remove_modes [hd [tl [hd V1316]]]]] [cons in [cons [shen-mu_reduction [
hd [tl [tl [hd V1316]]]] +] []]]]]]] []]]]]]]]] [cons shen-else [cons [fail] []]
]]]]] []]]]]]] []]]]]]]]] [true V1316]]]

null



Evaluating: [defun shen-rcons_form [V1318] [cond [[cons? V1318] [cons cons [cons
 [shen-rcons_form [hd V1318]] [cons [shen-rcons_form [tl V1318]] []]]]] [true V1
318]]]

null



Evaluating: [defun shen-remove_modes [V1319] [cond [[and [cons? V1319] [and [= m
ode [hd V1319]] [and [cons? [tl V1319]] [and [cons? [tl [tl V1319]]] [and [= + [
hd [tl [tl V1319]]]] [= [] [tl [tl [tl V1319]]]]]]]]] [shen-remove_modes [hd [tl
 V1319]]]] [[and [cons? V1319] [and [= mode [hd V1319]] [and [cons? [tl V1319]]
[and [cons? [tl [tl V1319]]] [and [= - [hd [tl [tl V1319]]]] [= [] [tl [tl [tl V
1319]]]]]]]]] [shen-remove_modes [hd [tl V1319]]]] [[cons? V1319] [cons [shen-re
move_modes [hd V1319]] [shen-remove_modes [tl V1319]]]] [true V1319]]]

null



Evaluating: [defun shen-ephemeral_variable? [V1320 V1321] [and [variable? V1320]
 [variable? V1321]]]

null



Evaluating: [defun shen-prolog_constant? [V1330] [cond [[cons? V1330] false] [tr
ue true]]]

null



Evaluating: [defun shen-aum_to_shen [V1331] [cond [[and [cons? V1331] [and [= le
t [hd V1331]] [and [cons? [tl V1331]] [and [cons? [tl [tl V1331]]] [and [= shen-
be [hd [tl [tl V1331]]]] [and [cons? [tl [tl [tl V1331]]]] [and [cons? [tl [tl [
tl [tl V1331]]]]] [and [= in [hd [tl [tl [tl [tl V1331]]]]]] [and [cons? [tl [tl
 [tl [tl [tl V1331]]]]]] [= [] [tl [tl [tl [tl [tl [tl V1331]]]]]]]]]]]]]]]] [co
ns let [cons [hd [tl V1331]] [cons [shen-aum_to_shen [hd [tl [tl [tl V1331]]]]]
[cons [shen-aum_to_shen [hd [tl [tl [tl [tl [tl V1331]]]]]]] []]]]]] [[and [cons
? V1331] [and [= shen-the [hd V1331]] [and [cons? [tl V1331]] [and [= shen-resul
t [hd [tl V1331]]] [and [cons? [tl [tl V1331]]] [and [= shen-of [hd [tl [tl V133
1]]]] [and [cons? [tl [tl [tl V1331]]]] [and [= shen-dereferencing [hd [tl [tl [
tl V1331]]]]] [and [cons? [tl [tl [tl [tl V1331]]]]] [= [] [tl [tl [tl [tl [tl V
1331]]]]]]]]]]]]]]] [cons shen-lazyderef [cons [shen-aum_to_shen [hd [tl [tl [tl
 [tl V1331]]]]]] [cons ProcessN []]]]] [[and [cons? V1331] [and [= if [hd V1331]
] [and [cons? [tl V1331]] [and [cons? [tl [tl V1331]]] [and [= shen-then [hd [tl
 [tl V1331]]]] [and [cons? [tl [tl [tl V1331]]]] [and [cons? [tl [tl [tl [tl V13
31]]]]] [and [= shen-else [hd [tl [tl [tl [tl V1331]]]]]] [and [cons? [tl [tl [t
l [tl [tl V1331]]]]]] [= [] [tl [tl [tl [tl [tl [tl V1331]]]]]]]]]]]]]]]] [cons
if [cons [shen-aum_to_shen [hd [tl V1331]]] [cons [shen-aum_to_shen [hd [tl [tl
[tl V1331]]]]] [cons [shen-aum_to_shen [hd [tl [tl [tl [tl [tl V1331]]]]]]] []]]
]]] [[and [cons? V1331] [and [cons? [tl V1331]] [and [= is [hd [tl V1331]]] [and
 [cons? [tl [tl V1331]]] [and [= shen-a [hd [tl [tl V1331]]]] [and [cons? [tl [t
l [tl V1331]]]] [and [= shen-variable [hd [tl [tl [tl V1331]]]]] [= [] [tl [tl [
tl [tl V1331]]]]]]]]]]]] [cons shen-pvar? [cons [hd V1331] []]]] [[and [cons? V1
331] [and [cons? [tl V1331]] [and [= is [hd [tl V1331]]] [and [cons? [tl [tl V13
31]]] [and [= shen-a [hd [tl [tl V1331]]]] [and [cons? [tl [tl [tl V1331]]]] [an
d [= shen-non-empty [hd [tl [tl [tl V1331]]]]] [and [cons? [tl [tl [tl [tl V1331
]]]]] [and [= list [hd [tl [tl [tl [tl V1331]]]]]] [= [] [tl [tl [tl [tl [tl V13
31]]]]]]]]]]]]]]] [cons cons? [cons [hd V1331] []]]] [[and [cons? V1331] [and [=
 shen-rename [hd V1331]] [and [cons? [tl V1331]] [and [= shen-the [hd [tl V1331]
]] [and [cons? [tl [tl V1331]]] [and [= shen-variables [hd [tl [tl V1331]]]] [an
d [cons? [tl [tl [tl V1331]]]] [and [= in [hd [tl [tl [tl V1331]]]]] [and [cons?
 [tl [tl [tl [tl V1331]]]]] [and [= [] [hd [tl [tl [tl [tl V1331]]]]]] [and [con
s? [tl [tl [tl [tl [tl V1331]]]]]] [and [= and [hd [tl [tl [tl [tl [tl V1331]]]]
]]] [and [cons? [tl [tl [tl [tl [tl [tl V1331]]]]]]] [and [= shen-then [hd [tl [
tl [tl [tl [tl [tl V1331]]]]]]]] [and [cons? [tl [tl [tl [tl [tl [tl [tl V1331]]
]]]]]] [= [] [tl [tl [tl [tl [tl [tl [tl [tl V1331]]]]]]]]]]]]]]]]]]]]]]]] [shen
-aum_to_shen [hd [tl [tl [tl [tl [tl [tl [tl V1331]]]]]]]]]] [[and [cons? V1331]
 [and [= shen-rename [hd V1331]] [and [cons? [tl V1331]] [and [= shen-the [hd [t
l V1331]]] [and [cons? [tl [tl V1331]]] [and [= shen-variables [hd [tl [tl V1331
]]]] [and [cons? [tl [tl [tl V1331]]]] [and [= in [hd [tl [tl [tl V1331]]]]] [an
d [cons? [tl [tl [tl [tl V1331]]]]] [and [cons? [hd [tl [tl [tl [tl V1331]]]]]]
[and [cons? [tl [tl [tl [tl [tl V1331]]]]]] [and [= and [hd [tl [tl [tl [tl [tl
V1331]]]]]]] [and [cons? [tl [tl [tl [tl [tl [tl V1331]]]]]]] [and [= shen-then
[hd [tl [tl [tl [tl [tl [tl V1331]]]]]]]] [and [cons? [tl [tl [tl [tl [tl [tl [t
l V1331]]]]]]]] [= [] [tl [tl [tl [tl [tl [tl [tl [tl V1331]]]]]]]]]]]]]]]]]]]]]
]]] [cons let [cons [hd [hd [tl [tl [tl [tl V1331]]]]]] [cons [cons shen-newpv [
cons ProcessN []]] [cons [shen-aum_to_shen [cons shen-rename [cons shen-the [con
s shen-variables [cons in [cons [tl [hd [tl [tl [tl [tl V1331]]]]]] [tl [tl [tl
[tl [tl V1331]]]]]]]]]]] []]]]]] [[and [cons? V1331] [and [= bind [hd V1331]] [a
nd [cons? [tl V1331]] [and [cons? [tl [tl V1331]]] [and [= shen-to [hd [tl [tl V
1331]]]] [and [cons? [tl [tl [tl V1331]]]] [and [cons? [tl [tl [tl [tl V1331]]]]
] [and [= in [hd [tl [tl [tl [tl V1331]]]]]] [and [cons? [tl [tl [tl [tl [tl V13
31]]]]]] [= [] [tl [tl [tl [tl [tl [tl V1331]]]]]]]]]]]]]]]] [cons do [cons [con
s shen-bindv [cons [hd [tl V1331]] [cons [shen-chwild [hd [tl [tl [tl V1331]]]]]
 [cons ProcessN []]]]] [cons [cons let [cons Result [cons [shen-aum_to_shen [hd
[tl [tl [tl [tl [tl V1331]]]]]]] [cons [cons do [cons [cons shen-unbindv [cons [
hd [tl V1331]] [cons ProcessN []]]] [cons Result []]]] []]]]] []]]]] [[and [cons
? V1331] [and [cons? [tl V1331]] [and [= is [hd [tl V1331]]] [and [cons? [tl [tl
 V1331]]] [and [= identical [hd [tl [tl V1331]]]] [and [cons? [tl [tl [tl V1331]
]]] [and [= shen-to [hd [tl [tl [tl V1331]]]]] [and [cons? [tl [tl [tl [tl V1331
]]]]] [= [] [tl [tl [tl [tl [tl V1331]]]]]]]]]]]]]] [cons = [cons [hd [tl [tl [t
l [tl V1331]]]]] [cons [hd V1331] []]]]] [[= V1331 [fail]] false] [[and [cons? V
1331] [and [= shen-the [hd V1331]] [and [cons? [tl V1331]] [and [= head [hd [tl
V1331]]] [and [cons? [tl [tl V1331]]] [and [= shen-of [hd [tl [tl V1331]]]] [and
 [cons? [tl [tl [tl V1331]]]] [= [] [tl [tl [tl [tl V1331]]]]]]]]]]]] [cons hd [
tl [tl [tl V1331]]]]] [[and [cons? V1331] [and [= shen-the [hd V1331]] [and [con
s? [tl V1331]] [and [= tail [hd [tl V1331]]] [and [cons? [tl [tl V1331]]] [and [
= shen-of [hd [tl [tl V1331]]]] [and [cons? [tl [tl [tl V1331]]]] [= [] [tl [tl
[tl [tl V1331]]]]]]]]]]]] [cons tl [tl [tl [tl V1331]]]]] [[and [cons? V1331] [a
nd [= shen-pop [hd V1331]] [and [cons? [tl V1331]] [and [= shen-the [hd [tl V133
1]]] [and [cons? [tl [tl V1331]]] [and [= shen-stack [hd [tl [tl V1331]]]] [= []
 [tl [tl [tl V1331]]]]]]]]]] [cons do [cons [cons shen-incinfs []] [cons [cons t
haw [cons Continuation []]] []]]]] [[and [cons? V1331] [and [= call [hd V1331]]
[and [cons? [tl V1331]] [and [= shen-the [hd [tl V1331]]] [and [cons? [tl [tl V1
331]]] [and [= shen-continuation [hd [tl [tl V1331]]]] [and [cons? [tl [tl [tl V
1331]]]] [= [] [tl [tl [tl [tl V1331]]]]]]]]]]]] [cons do [cons [cons shen-incin
fs []] [cons [shen-call_the_continuation [shen-chwild [hd [tl [tl [tl V1331]]]]]
 ProcessN Continuation] []]]]] [true V1331]]]

null



Evaluating: [defun shen-chwild [V1332] [cond [[= V1332 _] [cons shen-newpv [cons
 ProcessN []]]] [[cons? V1332] [map [lambda V1333 [shen-chwild V1333]] V1332]] [
true V1332]]]

null



Evaluating: [defun shen-newpv [V1334] [let Count+1 [+ [<-address [value shen-*va
rcounter*] V1334] 1] [let IncVar [address-> [value shen-*varcounter*] V1334 Coun
t+1] [let Vector [<-address [value shen-*prologvectors*] V1334] [let ResizeVecto
rIfNeeded [if [= Count+1 [limit Vector]] [shen-resizeprocessvector V1334 Count+1
] shen-skip] [shen-mk-pvar Count+1]]]]]]

null



Evaluating: [defun shen-resizeprocessvector [V1335 V1336] [let Vector [<-address
 [value shen-*prologvectors*] V1335] [let BigVector [shen-resize-vector Vector [
+ V1336 V1336] shen--null-] [address-> [value shen-*prologvectors*] V1335 BigVec
tor]]]]

null



Evaluating: [defun shen-resize-vector [V1337 V1338 V1339] [let BigVector [addres
s-> [absvector [+ 1 V1338]] 0 V1338] [shen-copy-vector V1337 BigVector [limit V1
337] V1338 V1339]]]

null



Evaluating: [defun shen-copy-vector [V1340 V1341 V1342 V1343 V1344] [shen-copy-v
ector-stage-2 [+ 1 V1342] [+ V1343 1] V1344 [shen-copy-vector-stage-1 1 V1340 V1
341 [+ 1 V1342]]]]

null



Evaluating: [defun shen-copy-vector-stage-1 [V1347 V1348 V1349 V1350] [cond [[=
V1350 V1347] V1349] [true [shen-copy-vector-stage-1 [+ 1 V1347] V1348 [address->
 V1349 V1347 [<-address V1348 V1347]] V1350]]]]

null



Evaluating: [defun shen-copy-vector-stage-2 [V1354 V1355 V1356 V1357] [cond [[=
V1355 V1354] V1357] [true [shen-copy-vector-stage-2 [+ V1354 1] V1355 V1356 [add
ress-> V1357 V1354 V1356]]]]]

null



Evaluating: [defun shen-mk-pvar [V1359] [address-> [address-> [absvector 2] 0 sh
en-pvar] 1 V1359]]

null



Evaluating: [defun shen-pvar? [V1360] [and [absvector? V1360] [= [<-address V136
0 0] shen-pvar]]]

null



Evaluating: [defun shen-bindv [V1361 V1362 V1363] [let Vector [<-address [value
shen-*prologvectors*] V1363] [address-> Vector [<-address V1361 1] V1362]]]

null



Evaluating: [defun shen-unbindv [V1364 V1365] [let Vector [<-address [value shen
-*prologvectors*] V1365] [address-> Vector [<-address V1364 1] shen--null-]]]

null



Evaluating: [defun shen-incinfs [] [set shen-*infs* [+ 1 [value shen-*infs*]]]]

null



Evaluating: [defun shen-call_the_continuation [V1366 V1367 V1368] [cond [[and [c
ons? V1366] [and [cons? [hd V1366]] [= [] [tl V1366]]]] [cons [hd [hd V1366]] [a
ppend [tl [hd V1366]] [cons V1367 [cons V1368 []]]]]] [[and [cons? V1366] [cons?
 [hd V1366]]] [let NewContinuation [shen-newcontinuation [tl V1366] V1367 V1368]
 [cons [hd [hd V1366]] [append [tl [hd V1366]] [cons V1367 [cons NewContinuation
 []]]]]]] [true [shen-sys-error shen-call_the_continuation]]]]

null



Evaluating: [defun shen-newcontinuation [V1369 V1370 V1371] [cond [[= [] V1369]
V1371] [[and [cons? V1369] [cons? [hd V1369]]] [cons freeze [cons [cons [hd [hd
V1369]] [append [tl [hd V1369]] [cons V1370 [cons [shen-newcontinuation [tl V136
9] V1370 V1371] []]]]] []]]] [true [shen-sys-error shen-newcontinuation]]]]

null



Evaluating: [defun return [V1376 V1377 V1378] [shen-deref V1376 V1377]]

null



Evaluating: [defun shen-measure&return [V1383 V1384 V1385] [do [intoutput ~A inf
erences
 [@p [value shen-*infs*] []]] [shen-deref V1383 V1384]]]

null



Evaluating: [defun unify [V1386 V1387 V1388 V1389] [shen-lzy= [shen-lazyderef V1
386 V1388] [shen-lazyderef V1387 V1388] V1388 V1389]]

null



Evaluating: [defun shen-lzy= [V1406 V1407 V1408 V1409] [cond [[= V1407 V1406] [t
haw V1409]] [[shen-pvar? V1406] [bind V1406 V1407 V1408 V1409]] [[shen-pvar? V14
07] [bind V1407 V1406 V1408 V1409]] [[and [cons? V1406] [cons? V1407]] [shen-lzy
= [shen-lazyderef [hd V1406] V1408] [shen-lazyderef [hd V1407] V1408] V1408 [fre
eze [shen-lzy= [shen-lazyderef [tl V1406] V1408] [shen-lazyderef [tl V1407] V140
8] V1408 V1409]]]] [true false]]]

null



Evaluating: [defun shen-deref [V1411 V1412] [cond [[cons? V1411] [cons [shen-der
ef [hd V1411] V1412] [shen-deref [tl V1411] V1412]]] [true [if [shen-pvar? V1411
] [let Value [shen-valvector V1411 V1412] [if [= Value shen--null-] V1411 [shen-
deref Value V1412]]] V1411]]]]

null



Evaluating: [defun shen-lazyderef [V1413 V1414] [if [shen-pvar? V1413] [let Valu
e [shen-valvector V1413 V1414] [if [= Value shen--null-] V1413 [shen-lazyderef V
alue V1414]]] V1413]]

null



Evaluating: [defun shen-valvector [V1415 V1416] [<-address [<-address [value she
n-*prologvectors*] V1416] [<-address V1415 1]]]

null



Evaluating: [defun unify! [V1417 V1418 V1419 V1420] [shen-lzy=! [shen-lazyderef
V1417 V1419] [shen-lazyderef V1418 V1419] V1419 V1420]]

null



Evaluating: [defun shen-lzy=! [V1437 V1438 V1439 V1440] [cond [[= V1438 V1437] [
thaw V1440]] [[and [shen-pvar? V1437] [not [shen-occurs? V1437 [shen-deref V1438
 V1439]]]] [bind V1437 V1438 V1439 V1440]] [[and [shen-pvar? V1438] [not [shen-o
ccurs? V1438 [shen-deref V1437 V1439]]]] [bind V1438 V1437 V1439 V1440]] [[and [
cons? V1437] [cons? V1438]] [shen-lzy=! [shen-lazyderef [hd V1437] V1439] [shen-
lazyderef [hd V1438] V1439] V1439 [freeze [shen-lzy=! [shen-lazyderef [tl V1437]
 V1439] [shen-lazyderef [tl V1438] V1439] V1439 V1440]]]] [true false]]]

null



Evaluating: [defun shen-occurs? [V1450 V1451] [cond [[= V1451 V1450] true] [[con
s? V1451] [or [shen-occurs? V1450 [hd V1451]] [shen-occurs? V1450 [tl V1451]]]]
[true false]]]

null



Evaluating: [defun identical [V1453 V1454 V1455 V1456] [shen-lzy== [shen-lazyder
ef V1453 V1455] [shen-lazyderef V1454 V1455] V1455 V1456]]

null



Evaluating: [defun shen-lzy== [V1473 V1474 V1475 V1476] [cond [[= V1474 V1473] [
thaw V1476]] [[and [cons? V1473] [cons? V1474]] [shen-lzy== [shen-lazyderef [hd
V1473] V1475] [shen-lazyderef [hd V1474] V1475] V1475 [freeze [shen-lzy== [tl V1
473] [tl V1474] V1475 V1476]]]] [true false]]]

null



Evaluating: [defun shen-pvar [V1478] [intmake-string Var~A [@p [<-address V1478
1] []]]]

null



Evaluating: [defun bind [V1479 V1480 V1481 V1482] [do [shen-bindv V1479 V1480 V1
481] [let Result [thaw V1482] [do [shen-unbindv V1479 V1481] Result]]]]

null



Evaluating: [defun fwhen [V1497 V1498 V1499] [cond [[= true V1497] [thaw V1499]]
 [[= false V1497] false] [true [interror fwhen expects a boolean: not ~S% [@p V1
497 []]]]]]

null



Evaluating: [defun call [V1512 V1513 V1514] [cond [[cons? V1512] [shen-call-help
 [shen-m_prolog_to_s-prolog_predicate [shen-lazyderef [hd V1512] V1513]] [tl V15
12] V1513 V1514]] [true false]]]

null



Evaluating: [defun shen-call-help [V1515 V1516 V1517 V1518] [cond [[= [] V1516]
[V1515 V1517 V1518]] [[cons? V1516] [shen-call-help [V1515 [hd V1516]] [tl V1516
] V1517 V1518]] [true [shen-sys-error shen-call-help]]]]

null



Evaluating: [defun shen-intprolog [V1519] [cond [[and [cons? V1519] [cons? [hd V
1519]]] [let ProcessN [shen-start-new-prolog-process] [shen-intprolog-help [hd [
hd V1519]] [shen-insert-prolog-variables [cons [tl [hd V1519]] [cons [tl V1519]
[]]] ProcessN] ProcessN]]] [true [shen-sys-error shen-intprolog]]]]

null



Evaluating: [defun shen-intprolog-help [V1520 V1521 V1522] [cond [[and [cons? V1
521] [and [cons? [tl V1521]] [= [] [tl [tl V1521]]]]] [shen-intprolog-help-help
V1520 [hd V1521] [hd [tl V1521]] V1522]] [true [shen-sys-error shen-intprolog-he
lp]]]]

null



Evaluating: [defun shen-intprolog-help-help [V1523 V1524 V1525 V1526] [cond [[=
[] V1524] [V1523 V1526 [freeze [shen-call-rest V1525 V1526]]]] [[cons? V1524] [s
hen-intprolog-help-help [V1523 [hd V1524]] [tl V1524] V1525 V1526]] [true [shen-
sys-error shen-intprolog-help-help]]]]

null



Evaluating: [defun shen-call-rest [V1529 V1530] [cond [[= [] V1529] true] [[and
[cons? V1529] [and [cons? [hd V1529]] [cons? [tl [hd V1529]]]]] [shen-call-rest
[cons [cons [[hd [hd V1529]] [hd [tl [hd V1529]]]] [tl [tl [hd V1529]]]] [tl V15
29]] V1530]] [[and [cons? V1529] [and [cons? [hd V1529]] [= [] [tl [hd V1529]]]]
] [[hd [hd V1529]] V1530 [freeze [shen-call-rest [tl V1529] V1530]]]] [true [she
n-sys-error shen-call-rest]]]]

null



Evaluating: [defun shen-start-new-prolog-process [] [let IncrementProcessCounter
 [set shen-*process-counter* [+ 1 [value shen-*process-counter*]]] [shen-initial
ise-prolog IncrementProcessCounter]]]

null



Evaluating: [defun shen-insert-prolog-variables [V1531 V1532] [shen-insert-prolo
g-variables-help V1531 [shen-flatten V1531] V1532]]

null



Evaluating: [defun shen-insert-prolog-variables-help [V1537 V1538 V1539] [cond [
[= [] V1538] V1537] [[and [cons? V1538] [variable? [hd V1538]]] [let V [shen-new
pv V1539] [let XV/Y [subst V [hd V1538] V1537] [let Z-Y [remove [hd V1538] [tl V
1538]] [shen-insert-prolog-variables-help XV/Y Z-Y V1539]]]]] [[cons? V1538] [sh
en-insert-prolog-variables-help V1537 [tl V1538] V1539]] [true [shen-sys-error s
hen-insert-prolog-variables-help]]]]

null



Evaluating: [defun shen-initialise-prolog [V1540] [let Vector [address-> [value
shen-*prologvectors*] V1540 [shen-fillvector [vector 10] 1 10 shen--null-]] [let
 Counter [address-> [value shen-*varcounter*] V1540 1] V1540]]]

null



Evaluating:                                                    The License

 The user is free to produce commercial applications with the software, to distr
ibute these applications in source or binary  form, and to charge monies for the
m as he sees fit and in concordance with the laws of the land subject to the fol
lowing  license.

 1. The license applies to all the software and all derived software and must ap
pear on such.
 2. It is illegal to distribute the software without this license attached to it
 and use of the software implies agreement
    with the license as such. It is illegal for anyone who is not the copyright
holder to tamper with or change the license.
 3. Neither the names of Lambda Associates or the copyright holder may be used t
o endorse or promote products built using
     the software without specific prior written permission from the copyright h
older.
 4. That possession of this license does not confer on the copyright holder any
special contractual obligation towards the    user. That in no event shall the c
opyright holder be liable for any direct, indirect, incidental, special, exempla
ry or   consequential damages (including but not limited to procurement of subst
itute goods or services, loss of use, data, or    profits; or business interrupt
ion), however caused and on any theory of liability, whether in contract, strict
 liability   or tort (including negligence) arising in any way out of the use of
 the software, even if advised of the possibility of   such damage.
5. It is permitted for the user to change the software, for the purpose of impro
ving performance, correcting an error, or    porting to a new platform, and dist
ribute the modified version of Shen (hereafter the modified version) provided th
e     resulting program conforms in all respects to the Shen standard and is iss
ued under that title. The user must make it clear   with his distribution that h
e/she is the author of the changes and what these changes are and why.
6. Derived versions of this software in whatever form are subject to the same re
strictions. In particular it is not          permitted to make derived copies of
 this software which do not conform to the Shen standard or appear under a diffe
rent title.
7. It is permitted to distribute versions of Shen which incorporate libraries, g
raphics or other facilities which are not    part of the Shen standard.

For an explication of this license see http://www.lambdassociates.org/News/june1
1/license.htm which explains this license in full.

                                                   The License

 The user is free to produce comm




Evaluating: [defun shen-yacc [V293] [cond [[and [cons? V293] [and [= defcc [hd V
293]] [cons? [tl V293]]]] [shen-yacc->shen [hd [tl V293]] [tl [tl V293]] [shen-e
xtract-segvars [tl [tl V293]]]]] [true [shen-sys-error shen-yacc]]]]

null



Evaluating: [defun shen-extract-segvars [V298] [cond [[shen-segvar? V298] [cons
V298 []]] [[cons? V298] [union [shen-extract-segvars [hd V298]] [shen-extract-se
gvars [tl V298]]]] [true []]]]

null



Evaluating: [defun shen-yacc->shen [V299 V300 V301] [let Main [cons define [cons
 V299 [shen-yacc_cases [map [lambda V302 [shen-cc_body V302]] [shen-split_cc_rul
es V300 []]]]]] [if [empty? V301] Main [cons package [cons null [cons [] [cons M
ain [map [lambda V303 [shen-segdef V303]] V301]]]]]]]]

null



Evaluating: [defun shen-segdef [V304] [cons define [cons V304 [cons [cons @p [co
ns In [cons Out []]]] [cons Continuation [cons -> [cons [cons let [cons Continue
 [cons [cons Continuation [cons [cons reverse [cons Out []]] [cons [cons @p [con
s In [cons [] []]]] []]]] [cons [cons if [cons [cons and [cons [cons = [cons Con
tinue [cons [cons fail []] []]]] [cons [cons cons? [cons In []]] []]]] [cons [co
ns V304 [cons [cons @p [cons [cons tl [cons In []]] [cons [cons cons [cons [cons
 hd [cons In []]] [cons Out []]]] []]]] [cons Continuation []]]] [cons Continue
[]]]]] []]]]] []]]]]]]]

null



Evaluating: [defun shen-yacc_cases [V305] [append [mapcan [lambda Case [cons Str
eam [cons <- [cons Case []]]]] V305] [cons _ [cons -> [cons [cons fail []] []]]]
]]

null



Evaluating: [defun shen-first_n [V310 V311] [cond [[= 0 V310] []] [[= [] V311] [
]] [[cons? V311] [cons [hd V311] [shen-first_n [- V310 1] [tl V311]]]] [true [sh
en-sys-error shen-first_n]]]]

null



Evaluating: [defun shen-split_cc_rules [V312 V313] [cond [[and [= [] V312] [= []
 V313]] []] [[= [] V312] [cons [shen-split_cc_rule [reverse V313] []] []]] [[and
 [cons? V312] [= ; [hd V312]]] [cons [shen-split_cc_rule [reverse V313] []] [she
n-split_cc_rules [tl V312] []]]] [[cons? V312] [shen-split_cc_rules [tl V312] [c
ons [hd V312] V313]]] [true [shen-sys-error shen-split_cc_rules]]]]

null



Evaluating: [defun shen-split_cc_rule [V314 V315] [cond [[and [cons? V314] [and
[= := [hd V314]] [and [cons? [tl V314]] [= [] [tl [tl V314]]]]]] [cons [reverse
V315] [tl V314]]] [[and [cons? V314] [= := [hd V314]]] [cons [reverse V315] [con
s [shen-cons_form [tl V314]] []]]] [[= [] V314] [do [intoutput warning:  []] [do
 [map [lambda X [intoutput ~A  [@p X []]]] [reverse V315]] [do [intoutput has no
 semantics.
 []] [shen-split_cc_rule [cons := [cons [shen-default_semantics [reverse V315]]
[]]] V315]]]]] [[cons? V314] [shen-split_cc_rule [tl V314] [cons [hd V314] V315]
]] [true [shen-sys-error shen-split_cc_rule]]]]

null



Evaluating: [defun shen-default_semantics [V316] [cond [[= [] V316] []] [[and [c
ons? V316] [shen-grammar_symbol? [hd V316]]] [let PS [cons snd [cons [concat Par
se_ [hd V316]] []]] [if [empty? [tl V316]] PS [cons append [cons PS [cons [shen-
default_semantics [tl V316]] []]]]]]] [[cons? V316] [cons cons [cons [hd V316] [
cons [shen-default_semantics [tl V316]] []]]]] [true [shen-sys-error shen-defaul
t_semantics]]]]

null



Evaluating: [defun shen-cc_body [V317] [cond [[and [cons? V317] [and [cons? [tl
V317]] [= [] [tl [tl V317]]]]] [shen-syntax [hd V317] Stream [hd [tl V317]]]] [t
rue [shen-sys-error shen-cc_body]]]]

null



Evaluating: [defun shen-syntax [V318 V319 V320] [cond [[= [] V318] [cons shen-re
assemble [cons [cons fst [cons V319 []]] [cons [shen-semantics V320] []]]]] [[co
ns? V318] [if [shen-grammar_symbol? [hd V318]] [shen-recursive_descent V318 V319
 V320] [if [shen-segvar? [hd V318]] [shen-segment-match V318 V319 V320] [if [she
n-terminal? [hd V318]] [shen-check_stream V318 V319 V320] [if [shen-jump_stream?
 [hd V318]] [shen-jump_stream V318 V319 V320] [if [shen-list_stream? [hd V318]]
[shen-list_stream [shen-decons [hd V318]] [tl V318] V319 V320] [interror ~A is n
ot legal syntax
 [@p [hd V318] []]]]]]]]] [true [shen-sys-error shen-syntax]]]]

null



Evaluating: [defun shen-list_stream? [V329] [cond [[cons? V329] true] [true fals
e]]]

null



Evaluating: [defun shen-decons [V330] [cond [[and [cons? V330] [and [= cons [hd
V330]] [and [cons? [tl V330]] [and [cons? [tl [tl V330]]] [= [] [tl [tl [tl V330
]]]]]]]] [cons [hd [tl V330]] [shen-decons [hd [tl [tl V330]]]]]] [true V330]]]

null



Evaluating: [defun shen-list_stream [V331 V332 V333 V334] [let Test [cons and [c
ons [cons cons? [cons [cons fst [cons V333 []]] []]] [cons [cons cons? [cons [co
ns hd [cons [cons fst [cons V333 []]] []]] []]] []]]] [let Action [cons shen-snd
-or-fail [cons [shen-syntax V331 [cons shen-reassemble [cons [cons hd [cons [con
s fst [cons V333 []]] []]] [cons [cons snd [cons V333 []]] []]]] [cons shen-leav
e! [cons [shen-syntax V332 [cons shen-reassemble [cons [cons tl [cons [cons fst
[cons V333 []]] []]] [cons [cons snd [cons V333 []]] []]]] V334] []]]] []]] [let
 Else [cons fail []] [cons if [cons Test [cons Action [cons Else []]]]]]]]]

null



Evaluating: [defun shen-snd-or-fail [V341] [cond [[tuple? V341] [snd V341]] [tru
e [fail]]]]

null



Evaluating: [defun shen-grammar_symbol? [V342] [and [symbol? V342] [let Cs [expl
ode V342] [and [= [hd Cs] <] [= [hd [reverse Cs]] >]]]]]

null



Evaluating: [defun shen-recursive_descent [V343 V344 V345] [cond [[cons? V343] [
let Test [cons [hd V343] [cons V344 []]] [let Action [shen-syntax [tl V343] [con
cat Parse_ [hd V343]] V345] [let Else [cons fail []] [cons let [cons [concat Par
se_ [hd V343]] [cons Test [cons [cons if [cons [cons not [cons [cons = [cons [co
ns fail []] [cons [concat Parse_ [hd V343]] []]]] []]] [cons Action [cons Else [
]]]]] []]]]]]]]] [true [shen-sys-error shen-recursive_descent]]]]

null



Evaluating: [defun shen-segvar? [V346] [and [symbol? V346] [= [hd [explode V346]
] ?]]]

null



Evaluating: [defun shen-segment-match [V347 V348 V349] [cond [[cons? V347] [let
Continuation [cons lambda [cons [hd V347] [cons [cons lambda [cons Restart [cons
 [shen-syntax [tl V347] Restart V349] []]]] []]]] [cons [hd V347] [cons V348 [co
ns Continuation []]]]]] [true [shen-sys-error shen-segment-match]]]]

null



Evaluating: [defun shen-terminal? [V358] [cond [[cons? V358] false] [[= -*- V358
] false] [true true]]]

null



Evaluating: [defun shen-jump_stream? [V363] [cond [[= -*- V363] true] [true fals
e]]]

null



Evaluating: [defun shen-check_stream [V364 V365 V366] [cond [[cons? V364] [let T
est [cons and [cons [cons cons? [cons [cons fst [cons V365 []]] []]] [cons [cons
 = [cons [hd V364] [cons [cons hd [cons [cons fst [cons V365 []]] []]] []]]] []]
]] [let Action [shen-syntax [tl V364] [cons shen-reassemble [cons [cons tl [cons
 [cons fst [cons V365 []]] []]] [cons [cons snd [cons V365 []]] []]]] V366] [let
 Else [cons fail []] [cons if [cons Test [cons Action [cons Else []]]]]]]]] [tru
e [shen-sys-error shen-check_stream]]]]

null



Evaluating: [defun shen-reassemble [V368 V369] [cond [[= V369 [fail]] V369] [tru
e [@p V368 V369]]]]

null



Evaluating: [defun shen-jump_stream [V370 V371 V372] [cond [[cons? V370] [let Te
st [cons cons? [cons [cons fst [cons V371 []]] []]] [let Action [shen-syntax [tl
 V370] [cons shen-reassemble [cons [cons tl [cons [cons fst [cons V371 []]] []]]
 [cons [cons snd [cons V371 []]] []]]] V372] [let Else [cons fail []] [cons if [
cons Test [cons Action [cons Else []]]]]]]]] [true [shen-sys-error shen-jump_str
eam]]]]

null



Evaluating: [defun shen-semantics [V373] [cond [[and [cons? V373] [and [= shen-l
eave! [hd V373]] [and [cons? [tl V373]] [= [] [tl [tl V373]]]]]] [hd [tl V373]]]
 [[= [] V373] []] [[shen-grammar_symbol? V373] [cons snd [cons [concat Parse_ V3
73] []]]] [[= -o- V373] [cons snd [cons Stream []]]] [[= -*- V373] [cons hd [con
s [cons fst [cons Stream []]] []]]] [[= -s- V373] [cons fst [cons Stream []]]] [
[cons? V373] [map [lambda V374 [shen-semantics V374]] V373]] [true V373]]]

null



Evaluating: [defun <!> [V379] [cond [[tuple? V379] [@p [] [fst V379]]] [true [sh
en-sys-error <!>]]]]

null



Evaluating:                                                    The License

 The user is free to produce commercial applications with the software, to distr
ibute these applications in source or binary  form, and to charge monies for the
m as he sees fit and in concordance with the laws of the land subject to the fol
lowing  license.

 1. The license applies to all the software and all derived software and must ap
pear on such.
 2. It is illegal to distribute the software without this license attached to it
 and use of the software implies agreement
    with the license as such. It is illegal for anyone who is not the copyright
holder to tamper with or change the license.
 3. Neither the names of Lambda Associates or the copyright holder may be used t
o endorse or promote products built using
     the software without specific prior written permission from the copyright h
older.
 4. That possession of this license does not confer on the copyright holder any
special contractual obligation towards the    user. That in no event shall the c
opyright holder be liable for any direct, indirect, incidental, special, exempla
ry or   consequential damages (including but not limited to procurement of subst
itute goods or services, loss of use, data, or    profits; or business interrupt
ion), however caused and on any theory of liability, whether in contract, strict
 liability   or tort (including negligence) arising in any way out of the use of
 the software, even if advised of the possibility of   such damage.
5. It is permitted for the user to change the software, for the purpose of impro
ving performance, correcting an error, or    porting to a new platform, and dist
ribute the modified version of Shen (hereafter the modified version) provided th
e     resulting program conforms in all respects to the Shen standard and is iss
ued under that title. The user must make it clear   with his distribution that h
e/she is the author of the changes and what these changes are and why.
6. Derived versions of this software in whatever form are subject to the same re
strictions. In particular it is not          permitted to make derived copies of
 this software which do not conform to the Shen standard or appear under a diffe
rent title.
7. It is permitted to distribute versions of Shen which incorporate libraries, g
raphics or other facilities which are not    part of the Shen standard.

For an explication of this license see http://www.lambdassociates.org/News/june1
1/license.htm which explains this license in full.

                                                   The License

 The user is free to produce comm




Evaluating: [set shen-*installing-kl* false]

false



Evaluating: [set shen-*history* []]

()



Evaluating: [set shen-*tc* false]

false



Evaluating: [set shen-*property-vector* [vector 20000]]

[Ljava.lang.Object;@150b51f4



Evaluating: [set shen-*process-counter* 0]

0.0



Evaluating: [set shen-*varcounter* [vector 1000]]

[Ljava.lang.Object;@1c7d672a



Evaluating: [set shen-*prologvectors* [vector 1000]]

[Ljava.lang.Object;@507792fe



Evaluating: [set shen-*reader-macros* []]

()



Evaluating: [set *printer* []]

()



Evaluating: [set *home-directory* []]

()



Evaluating: [set shen-*gensym* 0]

0.0



Evaluating: [set shen-*tracking* []]

()



Evaluating: [set *home-directory* ]





Evaluating: [set shen-*alphabet* [cons A [cons B [cons C [cons D [cons E [cons F
 [cons G [cons H [cons I [cons J [cons K [cons L [cons M [cons N [cons O [cons P
 [cons Q [cons R [cons S [cons T [cons U [cons V [cons W [cons X [cons Y [cons Z
 []]]]]]]]]]]]]]]]]]]]]]]]]]]]

[A [B [C [D [E [F [G [H [I [J [K [L [M [N [O [P [Q [R [S [T [U [V [W [X [Y [Z |
()]]]]]]]]]]]]]]]]]]




Evaluating: [set shen-*special* [cons @p [cons @s [cons @v [cons cons [cons lamb
da [cons let [cons type [cons where [cons set [cons open []]]]]]]]]]]]

[@p [@s [@v [cons [lambda [let [type [where [set [open | ()]]]]]]]]]]



Evaluating: [set shen-*extraspecial* [cons define [cons shen-process-datatype [c
ons input+ []]]]]

[define [shen-process-datatype [input+ | ()]]]



Evaluating: [set shen-*spy* false]

false



Evaluating: [set shen-*datatypes* []]

()



Evaluating: [set shen-*alldatatypes* []]

()



Evaluating: [set shen-*synonyms* []]

()



Evaluating: [set shen-*system* []]

()



Evaluating: [set shen-*signedfuncs* []]

()



Evaluating: [set shen-*maxcomplexity* 128]

128.0



Evaluating: [set shen-*occurs* true]

true



Evaluating: [set shen-*maxinferences* 1000000]

1000000.0



Evaluating: [set *maximum-print-sequence-size* 20]

20.0



Evaluating: [set shen-*catch* 0]

0.0



Evaluating: [set shen-*call* 0]

0.0



Evaluating: [set shen-*infs* 0]

0.0



Evaluating: [set shen-*process-counter* 0]

0.0



Evaluating: [set shen-*catch* 0]

0.0



Evaluating: [defun shen-initialise_arity_table [V1541] [cond [[= [] V1541] []] [
[and [cons? V1541] [cons? [tl V1541]]] [let DecArity [put [hd V1541] arity [hd [
tl V1541]] [value shen-*property-vector*]] [shen-initialise_arity_table [tl [tl
V1541]]]]] [true [shen-sys-error shen-initialise_arity_table]]]]

null



Evaluating: [defun arity [V1542] [trap-error [get V1542 arity [value shen-*prope
rty-vector*]] [lambda E -1]]]

null



Evaluating: [shen-initialise_arity_table [cons adjoin [cons 2 [cons and [cons 2
[cons append [cons 2 [cons arity [cons 1 [cons assoc [cons 2 [cons boolean? [con
s 1 [cons cd [cons 1 [cons compile [cons 3 [cons concat [cons 2 [cons cons [cons
 2 [cons cons? [cons 1 [cons cn [cons 2 [cons declare [cons 2 [cons destroy [con
s 1 [cons difference [cons 2 [cons do [cons 2 [cons element? [cons 2 [cons empty
? [cons 1 [cons interror [cons 2 [cons eval [cons 1 [cons eval-kl [cons 1 [cons
explode [cons 1 [cons external [cons 1 [cons fail-if [cons 2 [cons fail [cons 0
[cons fix [cons 2 [cons findall [cons 5 [cons freeze [cons 1 [cons fst [cons 1 [
cons gensym [cons 1 [cons get [cons 3 [cons address-> [cons 3 [cons <-address [c
ons 2 [cons <-vector [cons 2 [cons > [cons 2 [cons >= [cons 2 [cons = [cons 2 [c
ons hd [cons 1 [cons hdv [cons 1 [cons hdstr [cons 1 [cons head [cons 1 [cons if
 [cons 3 [cons integer? [cons 1 [cons identical [cons 4 [cons inferences [cons 1
 [cons intoutput [cons 2 [cons make-string [cons 2 [cons intersection [cons 2 [c
ons length [cons 1 [cons lineread [cons 0 [cons load [cons 1 [cons < [cons 2 [co
ns <= [cons 2 [cons vector [cons 1 [cons macroexpand [cons 1 [cons map [cons 2 [
cons mapcan [cons 2 [cons intmake-string [cons 2 [cons maxinferences [cons 1 [co
ns not [cons 1 [cons nth [cons 2 [cons n->string [cons 1 [cons number? [cons 1 [
cons output [cons 2 [cons occurs-check [cons 1 [cons occurrences [cons 2 [cons o
ccurs-check [cons 1 [cons or [cons 2 [cons package [cons 3 [cons pos [cons 2 [co
ns print [cons 1 [cons profile [cons 1 [cons profile-results [cons 1 [cons ps [c
ons 1 [cons preclude [cons 1 [cons preclude-all-but [cons 1 [cons protect [cons
1 [cons address-> [cons 3 [cons put [cons 4 [cons shen-reassemble [cons 2 [cons
read-file-as-string [cons 1 [cons read-file [cons 1 [cons read-byte [cons 1 [con
s remove [cons 2 [cons reverse [cons 1 [cons set [cons 2 [cons simple-error [con
s 1 [cons snd [cons 1 [cons specialise [cons 1 [cons spy [cons 1 [cons step [con
s 1 [cons stinput [cons 1 [cons shen-stoutput [cons 1 [cons string->n [cons 1 [c
ons string? [cons 1 [cons strong-warning [cons 1 [cons subst [cons 3 [cons symbo
l? [cons 1 [cons tail [cons 1 [cons tl [cons 1 [cons tc [cons 1 [cons tc? [cons
1 [cons thaw [cons 1 [cons track [cons 1 [cons trap-error [cons 2 [cons tuple? [
cons 1 [cons type [cons 1 [cons return [cons 3 [cons unprofile [cons 1 [cons uni
fy [cons 4 [cons unify! [cons 4 [cons union [cons 2 [cons untrack [cons 1 [cons
unspecialise [cons 1 [cons vector [cons 1 [cons vector-> [cons 3 [cons value [co
ns 1 [cons variable? [cons 1 [cons version [cons 1 [cons warn [cons 1 [cons writ
e-to-file [cons 2 [cons y-or-n? [cons 1 [cons + [cons 2 [cons * [cons 2 [cons /
[cons 2 [cons - [cons 2 [cons == [cons 2 [cons shen-<1> [cons 1 [cons <e> [cons
1 [cons @p [cons 2 [cons @v [cons 2 [cons @s [cons 2 [cons preclude [cons 1 [con
s include [cons 1 [cons preclude-all-but [cons 1 [cons include-all-but [cons 1 [
cons where [cons 2 []]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]
]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]
]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]
]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]

()



Evaluating: [defun systemf [V1543] [set shen-*system* [adjoin V1543 [value shen-
*system*]]]]

null



Evaluating: [defun adjoin [V1544 V1545] [if [element? V1544 V1545] V1545 [cons V
1544 V1545]]]

null



Evaluating: [map [lambda V1546 [systemf V1546]] [cons ! [cons } [cons { [cons --
> [cons <-- [cons && [cons : [cons ; [cons :- [cons := [cons [intern _] [cons <!
> [cons -*- [cons *language* [cons *implementation* [cons *stinput* [cons *home-
directory* [cons *version* [cons *maximum-print-sequence-size* [cons *printer* [
cons *macros* [cons shen-*os* [cons shen-*release* [cons @v [cons @p [cons @s [c
ons <- [cons -> [cons <e> [cons == [cons = [cons >= [cons > [cons /. [cons =! [c
ons $ [cons - [cons / [cons * [cons + [cons <= [cons < [cons >> [cons [vector 0]
 [cons y-or-n? [cons write-to-file [cons where [cons when [cons warn [cons versi
on [cons verified [cons variable? [cons value [cons vector-> [cons <-vector [con
s vector [cons vector? [cons unspecialise [cons untrack [cons union [cons unify
[cons unify! [cons unprofile [cons return [cons type [cons tuple? [cons true [co
ns trap-error [cons track [cons time [cons thaw [cons tc? [cons tc [cons tl [con
s tlstr [cons tlv [cons tail [cons systemf [cons synonyms [cons symbol [cons sym
bol? [cons sum [cons subst [cons string? [cons string->n [cons stream [cons stri
ng [cons stinput [cons shen-stoutput [cons step [cons spy [cons specialise [cons
 snd [cons simple-error [cons set [cons save [cons str [cons run [cons reverse [
cons remove [cons read [cons read-file [cons read-file-as-bytelist [cons read-fi
le-as-string [cons read-byte [cons quit [cons put [cons preclude [cons preclude-
all-but [cons ps [cons prolog? [cons protect [cons profile-results [cons profile
 [cons print [cons pr [cons pos [cons package [cons output [cons out [cons or [c
ons open [cons occurrences [cons occurs-check [cons n->string [cons number? [con
s number [cons null [cons nth [cons not [cons nl [cons mode [cons macro [cons ma
croexpand [cons maxinferences [cons mapcan [cons map [cons make-string [cons loa
d [cons loaded [cons list [cons lineread [cons limit [cons length [cons let [con
s lazy [cons lambda [cons is [cons intersection [cons inferences [cons intern [c
ons integer? [cons input [cons input+ [cons include [cons include-all-but [cons
in [cons if [cons identical [cons head [cons hd [cons hdv [cons hdstr [cons hash
 [cons get [cons get-time [cons gensym [cons function [cons fst [cons freeze [co
ns format [cons fix [cons file [cons fail [cons fail-if [cons fwhen [cons findal
l [cons false [cons explode [cons external [cons exception [cons eval-kl [cons e
val [cons error-to-string [cons error [cons empty? [cons element? [cons do [cons
 difference [cons destroy [cons defun [cons define [cons defmacro [cons defcc [c
ons defprolog [cons declare [cons datatype [cons cut [cons cn [cons cons? [cons
cons [cons cond [cons concat [cons compile [cons cd [cons cases [cons call [cons
 close [cons bind [cons bound? [cons boolean? [cons boolean [cons bar! [cons ass
oc [cons arity [cons append [cons and [cons adjoin [cons <-address [cons address
-> [cons absvector? [cons absvector [cons abort [cons intmake-string [cons intou
tput [cons interror []]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]
]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]
]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]
]]]]]]]]]

[[! | ()] [[} [! | ()]] [[{ [} [! | ()]]] [[--> [{ [} [! | ()]]]] [[<-- [--> [{
[} [! | ()]]]]] [[&&




Evaluating: [defun specialise [V1547] [do [set shen-*special* [cons V1547 [value
 shen-*special*]]] V1547]]

null



Evaluating: [defun unspecialise [V1548] [do [set shen-*special* [remove V1548 [v
alue shen-*special*]]] V1548]]

null



Evaluating:                                                    The License

 The user is free to produce commercial applications with the software, to distr
ibute these applications in source or binary  form, and to charge monies for the
m as he sees fit and in concordance with the laws of the land subject to the fol
lowing  license.

 1. The license applies to all the software and all derived software and must ap
pear on such.
 2. It is illegal to distribute the software without this license attached to it
 and use of the software implies agreement
    with the license as such. It is illegal for anyone who is not the copyright
holder to tamper with or change the license.
 3. Neither the names of Lambda Associates or the copyright holder may be used t
o endorse or promote products built using
     the software without specific prior written permission from the copyright h
older.
 4. That possession of this license does not confer on the copyright holder any
special contractual obligation towards the    user. That in no event shall the c
opyright holder be liable for any direct, indirect, incidental, special, exempla
ry or   consequential damages (including but not limited to procurement of subst
itute goods or services, loss of use, data, or    profits; or business interrupt
ion), however caused and on any theory of liability, whether in contract, strict
 liability   or tort (including negligence) arising in any way out of the use of
 the software, even if advised of the possibility of   such damage.
5. It is permitted for the user to change the software, for the purpose of impro
ving performance, correcting an error, or    porting to a new platform, and dist
ribute the modified version of Shen (hereafter the modified version) provided th
e     resulting program conforms in all respects to the Shen standard and is iss
ued under that title. The user must make it clear   with his distribution that h
e/she is the author of the changes and what these changes are and why.
6. Derived versions of this software in whatever form are subject to the same re
strictions. In particular it is not          permitted to make derived copies of
 this software which do not conform to the Shen standard or appear under a diffe
rent title.
7. It is permitted to distribute versions of Shen which incorporate libraries, g
raphics or other facilities which are not    part of the Shen standard.

For an explication of this license see http://www.lambdassociates.org/News/june1
1/license.htm which explains this license in full.

                                                   The License

 The user is free to produce comm




Evaluating: [defun load [V1651] [let Load [let Start [get-time run] [let Result
[shen-load-help [value shen-*tc*] [read-file V1651]] [let Finish [get-time run]
[let Time [- Finish Start] [let Message [intoutput
run time: ~A secs
 [@p Time []]] Result]]]]] [let Infs [if [value shen-*tc*] [intoutput
typechecked in ~A inferences
 [@p [inferences _] []]] shen-skip] loaded]]]

null



Evaluating: [defun shen-load-help [V1656 V1657] [cond [[= false V1656] [map [lam
bda X [intoutput ~S
 [@p [shen-eval-without-macros X] []]]] V1657]] [true [let RemoveSynonyms [mapca
n [lambda V1658 [shen-remove-synonyms V1658]] V1657] [let Table [mapcan [lambda
V1659 [shen-typetable V1659]] RemoveSynonyms] [let Assume [map [lambda V1660 [sh
en-assumetype V1660]] Table] [trap-error [map [lambda V1661 [shen-typecheck-and-
load V1661]] RemoveSynonyms] [lambda E [shen-unwind-types E Table]]]]]]]]]

null



Evaluating: [defun shen-remove-synonyms [V1662] [cond [[and [cons? V1662] [= she
n-synonyms-help [hd V1662]]] [do [eval V1662] []]] [true [cons V1662 []]]]]

null



Evaluating: [defun shen-typecheck-and-load [V1663] [do [nl 1] [shen-typecheck-an
d-evaluate V1663 [gensym A]]]]

null



Evaluating: [defun shen-typetable [V1668] [cond [[and [cons? V1668] [and [= defi
ne [hd V1668]] [cons? [tl V1668]]]] [let Sig [compile [lambda V1669 [shen-<sig+r
est> V1669]] [tl [tl V1668]] []] [if [= Sig [fail]] [interror ~A lacks a proper
signature.
 [@p [hd [tl V1668]] []]] [cons [cons [hd [tl V1668]] Sig] []]]]] [true []]]]

null



Evaluating: [defun shen-assumetype [V1670] [cond [[cons? V1670] [declare [hd V16
70] [tl V1670]]] [true [shen-sys-error shen-assumetype]]]]

null



Evaluating: [defun shen-unwind-types [V1675 V1676] [cond [[= [] V1676] [simple-e
rror [error-to-string V1675]]] [[and [cons? V1676] [cons? [hd V1676]]] [do [shen
-remtype [hd [hd V1676]]] [shen-unwind-types V1675 [tl V1676]]]] [true [shen-sys
-error shen-unwind-types]]]]

null



Evaluating: [defun shen-remtype [V1677] [do [set shen-*signedfuncs* [remove V167
7 [value shen-*signedfuncs*]]] V1677]]

null



Evaluating: [defun shen-<sig+rest> [V1678] [let Result [let Parse_<signature> [s
hen-<signature> V1678] [if [not [= [fail] Parse_<signature>]] [let Parse_<any> [
shen-<any> Parse_<signature>] [if [not [= [fail] Parse_<any>]] [shen-reassemble
[fst Parse_<any>] [snd Parse_<signature>]] [fail]]] [fail]]] [if [= Result [fail
]] [fail] Result]]]

null



Evaluating: [defun write-to-file [V1679 V1680] [let AbsPath [intmake-string ~A~A
 [@p [value *home-directory*] [@p V1679 []]]] [let Stream [open file AbsPath out
] [let String [intmake-string ~S

 [@p V1680 []]] [let Write [pr String Stream] [let Close [close Stream] V1680]]]
]]]

null



Evaluating:                                                    The License

 The user is free to produce commercial applications with the software, to distr
ibute these applications in source or binary  form, and to charge monies for the
m as he sees fit and in concordance with the laws of the land subject to the fol
lowing  license.

 1. The license applies to all the software and all derived software and must ap
pear on such.
 2. It is illegal to distribute the software without this license attached to it
 and use of the software implies agreement
    with the license as such. It is illegal for anyone who is not the copyright
holder to tamper with or change the license.
 3. Neither the names of Lambda Associates or the copyright holder may be used t
o endorse or promote products built using
     the software without specific prior written permission from the copyright h
older.
 4. That possession of this license does not confer on the copyright holder any
special contractual obligation towards the    user. That in no event shall the c
opyright holder be liable for any direct, indirect, incidental, special, exempla
ry or   consequential damages (including but not limited to procurement of subst
itute goods or services, loss of use, data, or    profits; or business interrupt
ion), however caused and on any theory of liability, whether in contract, strict
 liability   or tort (including negligence) arising in any way out of the use of
 the software, even if advised of the possibility of   such damage.
5. It is permitted for the user to change the software, for the purpose of impro
ving performance, correcting an error, or    porting to a new platform, and dist
ribute the modified version of Shen (hereafter the modified version) provided th
e     resulting program conforms in all respects to the Shen standard and is iss
ued under that title. The user must make it clear   with his distribution that h
e/she is the author of the changes and what these changes are and why.
6. Derived versions of this software in whatever form are subject to the same re
strictions. In particular it is not          permitted to make derived copies of
 this software which do not conform to the Shen standard or appear under a diffe
rent title.
7. It is permitted to distribute versions of Shen which incorporate libraries, g
raphics or other facilities which are not    part of the Shen standard.

For an explication of this license see http://www.lambdassociates.org/News/june1
1/license.htm which explains this license in full.

                                                   The License

 The user is free to produce comm




Evaluating: [defun macroexpand [V530] [shen-compose [value *macros*] V530]]

null



Evaluating: [defun macroexpand [V531] [let Y [shen-compose [value *macros*] V531
] [if [= V531 Y] V531 [shen-walk macroexpand Y]]]]

null



Evaluating: [set *macros* [cons shen-timer-macro [cons shen-cases-macro [cons sh
en-abs-macro [cons shen-put/get-macro [cons shen-compile-macro [cons shen-yacc-m
acro [cons shen-datatype-macro [cons shen-let-macro [cons shen-assoc-macro [cons
 shen-i/o-macro [cons shen-prolog-macro [cons shen-synonyms-macro [cons shen-nl-
macro [cons shen-vector-macro [cons shen-@s-macro [cons shen-defmacro-macro [con
s shen-defprolog-macro [cons shen-function-macro []]]]]]]]]]]]]]]]]]]]

[shen-timer-macro [shen-cases-macro [shen-abs-macro [shen-put/get-macro [shen-co
mpile-macro [shen-ya




Evaluating: [defun shen-compose [V532 V533] [cond [[= [] V532] V533] [[cons? V53
2] [shen-compose [tl V532] [[hd V532] V533]]] [true [shen-sys-error shen-compose
]]]]

null



Evaluating: [defun shen-compile-macro [V534] [cond [[and [cons? V534] [and [= co
mpile [hd V534]] [and [cons? [tl V534]] [and [cons? [tl [tl V534]]] [= [] [tl [t
l [tl V534]]]]]]]] [cons compile [cons [hd [tl V534]] [cons [hd [tl [tl V534]]]
[cons [] []]]]]] [true V534]]]

null



Evaluating: [defun shen-prolog-macro [V535] [cond [[and [cons? V535] [= prolog?
[hd V535]]] [cons shen-intprolog [cons [shen-prolog-form [tl V535]] []]]] [true
V535]]]

null



Evaluating: [defun shen-defprolog-macro [V536] [cond [[and [cons? V536] [and [=
defprolog [hd V536]] [cons? [tl V536]]]] [compile [lambda V537 [shen-<defprolog>
 V537]] [tl V536] [lambda Y [shen-prolog-error [hd [tl V536]] Y]]]] [true V536]]
]

null



Evaluating: [defun shen-prolog-form [V538] [shen-cons_form [map [lambda V539 [sh
en-cons_form V539]] V538]]]

null



Evaluating: [defun shen-datatype-macro [V540] [cond [[and [cons? V540] [and [= d
atatype [hd V540]] [cons? [tl V540]]]] [cons shen-process-datatype [cons [hd [tl
 V540]] [cons [cons compile [cons [cons function [cons shen-<datatype-rules> []]
] [cons [shen-rcons_form [tl [tl V540]]] [cons [cons function [cons shen-datatyp
e-error []]] []]]]] []]]]] [true V540]]]

null



Evaluating: [defun shen-defmacro-macro [V541] [cond [[and [cons? V541] [and [= d
efmacro [hd V541]] [cons? [tl V541]]]] [let Macro [compile shen-<defmacro> [tl V
541] []] [let Declare [cons do [cons [cons set [cons *macros* [cons [cons adjoin
 [cons [hd [tl V541]] [cons [cons value [cons *macros* []]] []]]] []]]] [cons ma
cro []]]] [let Package [cons package [cons null [cons [] [cons Declare [cons Mac
ro []]]]]] Package]]]] [true V541]]]

null



Evaluating: [defun shen-defmacro-macro [V542] [cond [[and [cons? V542] [and [= d
efmacro [hd V542]] [cons? [tl V542]]]] [let Macro [cons define [cons [hd [tl V54
2]] [append [tl [tl V542]] [cons X [cons -> [cons X []]]]]]] [let Declare [cons
do [cons [cons set [cons *macros* [cons [cons adjoin [cons [hd [tl V542]] [cons
[cons value [cons *macros* []]] []]]] []]]] [cons macro []]]] [let Package [cons
 package [cons null [cons [] [cons Declare [cons Macro []]]]]] Package]]]] [true
 V542]]]

null



Evaluating: [defun shen-<defmacro> [V543] [let Result [let Parse_<name> [shen-<n
ame> V543] [if [not [= [fail] Parse_<name>]] [let Parse_<macrorules> [shen-<macr
orules> Parse_<name>] [if [not [= [fail] Parse_<macrorules>]] [shen-reassemble [
fst Parse_<macrorules>] [cons define [cons [snd Parse_<name>] [snd Parse_<macror
ules>]]]] [fail]]] [fail]]] [if [= Result [fail]] [fail] Result]]]

null



Evaluating: [defun shen-<macrorules> [V544] [let Result [let Parse_<macrorule> [
shen-<macrorule> V544] [if [not [= [fail] Parse_<macrorule>]] [let Parse_<macror
ules> [shen-<macrorules> Parse_<macrorule>] [if [not [= [fail] Parse_<macrorules
>]] [shen-reassemble [fst Parse_<macrorules>] [append [snd Parse_<macrorule>] [s
nd Parse_<macrorules>]]] [fail]]] [fail]]] [if [= Result [fail]] [let Result [le
t Parse_<macrorule> [shen-<macrorule> V544] [if [not [= [fail] Parse_<macrorule>
]] [shen-reassemble [fst Parse_<macrorule>] [append [snd Parse_<macrorule>] [con
s X [cons -> [cons X []]]]]] [fail]]] [if [= Result [fail]] [fail] Result]] Resu
lt]]]

null



Evaluating: [defun shen-<macrorule> [V545] [let Result [let Parse_<patterns> [sh
en-<patterns> V545] [if [not [= [fail] Parse_<patterns>]] [if [and [cons? [fst P
arse_<patterns>]] [= -> [hd [fst Parse_<patterns>]]]] [let Parse_<macroaction> [
shen-<macroaction> [shen-reassemble [tl [fst Parse_<patterns>]] [snd Parse_<patt
erns>]]] [if [not [= [fail] Parse_<macroaction>]] [if [and [cons? [fst Parse_<ma
croaction>]] [= where [hd [fst Parse_<macroaction>]]]] [let Parse_<guard> [shen-
<guard> [shen-reassemble [tl [fst Parse_<macroaction>]] [snd Parse_<macroaction>
]]] [if [not [= [fail] Parse_<guard>]] [shen-reassemble [fst Parse_<guard>] [app
end [snd Parse_<patterns>] [cons -> [append [snd Parse_<macroaction>] [cons wher
e [snd Parse_<guard>]]]]]] [fail]]] [fail]] [fail]]] [fail]] [fail]]] [if [= Res
ult [fail]] [let Result [let Parse_<patterns> [shen-<patterns> V545] [if [not [=
 [fail] Parse_<patterns>]] [if [and [cons? [fst Parse_<patterns>]] [= -> [hd [fs
t Parse_<patterns>]]]] [let Parse_<macroaction> [shen-<macroaction> [shen-reasse
mble [tl [fst Parse_<patterns>]] [snd Parse_<patterns>]]] [if [not [= [fail] Par
se_<macroaction>]] [shen-reassemble [fst Parse_<macroaction>] [append [snd Parse
_<patterns>] [cons -> [snd Parse_<macroaction>]]]] [fail]]] [fail]] [fail]]] [if
 [= Result [fail]] [let Result [let Parse_<patterns> [shen-<patterns> V545] [if
[not [= [fail] Parse_<patterns>]] [if [and [cons? [fst Parse_<patterns>]] [= <-
[hd [fst Parse_<patterns>]]]] [let Parse_<macroaction> [shen-<macroaction> [shen
-reassemble [tl [fst Parse_<patterns>]] [snd Parse_<patterns>]]] [if [not [= [fa
il] Parse_<macroaction>]] [if [and [cons? [fst Parse_<macroaction>]] [= where [h
d [fst Parse_<macroaction>]]]] [let Parse_<guard> [shen-<guard> [shen-reassemble
 [tl [fst Parse_<macroaction>]] [snd Parse_<macroaction>]]] [if [not [= [fail] P
arse_<guard>]] [shen-reassemble [fst Parse_<guard>] [append [snd Parse_<patterns
>] [cons <- [append [snd Parse_<macroaction>] [cons where [snd Parse_<guard>]]]]
]] [fail]]] [fail]] [fail]]] [fail]] [fail]]] [if [= Result [fail]] [let Result
[let Parse_<patterns> [shen-<patterns> V545] [if [not [= [fail] Parse_<patterns>
]] [if [and [cons? [fst Parse_<patterns>]] [= <- [hd [fst Parse_<patterns>]]]] [
let Parse_<macroaction> [shen-<macroaction> [shen-reassemble [tl [fst Parse_<pat
terns>]] [snd Parse_<patterns>]]] [if [not [= [fail] Parse_<macroaction>]] [shen
-reassemble [fst Parse_<macroaction>] [append [snd Parse_<patterns>] [cons <- [s
nd Parse_<macroaction>]]]] [fail]]] [fail]] [fail]]] [if [= Result [fail]] [fail
] Result]] Result]] Result]] Result]]]

null



Evaluating: [defun shen-<macroaction> [V546] [let Result [let Parse_<action> [sh
en-<action> V546] [if [not [= [fail] Parse_<action>]] [shen-reassemble [fst Pars
e_<action>] [cons [cons shen-walk [cons [cons function [cons macroexpand []]] [c
ons [snd Parse_<action>] []]]] []]] [fail]]] [if [= Result [fail]] [fail] Result
]]]

null



Evaluating: [defun shen-@s-macro [V547] [cond [[and [cons? V547] [and [= @s [hd
V547]] [and [cons? [tl V547]] [and [cons? [tl [tl V547]]] [cons? [tl [tl [tl V54
7]]]]]]]] [cons @s [cons [hd [tl V547]] [cons [shen-@s-macro [cons @s [tl [tl V5
47]]]] []]]]] [[and [cons? V547] [and [= @s [hd V547]] [and [cons? [tl V547]] [a
nd [cons? [tl [tl V547]]] [and [= [] [tl [tl [tl V547]]]] [string? [hd [tl V547]
]]]]]]] [let E [explode [hd [tl V547]]] [if [> [length E] 1] [shen-@s-macro [con
s @s [append E [tl [tl V547]]]]] V547]]] [true V547]]]

null



Evaluating: [defun shen-synonyms-macro [V548] [cond [[and [cons? V548] [= synony
ms [hd V548]]] [cons shen-synonyms-help [cons [shen-rcons_form [tl V548]] []]]]
[true V548]]]

null



Evaluating: [defun shen-nl-macro [V549] [cond [[and [cons? V549] [and [= nl [hd
V549]] [= [] [tl V549]]]] [cons nl [cons 1 []]]] [true V549]]]

null



Evaluating: [defun shen-vector-macro [V550] [cond [[= [vector 0] V550] [cons vec
tor [cons 0 []]]] [true V550]]]

null



Evaluating: [defun shen-yacc-macro [V551] [cond [[and [cons? V551] [and [= defcc
 [hd V551]] [cons? [tl V551]]]] [shen-yacc->shen [hd [tl V551]] [tl [tl V551]] [
shen-extract-segvars [tl [tl V551]]]]] [true V551]]]

null



Evaluating: [defun shen-assoc-macro [V552] [cond [[and [cons? V552] [and [cons?
[tl V552]] [and [cons? [tl [tl V552]]] [and [cons? [tl [tl [tl V552]]]] [element
? [hd V552] [cons @p [cons @v [cons append [cons and [cons or [cons + [cons * [c
ons do []]]]]]]]]]]]]] [cons [hd V552] [cons [hd [tl V552]] [cons [shen-assoc-ma
cro [cons [hd V552] [tl [tl V552]]]] []]]]] [true V552]]]

null



Evaluating: [defun shen-let-macro [V553] [cond [[and [cons? V553] [and [= let [h
d V553]] [and [cons? [tl V553]] [and [cons? [tl [tl V553]]] [and [cons? [tl [tl
[tl V553]]]] [cons? [tl [tl [tl [tl V553]]]]]]]]]] [cons let [cons [hd [tl V553]
] [cons [hd [tl [tl V553]]] [cons [shen-let-macro [cons let [tl [tl [tl V553]]]]
] []]]]]] [true V553]]]

null



Evaluating: [defun shen-abs-macro [V554] [cond [[and [cons? V554] [and [= /. [hd
 V554]] [and [cons? [tl V554]] [and [cons? [tl [tl V554]]] [cons? [tl [tl [tl V5
54]]]]]]]] [cons lambda [cons [hd [tl V554]] [cons [shen-abs-macro [cons /. [tl
[tl V554]]]] []]]]] [[and [cons? V554] [and [= /. [hd V554]] [and [cons? [tl V55
4]] [and [cons? [tl [tl V554]]] [= [] [tl [tl [tl V554]]]]]]]] [cons lambda [tl
V554]]] [true V554]]]

null



Evaluating: [defun shen-cases-macro [V557] [cond [[and [cons? V557] [and [= case
s [hd V557]] [and [cons? [tl V557]] [and [= true [hd [tl V557]]] [cons? [tl [tl
V557]]]]]]] [hd [tl [tl V557]]]] [[and [cons? V557] [and [= cases [hd V557]] [an
d [cons? [tl V557]] [and [cons? [tl [tl V557]]] [= [] [tl [tl [tl V557]]]]]]]] [
cons if [cons [hd [tl V557]] [cons [hd [tl [tl V557]]] [cons [shen-i/o-macro [co
ns error [cons error: cases exhausted
 []]]] []]]]]] [[and [cons? V557] [and [= cases [hd V557]] [and [cons? [tl V557]
] [cons? [tl [tl V557]]]]]] [cons if [cons [hd [tl V557]] [cons [hd [tl [tl V557
]]] [cons [shen-cases-macro [cons cases [tl [tl [tl V557]]]]] []]]]]] [[and [con
s? V557] [and [= cases [hd V557]] [and [cons? [tl V557]] [= [] [tl [tl V557]]]]]
] [interror error: odd number of case elements
 []]] [true V557]]]

null



Evaluating: [defun shen-timer-macro [V558] [cond [[and [cons? V558] [and [= time
 [hd V558]] [and [cons? [tl V558]] [= [] [tl [tl V558]]]]]] [shen-let-macro [con
s let [cons Start [cons [cons get-time [cons run []]] [cons Result [cons [hd [tl
 V558]] [cons Finish [cons [cons get-time [cons run []]] [cons Time [cons [cons
- [cons Finish [cons Start []]]] [cons Message [cons [shen-i/o-macro [cons outpu
t [cons
run time: ~A secs
 [cons Time []]]]] [cons Result []]]]]]]]]]]]]]] [true V558]]]

null



Evaluating: [defun shen-i/o-macro [V559] [cond [[and [cons? V559] [and [= output
 [hd V559]] [cons? [tl V559]]]] [cons intoutput [cons [hd [tl V559]] [cons [shen
-tuple-up [tl [tl V559]]] []]]]] [[and [cons? V559] [and [= make-string [hd V559
]] [cons? [tl V559]]]] [cons intmake-string [cons [hd [tl V559]] [cons [shen-tup
le-up [tl [tl V559]]] []]]]] [[and [cons? V559] [and [= error [hd V559]] [cons?
[tl V559]]]] [cons interror [cons [hd [tl V559]] [cons [shen-tuple-up [tl [tl V5
59]]] []]]]] [[and [cons? V559] [and [= pr [hd V559]] [and [cons? [tl V559]] [=
[] [tl [tl V559]]]]]] [cons pr [cons [hd [tl V559]] [cons [cons shen-stoutput [c
ons 0 []]] []]]]] [[and [cons? V559] [and [= read-byte [hd V559]] [= [] [tl V559
]]]] [cons read-byte [cons [cons stinput [cons 0 []]] []]]] [true V559]]]

null



Evaluating: [defun shen-tuple-up [V560] [cond [[cons? V560] [cons @p [cons [hd V
560] [cons [shen-tuple-up [tl V560]] []]]]] [true V560]]]

null



Evaluating: [defun shen-put/get-macro [V561] [cond [[and [cons? V561] [and [= pu
t [hd V561]] [and [cons? [tl V561]] [and [cons? [tl [tl V561]]] [and [cons? [tl
[tl [tl V561]]]] [= [] [tl [tl [tl [tl V561]]]]]]]]]] [cons put [cons [hd [tl V5
61]] [cons [hd [tl [tl V561]]] [cons [hd [tl [tl [tl V561]]]] [cons [cons value
[cons shen-*property-vector* []]] []]]]]]] [[and [cons? V561] [and [= get [hd V5
61]] [and [cons? [tl V561]] [and [cons? [tl [tl V561]]] [= [] [tl [tl [tl V561]]
]]]]]] [cons get [cons [hd [tl V561]] [cons [hd [tl [tl V561]]] [cons [cons valu
e [cons shen-*property-vector* []]] []]]]]] [true V561]]]

null



Evaluating: [defun shen-function-macro [V562] [cond [[and [cons? V562] [and [= f
unction [hd V562]] [and [cons? [tl V562]] [= [] [tl [tl V562]]]]]] [shen-functio
n-abstraction [hd [tl V562]] [arity [hd [tl V562]]]]] [true V562]]]

null



Evaluating: [defun shen-function-abstraction [V563 V564] [cond [[= 0 V564] [cons
 freeze [cons V563 []]]] [[= -1 V564] V563] [true [shen-function-abstraction-hel
p V563 V564 []]]]]

null



Evaluating: [defun shen-function-abstraction-help [V565 V566 V567] [cond [[= 0 V
566] [cons V565 V567]] [true [let X [gensym V] [cons /. [cons X [cons [shen-func
tion-abstraction-help V565 [- V566 1] [append V567 [cons X []]]] []]]]]]]]

null



Evaluating:                                                    The License

 The user is free to produce commercial applications with the software, to distr
ibute these applications in source or binary  form, and to charge monies for the
m as he sees fit and in concordance with the laws of the land subject to the fol
lowing  license.

 1. The license applies to all the software and all derived software and must ap
pear on such.
 2. It is illegal to distribute the software without this license attached to it
 and use of the software implies agreement
    with the license as such. It is illegal for anyone who is not the copyright
holder to tamper with or change the license.
 3. Neither the names of Lambda Associates or the copyright holder may be used t
o endorse or promote products built using
     the software without specific prior written permission from the copyright h
older.
 4. That possession of this license does not confer on the copyright holder any
special contractual obligation towards the    user. That in no event shall the c
opyright holder be liable for any direct, indirect, incidental, special, exempla
ry or   consequential damages (including but not limited to procurement of subst
itute goods or services, loss of use, data, or    profits; or business interrupt
ion), however caused and on any theory of liability, whether in contract, strict
 liability   or tort (including negligence) arising in any way out of the use of
 the software, even if advised of the possibility of   such damage.
5. It is permitted for the user to change the software, for the purpose of impro
ving performance, correcting an error, or    porting to a new platform, and dist
ribute the modified version of Shen (hereafter the modified version) provided th
e     resulting program conforms in all respects to the Shen standard and is iss
ued under that title. The user must make it clear   with his distribution that h
e/she is the author of the changes and what these changes are and why.
6. Derived versions of this software in whatever form are subject to the same re
strictions. In particular it is not          permitted to make derived copies of
 this software which do not conform to the Shen standard or appear under a diffe
rent title.
7. It is permitted to distribute versions of Shen which incorporate libraries, g
raphics or other facilities which are not    part of the Shen standard.

For an explication of this license see http://www.lambdassociates.org/News/june1
1/license.htm which explains this license in full.

                                                   The License

 The user is free to produce comm




Evaluating: [set shen-*symbolcodes* [vector 128]]

[Ljava.lang.Object;@73e1518e



Evaluating: [address-> [value shen-*symbolcodes*] 126 ~]

[Ljava.lang.Object;@67591ba4



Evaluating: [address-> [value shen-*symbolcodes*] 122 z]

[Ljava.lang.Object;@67591ba4



Evaluating: [address-> [value shen-*symbolcodes*] 121 y]

[Ljava.lang.Object;@67591ba4



Evaluating: [address-> [value shen-*symbolcodes*] 120 x]

[Ljava.lang.Object;@67591ba4



Evaluating: [address-> [value shen-*symbolcodes*] 119 w]

[Ljava.lang.Object;@67591ba4



Evaluating: [address-> [value shen-*symbolcodes*] 118 v]

[Ljava.lang.Object;@67591ba4



Evaluating: [address-> [value shen-*symbolcodes*] 117 u]

[Ljava.lang.Object;@67591ba4



Evaluating: [address-> [value shen-*symbolcodes*] 116 t]

[Ljava.lang.Object;@67591ba4



Evaluating: [address-> [value shen-*symbolcodes*] 115 s]

[Ljava.lang.Object;@67591ba4



Evaluating: [address-> [value shen-*symbolcodes*] 114 r]

[Ljava.lang.Object;@67591ba4



Evaluating: [address-> [value shen-*symbolcodes*] 113 q]

[Ljava.lang.Object;@67591ba4



Evaluating: [address-> [value shen-*symbolcodes*] 112 p]

[Ljava.lang.Object;@67591ba4



Evaluating: [address-> [value shen-*symbolcodes*] 111 o]

[Ljava.lang.Object;@67591ba4



Evaluating: [address-> [value shen-*symbolcodes*] 110 n]

[Ljava.lang.Object;@67591ba4



Evaluating: [address-> [value shen-*symbolcodes*] 109 m]

[Ljava.lang.Object;@67591ba4



Evaluating: [address-> [value shen-*symbolcodes*] 108 l]

[Ljava.lang.Object;@67591ba4



Evaluating: [address-> [value shen-*symbolcodes*] 107 k]

[Ljava.lang.Object;@67591ba4



Evaluating: [address-> [value shen-*symbolcodes*] 106 j]

[Ljava.lang.Object;@67591ba4



Evaluating: [address-> [value shen-*symbolcodes*] 105 i]

[Ljava.lang.Object;@67591ba4



Evaluating: [address-> [value shen-*symbolcodes*] 104 h]

[Ljava.lang.Object;@67591ba4



Evaluating: [address-> [value shen-*symbolcodes*] 103 g]

[Ljava.lang.Object;@67591ba4



Evaluating: [address-> [value shen-*symbolcodes*] 102 f]

[Ljava.lang.Object;@67591ba4



Evaluating: [address-> [value shen-*symbolcodes*] 101 e]

[Ljava.lang.Object;@67591ba4



Evaluating: [address-> [value shen-*symbolcodes*] 100 d]

[Ljava.lang.Object;@67591ba4



Evaluating: [address-> [value shen-*symbolcodes*] 99 c]

[Ljava.lang.Object;@67591ba4



Evaluating: [address-> [value shen-*symbolcodes*] 98 b]

[Ljava.lang.Object;@67591ba4



Evaluating: [address-> [value shen-*symbolcodes*] 97 a]

[Ljava.lang.Object;@67591ba4



Evaluating: [address-> [value shen-*symbolcodes*] 96 `]

[Ljava.lang.Object;@b25e0fe



Evaluating: [address-> [value shen-*symbolcodes*] 95 _]

[Ljava.lang.Object;@67591ba4



Evaluating: [address-> [value shen-*symbolcodes*] 90 Z]

[Ljava.lang.Object;@67591ba4



Evaluating: [address-> [value shen-*symbolcodes*] 89 Y]

[Ljava.lang.Object;@b25e0fe



Evaluating: [address-> [value shen-*symbolcodes*] 88 X]

[Ljava.lang.Object;@67591ba4



Evaluating: [address-> [value shen-*symbolcodes*] 87 W]

[Ljava.lang.Object;@b25e0fe



Evaluating: [address-> [value shen-*symbolcodes*] 86 V]

[Ljava.lang.Object;@67591ba4



Evaluating: [address-> [value shen-*symbolcodes*] 85 U]

[Ljava.lang.Object;@67591ba4



Evaluating: [address-> [value shen-*symbolcodes*] 84 T]

[Ljava.lang.Object;@67591ba4



Evaluating: [address-> [value shen-*symbolcodes*] 83 S]

[Ljava.lang.Object;@67591ba4



Evaluating: [address-> [value shen-*symbolcodes*] 82 R]

[Ljava.lang.Object;@67591ba4



Evaluating: [address-> [value shen-*symbolcodes*] 81 Q]

[Ljava.lang.Object;@67591ba4



Evaluating: [address-> [value shen-*symbolcodes*] 80 P]

[Ljava.lang.Object;@67591ba4



Evaluating: [address-> [value shen-*symbolcodes*] 79 O]

[Ljava.lang.Object;@67591ba4



Evaluating: [address-> [value shen-*symbolcodes*] 78 N]

[Ljava.lang.Object;@67591ba4



Evaluating: [address-> [value shen-*symbolcodes*] 77 M]

[Ljava.lang.Object;@67591ba4



Evaluating: [address-> [value shen-*symbolcodes*] 76 L]

[Ljava.lang.Object;@67591ba4



Evaluating: [address-> [value shen-*symbolcodes*] 75 K]

[Ljava.lang.Object;@67591ba4



Evaluating: [address-> [value shen-*symbolcodes*] 74 J]

[Ljava.lang.Object;@67591ba4



Evaluating: [address-> [value shen-*symbolcodes*] 73 I]

[Ljava.lang.Object;@67591ba4



Evaluating: [address-> [value shen-*symbolcodes*] 72 H]

[Ljava.lang.Object;@67591ba4



Evaluating: [address-> [value shen-*symbolcodes*] 71 G]

[Ljava.lang.Object;@67591ba4



Evaluating: [address-> [value shen-*symbolcodes*] 70 F]

[Ljava.lang.Object;@67591ba4



Evaluating: [address-> [value shen-*symbolcodes*] 69 E]

[Ljava.lang.Object;@67591ba4



Evaluating: [address-> [value shen-*symbolcodes*] 68 D]

[Ljava.lang.Object;@67591ba4



Evaluating: [address-> [value shen-*symbolcodes*] 67 C]

[Ljava.lang.Object;@67591ba4



Evaluating: [address-> [value shen-*symbolcodes*] 66 B]

[Ljava.lang.Object;@67591ba4



Evaluating: [address-> [value shen-*symbolcodes*] 65 A]

[Ljava.lang.Object;@67591ba4



Evaluating: [address-> [value shen-*symbolcodes*] 64 @]

[Ljava.lang.Object;@67591ba4



Evaluating: [address-> [value shen-*symbolcodes*] 63 ?]

[Ljava.lang.Object;@67591ba4



Evaluating: [address-> [value shen-*symbolcodes*] 62 >]

[Ljava.lang.Object;@b25e0fe



Evaluating: [address-> [value shen-*symbolcodes*] 61 =]

[Ljava.lang.Object;@67591ba4



Evaluating: [address-> [value shen-*symbolcodes*] 60 <]

[Ljava.lang.Object;@67591ba4



Evaluating: [address-> [value shen-*symbolcodes*] 57 9]

[Ljava.lang.Object;@b25e0fe



Evaluating: [address-> [value shen-*symbolcodes*] 56 8]

[Ljava.lang.Object;@b25e0fe



Evaluating: [address-> [value shen-*symbolcodes*] 55 7]

[Ljava.lang.Object;@67591ba4



Evaluating: [address-> [value shen-*symbolcodes*] 54 6]

[Ljava.lang.Object;@67591ba4



Evaluating: [address-> [value shen-*symbolcodes*] 53 5]

[Ljava.lang.Object;@67591ba4



Evaluating: [address-> [value shen-*symbolcodes*] 52 4]

[Ljava.lang.Object;@b25e0fe



Evaluating: [address-> [value shen-*symbolcodes*] 51 3]

[Ljava.lang.Object;@b25e0fe



Evaluating: [address-> [value shen-*symbolcodes*] 50 2]

[Ljava.lang.Object;@b25e0fe



Evaluating: [address-> [value shen-*symbolcodes*] 49 1]

[Ljava.lang.Object;@b25e0fe



Evaluating: [address-> [value shen-*symbolcodes*] 48 0]

[Ljava.lang.Object;@67591ba4



Evaluating: [address-> [value shen-*symbolcodes*] 47 /]

[Ljava.lang.Object;@b25e0fe



Evaluating: [address-> [value shen-*symbolcodes*] 46 .]

[Ljava.lang.Object;@67591ba4



Evaluating: [address-> [value shen-*symbolcodes*] 45 -]

[Ljava.lang.Object;@67591ba4



Evaluating: [address-> [value shen-*symbolcodes*] 43 +]

[Ljava.lang.Object;@67591ba4



Evaluating: [address-> [value shen-*symbolcodes*] 42 *]

[Ljava.lang.Object;@67591ba4



Evaluating: [address-> [value shen-*symbolcodes*] 39 ']

[Ljava.lang.Object;@67591ba4



Evaluating: [address-> [value shen-*symbolcodes*] 38 &]

[Ljava.lang.Object;@67591ba4



Evaluating: [address-> [value shen-*symbolcodes*] 37 %]

[Ljava.lang.Object;@67591ba4



Evaluating: [address-> [value shen-*symbolcodes*] 36 $]

[Ljava.lang.Object;@67591ba4



Evaluating: [address-> [value shen-*symbolcodes*] 35 #]

[Ljava.lang.Object;@67591ba4



Evaluating: [address-> [value shen-*symbolcodes*] 33 !]

[Ljava.lang.Object;@67591ba4



Evaluating: [defun lineread [] [shen-lineread-loop [read-byte [stinput 0]] []]]

null



Evaluating: [defun shen-lineread-loop [V967 V968] [cond [[= V967 [shen-hat]] [in
terror line read aborted []]] [[element? V967 [cons [shen-newline] [cons [shen-c
arriage-return] []]]] [let Line [compile [lambda V969 [shen-<st_input> V969]] V9
68 []] [if [or [= Line [fail]] [empty? Line]] [shen-lineread-loop [read-byte [st
input 0]] [append V968 [cons V967 []]]] Line]]] [true [shen-lineread-loop [read-
byte [stinput 0]] [append V968 [cons V967 []]]]]]]

null



Evaluating: [defun read-file [V970] [let Bytelist [read-file-as-bytelist V970] [
compile [lambda V971 [shen-<st_input> V971]] Bytelist [lambda V972 [shen-read-er
ror V972]]]]]

null



Evaluating: [defun shen-read-error [V973] [interror read error here:

 ~A
 [@p [shen-compress-50 50 V973] []]]]

null



Evaluating: [defun shen-compress-50 [V978 V979] [cond [[= [] V979] ] [[= 0 V978]
 ] [[cons? V979] [cn [n->string [hd V979]] [shen-compress-50 [- V978 1] [tl V979
]]]] [true [shen-sys-error shen-compress-50]]]]

null



Evaluating: [defun shen-<st_input> [V980] [let Result [let Parse_<lsb> [shen-<ls
b> V980] [if [not [= [fail] Parse_<lsb>]] [let Parse_<st_input1> [shen-<st_input
1> Parse_<lsb>] [if [not [= [fail] Parse_<st_input1>]] [let Parse_<rsb> [shen-<r
sb> Parse_<st_input1>] [if [not [= [fail] Parse_<rsb>]] [let Parse_<st_input2> [
shen-<st_input2> Parse_<rsb>] [if [not [= [fail] Parse_<st_input2>]] [shen-reass
emble [fst Parse_<st_input2>] [cons [macroexpand [shen-cons_form [snd Parse_<st_
input1>]]] [snd Parse_<st_input2>]]] [fail]]] [fail]]] [fail]]] [fail]]] [if [=
Result [fail]] [let Result [let Parse_<lrb> [shen-<lrb> V980] [if [not [= [fail]
 Parse_<lrb>]] [let Parse_<st_input1> [shen-<st_input1> Parse_<lrb>] [if [not [=
 [fail] Parse_<st_input1>]] [let Parse_<rrb> [shen-<rrb> Parse_<st_input1>] [if
[not [= [fail] Parse_<rrb>]] [let Parse_<st_input2> [shen-<st_input2> Parse_<rrb
>] [if [not [= [fail] Parse_<st_input2>]] [shen-reassemble [fst Parse_<st_input2
>] [shen-package-macro [macroexpand [snd Parse_<st_input1>]] [snd Parse_<st_inpu
t2>]]] [fail]]] [fail]]] [fail]]] [fail]]] [if [= Result [fail]] [let Result [le
t Parse_<lcurly> [shen-<lcurly> V980] [if [not [= [fail] Parse_<lcurly>]] [let P
arse_<st_input> [shen-<st_input> Parse_<lcurly>] [if [not [= [fail] Parse_<st_in
put>]] [shen-reassemble [fst Parse_<st_input>] [cons { [snd Parse_<st_input>]]]
[fail]]] [fail]]] [if [= Result [fail]] [let Result [let Parse_<rcurly> [shen-<r
curly> V980] [if [not [= [fail] Parse_<rcurly>]] [let Parse_<st_input> [shen-<st
_input> Parse_<rcurly>] [if [not [= [fail] Parse_<st_input>]] [shen-reassemble [
fst Parse_<st_input>] [cons } [snd Parse_<st_input>]]] [fail]]] [fail]]] [if [=
Result [fail]] [let Result [let Parse_<bar> [shen-<bar> V980] [if [not [= [fail]
 Parse_<bar>]] [let Parse_<st_input> [shen-<st_input> Parse_<bar>] [if [not [= [
fail] Parse_<st_input>]] [shen-reassemble [fst Parse_<st_input>] [cons bar! [snd
 Parse_<st_input>]]] [fail]]] [fail]]] [if [= Result [fail]] [let Result [let Pa
rse_<semicolon> [shen-<semicolon> V980] [if [not [= [fail] Parse_<semicolon>]] [
let Parse_<st_input> [shen-<st_input> Parse_<semicolon>] [if [not [= [fail] Pars
e_<st_input>]] [shen-reassemble [fst Parse_<st_input>] [cons ; [snd Parse_<st_in
put>]]] [fail]]] [fail]]] [if [= Result [fail]] [let Result [let Parse_<colon> [
shen-<colon> V980] [if [not [= [fail] Parse_<colon>]] [let Parse_<equal> [shen-<
equal> Parse_<colon>] [if [not [= [fail] Parse_<equal>]] [let Parse_<st_input> [
shen-<st_input> Parse_<equal>] [if [not [= [fail] Parse_<st_input>]] [shen-reass
emble [fst Parse_<st_input>] [cons := [snd Parse_<st_input>]]] [fail]]] [fail]]]
 [fail]]] [if [= Result [fail]] [let Result [let Parse_<colon> [shen-<colon> V98
0] [if [not [= [fail] Parse_<colon>]] [let Parse_<minus> [shen-<minus> Parse_<co
lon>] [if [not [= [fail] Parse_<minus>]] [let Parse_<st_input> [shen-<st_input>
Parse_<minus>] [if [not [= [fail] Parse_<st_input>]] [shen-reassemble [fst Parse
_<st_input>] [cons :- [snd Parse_<st_input>]]] [fail]]] [fail]]] [fail]]] [if [=
 Result [fail]] [let Result [let Parse_<colon> [shen-<colon> V980] [if [not [= [
fail] Parse_<colon>]] [let Parse_<st_input> [shen-<st_input> Parse_<colon>] [if
[not [= [fail] Parse_<st_input>]] [shen-reassemble [fst Parse_<st_input>] [cons
: [snd Parse_<st_input>]]] [fail]]] [fail]]] [if [= Result [fail]] [let Result [
let Parse_<comma> [shen-<comma> V980] [if [not [= [fail] Parse_<comma>]] [let Pa
rse_<st_input> [shen-<st_input> Parse_<comma>] [if [not [= [fail] Parse_<st_inpu
t>]] [shen-reassemble [fst Parse_<st_input>] [cons shen- [snd Parse_<st_input>]]
] [fail]]] [fail]]] [if [= Result [fail]] [let Result [let Parse_<comment> [shen
-<comment> V980] [if [not [= [fail] Parse_<comment>]] [let Parse_<st_input> [she
n-<st_input> Parse_<comment>] [if [not [= [fail] Parse_<st_input>]] [shen-reasse
mble [fst Parse_<st_input>] [snd Parse_<st_input>]] [fail]]] [fail]]] [if [= Res
ult [fail]] [let Result [let Parse_<atom> [shen-<atom> V980] [if [not [= [fail]
Parse_<atom>]] [let Parse_<st_input> [shen-<st_input> Parse_<atom>] [if [not [=
[fail] Parse_<st_input>]] [shen-reassemble [fst Parse_<st_input>] [cons [macroex
pand [snd Parse_<atom>]] [snd Parse_<st_input>]]] [fail]]] [fail]]] [if [= Resul
t [fail]] [let Result [let Parse_<whitespaces> [shen-<whitespaces> V980] [if [no
t [= [fail] Parse_<whitespaces>]] [let Parse_<st_input> [shen-<st_input> Parse_<
whitespaces>] [if [not [= [fail] Parse_<st_input>]] [shen-reassemble [fst Parse_
<st_input>] [snd Parse_<st_input>]] [fail]]] [fail]]] [if [= Result [fail]] [let
 Result [let Parse_<e> [<e> V980] [if [not [= [fail] Parse_<e>]] [shen-reassembl
e [fst Parse_<e>] []] [fail]]] [if [= Result [fail]] [fail] Result]] Result]] Re
sult]] Result]] Result]] Result]] Result]] Result]] Result]] Result]] Result]] R
esult]] Result]] Result]]]

null



Evaluating: [defun shen-<lsb> [V981] [let Result [if [cons? [fst V981]] [shen-re
assemble [fst [shen-reassemble [tl [fst V981]] [snd V981]]] [if [= [hd [fst V981
]] 91] shen-skip [fail]]] [fail]] [if [= Result [fail]] [fail] Result]]]

null



Evaluating: [defun shen-<rsb> [V982] [let Result [if [cons? [fst V982]] [shen-re
assemble [fst [shen-reassemble [tl [fst V982]] [snd V982]]] [if [= [hd [fst V982
]] 93] shen-skip [fail]]] [fail]] [if [= Result [fail]] [fail] Result]]]

null



Evaluating: [defun shen-<lcurly> [V983] [let Result [if [cons? [fst V983]] [shen
-reassemble [fst [shen-reassemble [tl [fst V983]] [snd V983]]] [if [= [hd [fst V
983]] 123] shen-skip [fail]]] [fail]] [if [= Result [fail]] [fail] Result]]]

null



Evaluating: [defun shen-<rcurly> [V984] [let Result [if [cons? [fst V984]] [shen
-reassemble [fst [shen-reassemble [tl [fst V984]] [snd V984]]] [if [= [hd [fst V
984]] 125] shen-skip [fail]]] [fail]] [if [= Result [fail]] [fail] Result]]]

null



Evaluating: [defun shen-<bar> [V985] [let Result [if [cons? [fst V985]] [shen-re
assemble [fst [shen-reassemble [tl [fst V985]] [snd V985]]] [if [= [hd [fst V985
]] 124] shen-skip [fail]]] [fail]] [if [= Result [fail]] [fail] Result]]]

null



Evaluating: [defun shen-<semicolon> [V986] [let Result [if [cons? [fst V986]] [s
hen-reassemble [fst [shen-reassemble [tl [fst V986]] [snd V986]]] [if [= [hd [fs
t V986]] 59] shen-skip [fail]]] [fail]] [if [= Result [fail]] [fail] Result]]]

null



Evaluating: [defun shen-<colon> [V987] [let Result [if [cons? [fst V987]] [shen-
reassemble [fst [shen-reassemble [tl [fst V987]] [snd V987]]] [if [= [hd [fst V9
87]] 58] shen-skip [fail]]] [fail]] [if [= Result [fail]] [fail] Result]]]

null



Evaluating: [defun shen-<comma> [V988] [let Result [if [cons? [fst V988]] [shen-
reassemble [fst [shen-reassemble [tl [fst V988]] [snd V988]]] [if [= [hd [fst V9
88]] 44] shen-skip [fail]]] [fail]] [if [= Result [fail]] [fail] Result]]]

null



Evaluating: [defun shen-<equal> [V989] [let Result [if [cons? [fst V989]] [shen-
reassemble [fst [shen-reassemble [tl [fst V989]] [snd V989]]] [if [= [hd [fst V9
89]] 61] shen-skip [fail]]] [fail]] [if [= Result [fail]] [fail] Result]]]

null



Evaluating: [defun shen-<minus> [V990] [let Result [if [cons? [fst V990]] [shen-
reassemble [fst [shen-reassemble [tl [fst V990]] [snd V990]]] [if [= [hd [fst V9
90]] 45] shen-skip [fail]]] [fail]] [if [= Result [fail]] [fail] Result]]]

null



Evaluating: [defun shen-<lrb> [V991] [let Result [if [cons? [fst V991]] [shen-re
assemble [fst [shen-reassemble [tl [fst V991]] [snd V991]]] [if [= [hd [fst V991
]] 40] shen-skip [fail]]] [fail]] [if [= Result [fail]] [fail] Result]]]

null



Evaluating: [defun shen-<rrb> [V992] [let Result [if [cons? [fst V992]] [shen-re
assemble [fst [shen-reassemble [tl [fst V992]] [snd V992]]] [if [= [hd [fst V992
]] 41] shen-skip [fail]]] [fail]] [if [= Result [fail]] [fail] Result]]]

null



Evaluating: [defun shen-<atom> [V993] [let Result [let Parse_<str> [shen-<str> V
993] [if [not [= [fail] Parse_<str>]] [shen-reassemble [fst Parse_<str>] [shen-c
ontrol-chars [snd Parse_<str>]]] [fail]]] [if [= Result [fail]] [let Result [let
 Parse_<number> [shen-<number> V993] [if [not [= [fail] Parse_<number>]] [shen-r
eassemble [fst Parse_<number>] [snd Parse_<number>]] [fail]]] [if [= Result [fai
l]] [let Result [let Parse_<sym> [shen-<sym> V993] [if [not [= [fail] Parse_<sym
>]] [shen-reassemble [fst Parse_<sym>] [snd Parse_<sym>]] [fail]]] [if [= Result
 [fail]] [fail] Result]] Result]] Result]]]

null



Evaluating: [defun shen-control-chars [V994] [cond [[= [] V994] ] [[and [cons? V
994] [and [= c [hd V994]] [and [cons? [tl V994]] [= # [hd [tl V994]]]]]] [let Co
dePoint [shen-code-point [tl [tl V994]]] [let AfterCodePoint [shen-after-codepoi
nt [tl [tl V994]]] [@s [n->string [shen-decimalise CodePoint]] [shen-control-cha
rs AfterCodePoint]]]]] [[cons? V994] [@s [hd V994] [shen-control-chars [tl V994]
]]] [true [shen-sys-error shen-control-chars]]]]

null



Evaluating: [defun shen-code-point [V997] [cond [[and [cons? V997] [= ; [hd V997
]]] ] [[and [cons? V997] [element? [hd V997] [cons 0 [cons 1 [cons 2 [cons 3 [co
ns 4 [cons 5 [cons 6 [cons 7 [cons 8 [cons 9 [cons 0 []]]]]]]]]]]]]] [cons [hd V
997] [shen-code-point [tl V997]]]] [true [interror code point parse error ~A
 [@p V997 []]]]]]

null



Evaluating: [defun shen-after-codepoint [V1002] [cond [[= [] V1002] []] [[and [c
ons? V1002] [= ; [hd V1002]]] [tl V1002]] [[cons? V1002] [shen-after-codepoint [
tl V1002]]] [true [shen-sys-error shen-after-codepoint]]]]

null



Evaluating: [defun shen-decimalise [V1003] [shen-pre [reverse [shen-digits->inte
gers V1003]] 0]]

null



Evaluating: [defun shen-digits->integers [V1008] [cond [[and [cons? V1008] [= 0
[hd V1008]]] [cons 0 [shen-digits->integers [tl V1008]]]] [[and [cons? V1008] [=
 1 [hd V1008]]] [cons 1 [shen-digits->integers [tl V1008]]]] [[and [cons? V1008]
 [= 2 [hd V1008]]] [cons 2 [shen-digits->integers [tl V1008]]]] [[and [cons? V10
08] [= 3 [hd V1008]]] [cons 3 [shen-digits->integers [tl V1008]]]] [[and [cons?
V1008] [= 4 [hd V1008]]] [cons 4 [shen-digits->integers [tl V1008]]]] [[and [con
s? V1008] [= 5 [hd V1008]]] [cons 5 [shen-digits->integers [tl V1008]]]] [[and [
cons? V1008] [= 6 [hd V1008]]] [cons 6 [shen-digits->integers [tl V1008]]]] [[an
d [cons? V1008] [= 7 [hd V1008]]] [cons 7 [shen-digits->integers [tl V1008]]]] [
[and [cons? V1008] [= 8 [hd V1008]]] [cons 8 [shen-digits->integers [tl V1008]]]
] [[and [cons? V1008] [= 9 [hd V1008]]] [cons 9 [shen-digits->integers [tl V1008
]]]] [true []]]]

null



Evaluating: [defun shen-<sym> [V1009] [let Result [let Parse_<alpha> [shen-<alph
a> V1009] [if [not [= [fail] Parse_<alpha>]] [let Parse_<symchars> [shen-<symcha
rs> Parse_<alpha>] [if [not [= [fail] Parse_<symchars>]] [shen-reassemble [fst P
arse_<symchars>] [intern [cn [snd Parse_<alpha>] [snd Parse_<symchars>]]]] [fail
]]] [fail]]] [if [= Result [fail]] [let Result [let Parse_<alpha> [shen-<alpha>
V1009] [if [not [= [fail] Parse_<alpha>]] [shen-reassemble [fst Parse_<alpha>] [
intern [snd Parse_<alpha>]]] [fail]]] [if [= Result [fail]] [fail] Result]] Resu
lt]]]

null



Evaluating: [defun shen-<symchars> [V1010] [let Result [let Parse_<symchar> [she
n-<symchar> V1010] [if [not [= [fail] Parse_<symchar>]] [let Parse_<symchars> [s
hen-<symchars> Parse_<symchar>] [if [not [= [fail] Parse_<symchars>]] [shen-reas
semble [fst Parse_<symchars>] [cn [snd Parse_<symchar>] [snd Parse_<symchars>]]]
 [fail]]] [fail]]] [if [= Result [fail]] [let Result [let Parse_<symchar> [shen-
<symchar> V1010] [if [not [= [fail] Parse_<symchar>]] [shen-reassemble [fst Pars
e_<symchar>] [snd Parse_<symchar>]] [fail]]] [if [= Result [fail]] [fail] Result
]] Result]]]

null



Evaluating: [defun shen-<symchar> [V1011] [let Result [let Parse_<alpha> [shen-<
alpha> V1011] [if [not [= [fail] Parse_<alpha>]] [shen-reassemble [fst Parse_<al
pha>] [snd Parse_<alpha>]] [fail]]] [if [= Result [fail]] [let Result [let Parse
_<digit->string> [shen-<digit->string> V1011] [if [not [= [fail] Parse_<digit->s
tring>]] [shen-reassemble [fst Parse_<digit->string>] [snd Parse_<digit->string>
]] [fail]]] [if [= Result [fail]] [fail] Result]] Result]]]

null



Evaluating: [defun shen-<digit->string> [V1012] [let Result [if [cons? [fst V101
2]] [shen-reassemble [fst [shen-reassemble [tl [fst V1012]] [snd V1012]]] [if [s
hen-digit-byte? [hd [fst V1012]]] [n->string [hd [fst V1012]]] [fail]]] [fail]]
[if [= Result [fail]] [fail] Result]]]

null



Evaluating: [defun shen-digit-byte? [V1017] [cond [[= 48 V1017] true] [[= 49 V10
17] true] [[= 50 V1017] true] [[= 51 V1017] true] [[= 52 V1017] true] [[= 53 V10
17] true] [[= 54 V1017] true] [[= 55 V1017] true] [[= 56 V1017] true] [[= 57 V10
17] true] [true false]]]

null



Evaluating: [defun shen-<alpha> [V1018] [let Result [if [cons? [fst V1018]] [she
n-reassemble [fst [shen-reassemble [tl [fst V1018]] [snd V1018]]] [let S [shen-s
ymbol-byte->string [hd [fst V1018]]] [if [= S [fail]] [fail] S]]] [fail]] [if [=
 Result [fail]] [fail] Result]]]

null



Evaluating: [defun shen-symbol-byte->string [V1019] [<-address [value shen-*symb
olcodes*] V1019]]

null



Evaluating: [defun shen-<str> [V1020] [let Result [let Parse_<dbq> [shen-<dbq> V
1020] [if [not [= [fail] Parse_<dbq>]] [let Parse_<strcontents> [shen-<strconten
ts> Parse_<dbq>] [if [not [= [fail] Parse_<strcontents>]] [let Parse_<dbq> [shen
-<dbq> Parse_<strcontents>] [if [not [= [fail] Parse_<dbq>]] [shen-reassemble [f
st Parse_<dbq>] [snd Parse_<strcontents>]] [fail]]] [fail]]] [fail]]] [if [= Res
ult [fail]] [fail] Result]]]

null



Evaluating: [defun shen-<dbq> [V1021] [let Result [if [cons? [fst V1021]] [shen-
reassemble [fst [shen-reassemble [tl [fst V1021]] [snd V1021]]] [if [= [hd [fst
V1021]] 34] shen-skip [fail]]] [fail]] [if [= Result [fail]] [fail] Result]]]

null



Evaluating: [defun shen-<strcontents> [V1022] [let Result [let Parse_<strc> [she
n-<strc> V1022] [if [not [= [fail] Parse_<strc>]] [let Parse_<strcontents> [shen
-<strcontents> Parse_<strc>] [if [not [= [fail] Parse_<strcontents>]] [shen-reas
semble [fst Parse_<strcontents>] [cons [snd Parse_<strc>] [snd Parse_<strcontent
s>]]] [fail]]] [fail]]] [if [= Result [fail]] [let Result [let Parse_<e> [<e> V1
022] [if [not [= [fail] Parse_<e>]] [shen-reassemble [fst Parse_<e>] []] [fail]]
] [if [= Result [fail]] [fail] Result]] Result]]]

null



Evaluating: [defun shen-<byte> [V1023] [let Result [if [cons? [fst V1023]] [shen
-reassemble [fst [shen-reassemble [tl [fst V1023]] [snd V1023]]] [n->string [hd
[fst V1023]]]] [fail]] [if [= Result [fail]] [fail] Result]]]

null



Evaluating: [defun shen-<strc> [V1024] [let Result [if [cons? [fst V1024]] [shen
-reassemble [fst [shen-reassemble [tl [fst V1024]] [snd V1024]]] [if [= [hd [fst
 V1024]] 34] [fail] [n->string [hd [fst V1024]]]]] [fail]] [if [= Result [fail]]
 [fail] Result]]]

null



Evaluating: [defun shen-<backslash> [V1025] [let Result [if [cons? [fst V1025]]
[shen-reassemble [fst [shen-reassemble [tl [fst V1025]] [snd V1025]]] [if [= [hd
 [fst V1025]] 92] shen-skip [fail]]] [fail]] [if [= Result [fail]] [fail] Result
]]]

null



Evaluating: [defun shen-<number> [V1026] [let Result [let Parse_<minus> [shen-<m
inus> V1026] [if [not [= [fail] Parse_<minus>]] [let Parse_<number> [shen-<numbe
r> Parse_<minus>] [if [not [= [fail] Parse_<number>]] [shen-reassemble [fst Pars
e_<number>] [- 0 [snd Parse_<number>]]] [fail]]] [fail]]] [if [= Result [fail]]
[let Result [let Parse_<plus> [shen-<plus> V1026] [if [not [= [fail] Parse_<plus
>]] [let Parse_<number> [shen-<number> Parse_<plus>] [if [not [= [fail] Parse_<n
umber>]] [shen-reassemble [fst Parse_<number>] [snd Parse_<number>]] [fail]]] [f
ail]]] [if [= Result [fail]] [let Result [let Parse_<predigits> [shen-<predigits
> V1026] [if [not [= [fail] Parse_<predigits>]] [let Parse_<stop> [shen-<stop> P
arse_<predigits>] [if [not [= [fail] Parse_<stop>]] [let Parse_<postdigits> [she
n-<postdigits> Parse_<stop>] [if [not [= [fail] Parse_<postdigits>]] [let Parse_
<E> [shen-<E> Parse_<postdigits>] [if [not [= [fail] Parse_<E>]] [let Parse_<log
10> [shen-<log10> Parse_<E>] [if [not [= [fail] Parse_<log10>]] [shen-reassemble
 [fst Parse_<log10>] [* [shen-expt 10 [snd Parse_<log10>]] [+ [shen-pre [reverse
 [snd Parse_<predigits>]] 0] [shen-post [snd Parse_<postdigits>] 1]]]] [fail]]]
[fail]]] [fail]]] [fail]]] [fail]]] [if [= Result [fail]] [let Result [let Parse
_<digits> [shen-<digits> V1026] [if [not [= [fail] Parse_<digits>]] [let Parse_<
E> [shen-<E> Parse_<digits>] [if [not [= [fail] Parse_<E>]] [let Parse_<log10> [
shen-<log10> Parse_<E>] [if [not [= [fail] Parse_<log10>]] [shen-reassemble [fst
 Parse_<log10>] [* [shen-expt 10 [snd Parse_<log10>]] [shen-pre [reverse [snd Pa
rse_<digits>]] 0]]] [fail]]] [fail]]] [fail]]] [if [= Result [fail]] [let Result
 [let Parse_<predigits> [shen-<predigits> V1026] [if [not [= [fail] Parse_<predi
gits>]] [let Parse_<stop> [shen-<stop> Parse_<predigits>] [if [not [= [fail] Par
se_<stop>]] [let Parse_<postdigits> [shen-<postdigits> Parse_<stop>] [if [not [=
 [fail] Parse_<postdigits>]] [shen-reassemble [fst Parse_<postdigits>] [+ [shen-
pre [reverse [snd Parse_<predigits>]] 0] [shen-post [snd Parse_<postdigits>] 1]]
] [fail]]] [fail]]] [fail]]] [if [= Result [fail]] [let Result [let Parse_<digit
s> [shen-<digits> V1026] [if [not [= [fail] Parse_<digits>]] [shen-reassemble [f
st Parse_<digits>] [shen-pre [reverse [snd Parse_<digits>]] 0]] [fail]]] [if [=
Result [fail]] [fail] Result]] Result]] Result]] Result]] Result]] Result]]]

null



Evaluating: [defun shen-<E> [V1027] [let Result [if [and [cons? [fst V1027]] [=
101 [hd [fst V1027]]]] [shen-reassemble [fst [shen-reassemble [tl [fst V1027]] [
snd V1027]]] [cons 101 []]] [fail]] [if [= Result [fail]] [fail] Result]]]

null



Evaluating: [defun shen-<log10> [V1028] [let Result [let Parse_<minus> [shen-<mi
nus> V1028] [if [not [= [fail] Parse_<minus>]] [let Parse_<digits> [shen-<digits
> Parse_<minus>] [if [not [= [fail] Parse_<digits>]] [shen-reassemble [fst Parse
_<digits>] [- 0 [shen-pre [reverse [snd Parse_<digits>]] 0]]] [fail]]] [fail]]]
[if [= Result [fail]] [let Result [let Parse_<digits> [shen-<digits> V1028] [if
[not [= [fail] Parse_<digits>]] [shen-reassemble [fst Parse_<digits>] [shen-pre
[reverse [snd Parse_<digits>]] 0]] [fail]]] [if [= Result [fail]] [fail] Result]
] Result]]]

null



Evaluating: [defun shen-<plus> [V1029] [let Result [if [cons? [fst V1029]] [shen
-reassemble [fst [shen-reassemble [tl [fst V1029]] [snd V1029]]] [if [= [hd [fst
 V1029]] 43] shen-skip [fail]]] [fail]] [if [= Result [fail]] [fail] Result]]]

null



Evaluating: [defun shen-<stop> [V1030] [let Result [if [cons? [fst V1030]] [shen
-reassemble [fst [shen-reassemble [tl [fst V1030]] [snd V1030]]] [if [= [hd [fst
 V1030]] 46] shen-skip [fail]]] [fail]] [if [= Result [fail]] [fail] Result]]]

null



Evaluating: [defun shen-<predigits> [V1031] [let Result [let Parse_<digits> [she
n-<digits> V1031] [if [not [= [fail] Parse_<digits>]] [shen-reassemble [fst Pars
e_<digits>] [snd Parse_<digits>]] [fail]]] [if [= Result [fail]] [let Result [le
t Parse_<e> [<e> V1031] [if [not [= [fail] Parse_<e>]] [shen-reassemble [fst Par
se_<e>] []] [fail]]] [if [= Result [fail]] [fail] Result]] Result]]]

null



Evaluating: [defun shen-<postdigits> [V1032] [let Result [let Parse_<digits> [sh
en-<digits> V1032] [if [not [= [fail] Parse_<digits>]] [shen-reassemble [fst Par
se_<digits>] [snd Parse_<digits>]] [fail]]] [if [= Result [fail]] [fail] Result]
]]

null



Evaluating: [defun shen-<digits> [V1033] [let Result [let Parse_<digit> [shen-<d
igit> V1033] [if [not [= [fail] Parse_<digit>]] [let Parse_<digits> [shen-<digit
s> Parse_<digit>] [if [not [= [fail] Parse_<digits>]] [shen-reassemble [fst Pars
e_<digits>] [cons [snd Parse_<digit>] [snd Parse_<digits>]]] [fail]]] [fail]]] [
if [= Result [fail]] [let Result [let Parse_<digit> [shen-<digit> V1033] [if [no
t [= [fail] Parse_<digit>]] [shen-reassemble [fst Parse_<digit>] [cons [snd Pars
e_<digit>] []]] [fail]]] [if [= Result [fail]] [fail] Result]] Result]]]

null



Evaluating: [defun shen-<digit> [V1034] [let Result [if [cons? [fst V1034]] [she
n-reassemble [fst [shen-reassemble [tl [fst V1034]] [snd V1034]]] [if [shen-digi
t-byte? [hd [fst V1034]]] [shen-byte->digit [hd [fst V1034]]] [fail]]] [fail]] [
if [= Result [fail]] [fail] Result]]]

null



Evaluating: [defun shen-byte->digit [V1035] [cond [[= 48 V1035] 0] [[= 49 V1035]
 1] [[= 50 V1035] 2] [[= 51 V1035] 3] [[= 52 V1035] 4] [[= 53 V1035] 5] [[= 54 V
1035] 6] [[= 55 V1035] 7] [[= 56 V1035] 8] [[= 57 V1035] 9] [true [shen-sys-erro
r shen-byte->digit]]]]

null



Evaluating: [defun shen-pre [V1038 V1039] [cond [[= [] V1038] 0] [[cons? V1038]
[+ [* [shen-expt 10 V1039] [hd V1038]] [shen-pre [tl V1038] [+ V1039 1]]]] [true
 [shen-sys-error shen-pre]]]]

null



Evaluating: [defun shen-post [V1042 V1043] [cond [[= [] V1042] 0] [[cons? V1042]
 [+ [* [shen-expt 10 [- 0 V1043]] [hd V1042]] [shen-post [tl V1042] [+ V1043 1]]
]] [true [shen-sys-error shen-post]]]]

null



Evaluating: [defun shen-expt [V1046 V1047] [cond [[= 0 V1047] 1] [[> V1047 0] [*
 V1046 [shen-expt V1046 [- V1047 1]]]] [true [* 1 [/ [shen-expt V1046 [+ V1047 1
]] V1046]]]]]

null



Evaluating: [defun shen-<st_input1> [V1048] [let Result [let Parse_<st_input> [s
hen-<st_input> V1048] [if [not [= [fail] Parse_<st_input>]] [shen-reassemble [fs
t Parse_<st_input>] [snd Parse_<st_input>]] [fail]]] [if [= Result [fail]] [fail
] Result]]]

null



Evaluating: [defun shen-<st_input2> [V1049] [let Result [let Parse_<st_input> [s
hen-<st_input> V1049] [if [not [= [fail] Parse_<st_input>]] [shen-reassemble [fs
t Parse_<st_input>] [snd Parse_<st_input>]] [fail]]] [if [= Result [fail]] [fail
] Result]]]

null



Evaluating: [defun shen-<comment> [V1050] [let Result [let Parse_<backslash> [sh
en-<backslash> V1050] [if [not [= [fail] Parse_<backslash>]] [let Parse_<times>
[shen-<times> Parse_<backslash>] [if [not [= [fail] Parse_<times>]] [let Parse_<
any> [shen-<any> Parse_<times>] [if [not [= [fail] Parse_<any>]] [let Parse_<tim
es> [shen-<times> Parse_<any>] [if [not [= [fail] Parse_<times>]] [let Parse_<ba
ckslash> [shen-<backslash> Parse_<times>] [if [not [= [fail] Parse_<backslash>]]
 [shen-reassemble [fst Parse_<backslash>] shen-skip] [fail]]] [fail]]] [fail]]]
[fail]]] [fail]]] [if [= Result [fail]] [fail] Result]]]

null



Evaluating: [defun shen-<times> [V1051] [let Result [if [cons? [fst V1051]] [she
n-reassemble [fst [shen-reassemble [tl [fst V1051]] [snd V1051]]] [if [= [hd [fs
t V1051]] 42] shen-skip [fail]]] [fail]] [if [= Result [fail]] [fail] Result]]]

null



Evaluating: [defun shen-<any> [V1052] [let Result [let Parse_<comment> [shen-<co
mment> V1052] [if [not [= [fail] Parse_<comment>]] [let Parse_<any> [shen-<any>
Parse_<comment>] [if [not [= [fail] Parse_<any>]] [shen-reassemble [fst Parse_<a
ny>] shen-skip] [fail]]] [fail]]] [if [= Result [fail]] [let Result [let Parse_<
blah> [shen-<blah> V1052] [if [not [= [fail] Parse_<blah>]] [let Parse_<any> [sh
en-<any> Parse_<blah>] [if [not [= [fail] Parse_<any>]] [shen-reassemble [fst Pa
rse_<any>] shen-skip] [fail]]] [fail]]] [if [= Result [fail]] [let Result [let P
arse_<e> [<e> V1052] [if [not [= [fail] Parse_<e>]] [shen-reassemble [fst Parse_
<e>] shen-skip] [fail]]] [if [= Result [fail]] [fail] Result]] Result]] Result]]
]

null



Evaluating: [defun shen-<blah> [V1053] [let Result [if [cons? [fst V1053]] [shen
-reassemble [fst [shen-reassemble [tl [fst V1053]] [snd V1053]]] [if [shen-end-o
f-comment? [fst V1053]] [fail] shen-skip]] [fail]] [if [= Result [fail]] [fail]
Result]]]

null



Evaluating: [defun shen-end-of-comment? [V1060] [cond [[and [cons? V1060] [and [
= 42 [hd V1060]] [and [cons? [tl V1060]] [= 92 [hd [tl V1060]]]]]] true] [true f
alse]]]

null



Evaluating: [defun shen-<whitespaces> [V1061] [let Result [let Parse_<whitespace
> [shen-<whitespace> V1061] [if [not [= [fail] Parse_<whitespace>]] [let Parse_<
whitespaces> [shen-<whitespaces> Parse_<whitespace>] [if [not [= [fail] Parse_<w
hitespaces>]] [shen-reassemble [fst Parse_<whitespaces>] shen-skip] [fail]]] [fa
il]]] [if [= Result [fail]] [let Result [let Parse_<whitespace> [shen-<whitespac
e> V1061] [if [not [= [fail] Parse_<whitespace>]] [shen-reassemble [fst Parse_<w
hitespace>] shen-skip] [fail]]] [if [= Result [fail]] [fail] Result]] Result]]]

null



Evaluating: [defun shen-<whitespace> [V1062] [let Result [if [cons? [fst V1062]]
 [shen-reassemble [fst [shen-reassemble [tl [fst V1062]] [snd V1062]]] [let Case
 [hd [fst V1062]] [if [= Case 32] shen-skip [if [= Case 13] shen-skip [if [= Cas
e 10] shen-skip [if [= Case 9] shen-skip [fail]]]]]]] [fail]] [if [= Result [fai
l]] [fail] Result]]]

null



Evaluating: [defun shen-cons_form [V1063] [cond [[= [] V1063] []] [[and [cons? V
1063] [and [cons? [tl V1063]] [and [= bar! [hd [tl V1063]]] [and [cons? [tl [tl
V1063]]] [= [] [tl [tl [tl V1063]]]]]]]] [cons cons [cons [hd V1063] [tl [tl V10
63]]]]] [[cons? V1063] [cons cons [cons [hd V1063] [cons [shen-cons_form [tl V10
63]] []]]]] [true [shen-sys-error shen-cons_form]]]]

null



Evaluating: [defun shen-package-macro [V1066 V1067] [cond [[and [cons? V1066] [a
nd [= $ [hd V1066]] [and [cons? [tl V1066]] [= [] [tl [tl V1066]]]]]] [append [e
xplode [hd [tl V1066]]] V1067]] [[and [cons? V1066] [and [= package [hd V1066]]
[and [cons? [tl V1066]] [and [= null [hd [tl V1066]]] [cons? [tl [tl V1066]]]]]]
] [append [tl [tl [tl V1066]]] V1067]] [[and [cons? V1066] [and [= package [hd V
1066]] [and [cons? [tl V1066]] [cons? [tl [tl V1066]]]]]] [let ListofExceptions
[shen-eval-without-macros [hd [tl [tl V1066]]]] [let Record [shen-record-excepti
ons ListofExceptions [hd [tl V1066]]] [append [shen-packageh [hd [tl V1066]] Lis
tofExceptions [tl [tl [tl V1066]]]] V1067]]]] [true [cons V1066 V1067]]]]

null



Evaluating: [defun shen-record-exceptions [V1068 V1069] [let CurrExceptions [tra
p-error [get V1069 shen-external-symbols [value shen-*property-vector*]] [lambda
 E []]] [let AllExceptions [union V1068 CurrExceptions] [put V1069 shen-external
-symbols AllExceptions [value shen-*property-vector*]]]]]

null



Evaluating: [defun shen-packageh [V1078 V1079 V1080] [cond [[cons? V1080] [cons
[shen-packageh V1078 V1079 [hd V1080]] [shen-packageh V1078 V1079 [tl V1080]]]]
[[or [shen-sysfunc? V1080] [or [variable? V1080] [or [element? V1080 V1079] [or
[shen-doubleunderline? V1080] [shen-singleunderline? V1080]]]]] V1080] [[and [sy
mbol? V1080] [not [shen-prefix? [cons s [cons h [cons e [cons n [cons - []]]]]]
[explode V1080]]]] [concat V1078 V1080]] [true V1080]]]

null



Evaluating:                                                    The License

 The user is free to produce commercial applications with the software, to distr
ibute these applications in source or binary  form, and to charge monies for the
m as he sees fit and in concordance with the laws of the land subject to the fol
lowing  license.

 1. The license applies to all the software and all derived software and must ap
pear on such.
 2. It is illegal to distribute the software without this license attached to it
 and use of the software implies agreement
    with the license as such. It is illegal for anyone who is not the copyright
holder to tamper with or change the license.
 3. Neither the names of Lambda Associates or the copyright holder may be used t
o endorse or promote products built using
     the software without specific prior written permission from the copyright h
older.
 4. That possession of this license does not confer on the copyright holder any
special contractual obligation towards the    user. That in no event shall the c
opyright holder be liable for any direct, indirect, incidental, special, exempla
ry or   consequential damages (including but not limited to procurement of subst
itute goods or services, loss of use, data, or    profits; or business interrupt
ion), however caused and on any theory of liability, whether in contract, strict
 liability   or tort (including negligence) arising in any way out of the use of
 the software, even if advised of the possibility of   such damage.
5. It is permitted for the user to change the software, for the purpose of impro
ving performance, correcting an error, or    porting to a new platform, and dist
ribute the modified version of Shen (hereafter the modified version) provided th
e     resulting program conforms in all respects to the Shen standard and is iss
ued under that title. The user must make it clear   with his distribution that h
e/she is the author of the changes and what these changes are and why.
6. Derived versions of this software in whatever form are subject to the same re
strictions. In particular it is not          permitted to make derived copies of
 this software which do not conform to the Shen standard or appear under a diffe
rent title.
7. It is permitted to distribute versions of Shen which incorporate libraries, g
raphics or other facilities which are not    part of the Shen standard.

For an explication of this license see http://www.lambdassociates.org/News/june1
1/license.htm which explains this license in full.

                                                   The License

 The user is free to produce comm




Evaluating: [defun shen-datatype-error [V1549] [interror datatype syntax error h
ere:

 ~A
 [@p [shen-next-50 50 V1549] []]]]

null



Evaluating: [defun shen-<datatype-rules> [V1550] [let Result [let Parse_<datatyp
e-rule> [shen-<datatype-rule> V1550] [if [not [= [fail] Parse_<datatype-rule>]]
[let Parse_<datatype-rules> [shen-<datatype-rules> Parse_<datatype-rule>] [if [n
ot [= [fail] Parse_<datatype-rules>]] [shen-reassemble [fst Parse_<datatype-rule
s>] [cons [snd Parse_<datatype-rule>] [snd Parse_<datatype-rules>]]] [fail]]] [f
ail]]] [if [= Result [fail]] [let Result [let Parse_<e> [<e> V1550] [if [not [=
[fail] Parse_<e>]] [shen-reassemble [fst Parse_<e>] []] [fail]]] [if [= Result [
fail]] [fail] Result]] Result]]]

null



Evaluating: [defun shen-<datatype-rule> [V1551] [let Result [let Parse_<side-con
ditions> [shen-<side-conditions> V1551] [if [not [= [fail] Parse_<side-condition
s>]] [let Parse_<premises> [shen-<premises> Parse_<side-conditions>] [if [not [=
 [fail] Parse_<premises>]] [let Parse_<singleunderline> [shen-<singleunderline>
Parse_<premises>] [if [not [= [fail] Parse_<singleunderline>]] [let Parse_<concl
usion> [shen-<conclusion> Parse_<singleunderline>] [if [not [= [fail] Parse_<con
clusion>]] [shen-reassemble [fst Parse_<conclusion>] [@p shen-single [cons [snd
Parse_<side-conditions>] [cons [snd Parse_<premises>] [cons [snd Parse_<conclusi
on>] []]]]]] [fail]]] [fail]]] [fail]]] [fail]]] [if [= Result [fail]] [let Resu
lt [let Parse_<side-conditions> [shen-<side-conditions> V1551] [if [not [= [fail
] Parse_<side-conditions>]] [let Parse_<premises> [shen-<premises> Parse_<side-c
onditions>] [if [not [= [fail] Parse_<premises>]] [let Parse_<doubleunderline> [
shen-<doubleunderline> Parse_<premises>] [if [not [= [fail] Parse_<doubleunderli
ne>]] [let Parse_<conclusion> [shen-<conclusion> Parse_<doubleunderline>] [if [n
ot [= [fail] Parse_<conclusion>]] [shen-reassemble [fst Parse_<conclusion>] [@p
shen-double [cons [snd Parse_<side-conditions>] [cons [snd Parse_<premises>] [co
ns [snd Parse_<conclusion>] []]]]]] [fail]]] [fail]]] [fail]]] [fail]]] [if [= R
esult [fail]] [fail] Result]] Result]]]

null



Evaluating: [defun shen-<side-conditions> [V1552] [let Result [let Parse_<side-c
ondition> [shen-<side-condition> V1552] [if [not [= [fail] Parse_<side-condition
>]] [let Parse_<side-conditions> [shen-<side-conditions> Parse_<side-condition>]
 [if [not [= [fail] Parse_<side-conditions>]] [shen-reassemble [fst Parse_<side-
conditions>] [cons [snd Parse_<side-condition>] [snd Parse_<side-conditions>]]]
[fail]]] [fail]]] [if [= Result [fail]] [let Result [let Parse_<e> [<e> V1552] [
if [not [= [fail] Parse_<e>]] [shen-reassemble [fst Parse_<e>] []] [fail]]] [if
[= Result [fail]] [fail] Result]] Result]]]

null



Evaluating: [defun shen-<side-condition> [V1553] [let Result [if [and [cons? [fs
t V1553]] [= if [hd [fst V1553]]]] [let Parse_<expr> [shen-<expr> [shen-reassemb
le [tl [fst V1553]] [snd V1553]]] [if [not [= [fail] Parse_<expr>]] [shen-reasse
mble [fst Parse_<expr>] [cons if [cons [snd Parse_<expr>] []]]] [fail]]] [fail]]
 [if [= Result [fail]] [let Result [if [and [cons? [fst V1553]] [= let [hd [fst
V1553]]]] [let Parse_<variable?> [shen-<variable?> [shen-reassemble [tl [fst V15
53]] [snd V1553]]] [if [not [= [fail] Parse_<variable?>]] [let Parse_<expr> [she
n-<expr> Parse_<variable?>] [if [not [= [fail] Parse_<expr>]] [shen-reassemble [
fst Parse_<expr>] [cons let [cons [snd Parse_<variable?>] [cons [snd Parse_<expr
>] []]]]] [fail]]] [fail]]] [fail]] [if [= Result [fail]] [fail] Result]] Result
]]]

null



Evaluating: [defun shen-<variable?> [V1554] [let Result [if [cons? [fst V1554]]
[shen-reassemble [fst [shen-reassemble [tl [fst V1554]] [snd V1554]]] [if [not [
variable? [hd [fst V1554]]]] [fail] [hd [fst V1554]]]] [fail]] [if [= Result [fa
il]] [fail] Result]]]

null



Evaluating: [defun shen-<expr> [V1555] [let Result [if [cons? [fst V1555]] [shen
-reassemble [fst [shen-reassemble [tl [fst V1555]] [snd V1555]]] [if [or [elemen
t? [hd [fst V1555]] [cons >> [cons ; []]]] [or [shen-singleunderline? [hd [fst V
1555]]] [shen-doubleunderline? [hd [fst V1555]]]]] [fail] [shen-remove-bar [hd [
fst V1555]]]]] [fail]] [if [= Result [fail]] [fail] Result]]]

null



Evaluating: [defun shen-remove-bar [V1556] [cond [[and [cons? V1556] [and [cons?
 [tl V1556]] [and [cons? [tl [tl V1556]]] [and [= [] [tl [tl [tl V1556]]]] [= [h
d [tl V1556]] bar!]]]]] [cons [hd V1556] [hd [tl [tl V1556]]]]] [[cons? V1556] [
cons [shen-remove-bar [hd V1556]] [shen-remove-bar [tl V1556]]]] [true V1556]]]

null



Evaluating: [defun shen-<premises> [V1557] [let Result [let Parse_<premise> [she
n-<premise> V1557] [if [not [= [fail] Parse_<premise>]] [let Parse_<semicolon-sy
mbol> [shen-<semicolon-symbol> Parse_<premise>] [if [not [= [fail] Parse_<semico
lon-symbol>]] [let Parse_<premises> [shen-<premises> Parse_<semicolon-symbol>] [
if [not [= [fail] Parse_<premises>]] [shen-reassemble [fst Parse_<premises>] [co
ns [snd Parse_<premise>] [snd Parse_<premises>]]] [fail]]] [fail]]] [fail]]] [if
 [= Result [fail]] [let Result [let Parse_<e> [<e> V1557] [if [not [= [fail] Par
se_<e>]] [shen-reassemble [fst Parse_<e>] []] [fail]]] [if [= Result [fail]] [fa
il] Result]] Result]]]

null



Evaluating: [defun shen-<semicolon-symbol> [V1558] [let Result [if [cons? [fst V
1558]] [shen-reassemble [fst [shen-reassemble [tl [fst V1558]] [snd V1558]]] [if
 [= [hd [fst V1558]] ;] shen-skip [fail]]] [fail]] [if [= Result [fail]] [fail]
Result]]]

null



Evaluating: [defun shen-<premise> [V1559] [let Result [if [and [cons? [fst V1559
]] [= ! [hd [fst V1559]]]] [shen-reassemble [fst [shen-reassemble [tl [fst V1559
]] [snd V1559]]] !] [fail]] [if [= Result [fail]] [let Result [let Parse_<formul
ae> [shen-<formulae> V1559] [if [not [= [fail] Parse_<formulae>]] [if [and [cons
? [fst Parse_<formulae>]] [= >> [hd [fst Parse_<formulae>]]]] [let Parse_<formul
a> [shen-<formula> [shen-reassemble [tl [fst Parse_<formulae>]] [snd Parse_<form
ulae>]]] [if [not [= [fail] Parse_<formula>]] [shen-reassemble [fst Parse_<formu
la>] [@p [snd Parse_<formulae>] [snd Parse_<formula>]]] [fail]]] [fail]] [fail]]
] [if [= Result [fail]] [let Result [let Parse_<formula> [shen-<formula> V1559]
[if [not [= [fail] Parse_<formula>]] [shen-reassemble [fst Parse_<formula>] [@p
[] [snd Parse_<formula>]]] [fail]]] [if [= Result [fail]] [fail] Result]] Result
]] Result]]]

null



Evaluating: [defun shen-<conclusion> [V1560] [let Result [let Parse_<formulae> [
shen-<formulae> V1560] [if [not [= [fail] Parse_<formulae>]] [if [and [cons? [fs
t Parse_<formulae>]] [= >> [hd [fst Parse_<formulae>]]]] [let Parse_<formula> [s
hen-<formula> [shen-reassemble [tl [fst Parse_<formulae>]] [snd Parse_<formulae>
]]] [if [not [= [fail] Parse_<formula>]] [let Parse_<semicolon-symbol> [shen-<se
micolon-symbol> Parse_<formula>] [if [not [= [fail] Parse_<semicolon-symbol>]] [
shen-reassemble [fst Parse_<semicolon-symbol>] [@p [snd Parse_<formulae>] [snd P
arse_<formula>]]] [fail]]] [fail]]] [fail]] [fail]]] [if [= Result [fail]] [let
Result [let Parse_<formula> [shen-<formula> V1560] [if [not [= [fail] Parse_<for
mula>]] [let Parse_<semicolon-symbol> [shen-<semicolon-symbol> Parse_<formula>]
[if [not [= [fail] Parse_<semicolon-symbol>]] [shen-reassemble [fst Parse_<semic
olon-symbol>] [@p [] [snd Parse_<formula>]]] [fail]]] [fail]]] [if [= Result [fa
il]] [fail] Result]] Result]]]

null



Evaluating: [defun shen-<formulae> [V1561] [let Result [let Parse_<formula> [she
n-<formula> V1561] [if [not [= [fail] Parse_<formula>]] [if [and [cons? [fst Par
se_<formula>]] [= shen- [hd [fst Parse_<formula>]]]] [let Parse_<formulae> [shen
-<formulae> [shen-reassemble [tl [fst Parse_<formula>]] [snd Parse_<formula>]]]
[if [not [= [fail] Parse_<formulae>]] [shen-reassemble [fst Parse_<formulae>] [c
ons [snd Parse_<formula>] [snd Parse_<formulae>]]] [fail]]] [fail]] [fail]]] [if
 [= Result [fail]] [let Result [let Parse_<formula> [shen-<formula> V1561] [if [
not [= [fail] Parse_<formula>]] [shen-reassemble [fst Parse_<formula>] [cons [sn
d Parse_<formula>] []]] [fail]]] [if [= Result [fail]] [let Result [let Parse_<e
> [<e> V1561] [if [not [= [fail] Parse_<e>]] [shen-reassemble [fst Parse_<e>] []
] [fail]]] [if [= Result [fail]] [fail] Result]] Result]] Result]]]

null



Evaluating: [defun shen-<formula> [V1562] [let Result [let Parse_<expr> [shen-<e
xpr> V1562] [if [not [= [fail] Parse_<expr>]] [if [and [cons? [fst Parse_<expr>]
] [= : [hd [fst Parse_<expr>]]]] [let Parse_<type> [shen-<type> [shen-reassemble
 [tl [fst Parse_<expr>]] [snd Parse_<expr>]]] [if [not [= [fail] Parse_<type>]]
[shen-reassemble [fst Parse_<type>] [cons [shen-curry [snd Parse_<expr>]] [cons
: [cons [shen-normalise-type [snd Parse_<type>]] []]]]] [fail]]] [fail]] [fail]]
] [if [= Result [fail]] [let Result [let Parse_<expr> [shen-<expr> V1562] [if [n
ot [= [fail] Parse_<expr>]] [shen-reassemble [fst Parse_<expr>] [snd Parse_<expr
>]] [fail]]] [if [= Result [fail]] [fail] Result]] Result]]]

null



Evaluating: [defun shen-<colonsymbol> [V1563] [let Result [if [cons? [fst V1563]
] [shen-reassemble [fst [shen-reassemble [tl [fst V1563]] [snd V1563]]] [if [= [
hd [fst V1563]] ;] [hd [fst V1563]] [fail]]] [fail]] [if [= Result [fail]] [fail
] Result]]]

null



Evaluating: [defun shen-<type> [V1564] [let Result [let Parse_<expr> [shen-<expr
> V1564] [if [not [= [fail] Parse_<expr>]] [shen-reassemble [fst Parse_<expr>] [
shen-curry-type [snd Parse_<expr>]]] [fail]]] [if [= Result [fail]] [fail] Resul
t]]]

null



Evaluating: [defun shen-<doubleunderline> [V1565] [let Result [if [cons? [fst V1
565]] [shen-reassemble [fst [shen-reassemble [tl [fst V1565]] [snd V1565]]] [if
[shen-doubleunderline? [hd [fst V1565]]] [hd [fst V1565]] [fail]]] [fail]] [if [
= Result [fail]] [fail] Result]]]

null



Evaluating: [defun shen-<singleunderline> [V1566] [let Result [if [cons? [fst V1
566]] [shen-reassemble [fst [shen-reassemble [tl [fst V1566]] [snd V1566]]] [if
[shen-singleunderline? [hd [fst V1566]]] [hd [fst V1566]] [fail]]] [fail]] [if [
= Result [fail]] [fail] Result]]]

null



Evaluating: [defun shen-singleunderline? [V1567] [and [symbol? V1567] [shen-sh?
[str V1567]]]]

null



Evaluating: [defun shen-sh? [V1568] [cond [[= _ V1568] true] [true [and [= [pos
V1568 0] _] [shen-sh? [tlstr V1568]]]]]]

null



Evaluating: [defun shen-doubleunderline? [V1569] [and [symbol? V1569] [shen-dh?
[str V1569]]]]

null



Evaluating: [defun shen-dh? [V1570] [cond [[= = V1570] true] [true [and [= [pos
V1570 0] =] [shen-dh? [tlstr V1570]]]]]]

null



Evaluating: [defun shen-process-datatype [V1571 V1572] [shen-remember-datatype [
shen-s-prolog [shen-rules->horn-clauses V1571 V1572]]]]

null



Evaluating: [defun shen-remember-datatype [V1577] [cond [[cons? V1577] [do [set
shen-*datatypes* [adjoin [hd V1577] [value shen-*datatypes*]]] [do [set shen-*al
ldatatypes* [adjoin [hd V1577] [value shen-*alldatatypes*]]] [hd V1577]]]] [true
 [shen-sys-error shen-remember-datatype]]]]

null



Evaluating: [defun shen-rules->horn-clauses [V1580 V1581] [cond [[= [] V1581] []
] [[and [cons? V1581] [and [tuple? [hd V1581]] [= shen-single [fst [hd V1581]]]]
] [cons [shen-rule->horn-clause V1580 [snd [hd V1581]]] [shen-rules->horn-clause
s V1580 [tl V1581]]]] [[and [cons? V1581] [and [tuple? [hd V1581]] [= shen-doubl
e [fst [hd V1581]]]]] [shen-rules->horn-clauses V1580 [append [shen-double->sing
les [snd [hd V1581]]] [tl V1581]]]] [true [shen-sys-error shen-rules->horn-claus
es]]]]

null



Evaluating: [defun shen-double->singles [V1582] [cons [shen-right-rule V1582] [c
ons [shen-left-rule V1582] []]]]

null



Evaluating: [defun shen-right-rule [V1583] [@p shen-single V1583]]

null



Evaluating: [defun shen-left-rule [V1584] [cond [[and [cons? V1584] [and [cons?
[tl V1584]] [and [cons? [tl [tl V1584]]] [and [tuple? [hd [tl [tl V1584]]]] [and
 [= [] [fst [hd [tl [tl V1584]]]]] [= [] [tl [tl [tl V1584]]]]]]]]] [let Q [gens
ym Qv] [let NewConclusion [@p [cons [snd [hd [tl [tl V1584]]]] []] Q] [let NewPr
emises [cons [@p [map [lambda V1585 [shen-right->left V1585]] [hd [tl V1584]]] Q
] []] [@p shen-single [cons [hd V1584] [cons NewPremises [cons NewConclusion []]
]]]]]]] [true [shen-sys-error shen-left-rule]]]]

null



Evaluating: [defun shen-right->left [V1590] [cond [[and [tuple? V1590] [= [] [fs
t V1590]]] [snd V1590]] [true [interror syntax error with ==========
 []]]]]

null



Evaluating: [defun shen-rule->horn-clause [V1591 V1592] [cond [[and [cons? V1592
] [and [cons? [tl V1592]] [and [cons? [tl [tl V1592]]] [and [tuple? [hd [tl [tl
V1592]]]] [= [] [tl [tl [tl V1592]]]]]]]] [cons [shen-rule->horn-clause-head V15
91 [snd [hd [tl [tl V1592]]]]] [cons :- [cons [shen-rule->horn-clause-body [hd V
1592] [hd [tl V1592]] [fst [hd [tl [tl V1592]]]]] []]]]] [true [shen-sys-error s
hen-rule->horn-clause]]]]

null



Evaluating: [defun shen-rule->horn-clause-head [V1593 V1594] [cons V1593 [cons [
shen-mode-ify V1594] [cons Context_1957 []]]]]

null



Evaluating: [defun shen-mode-ify [V1595] [cond [[and [cons? V1595] [and [cons? [
tl V1595]] [and [= : [hd [tl V1595]]] [and [cons? [tl [tl V1595]]] [= [] [tl [tl
 [tl V1595]]]]]]]] [cons mode [cons [cons [hd V1595] [cons : [cons [cons mode [c
ons [hd [tl [tl V1595]]] [cons + []]]] []]]] [cons - []]]]] [true V1595]]]

null



Evaluating: [defun shen-rule->horn-clause-body [V1596 V1597 V1598] [let Variable
s [map [lambda V1599 [shen-extract_vars V1599]] V1598] [let Predicates [map [lam
bda X [gensym shen-cl]] V1598] [let SearchLiterals [shen-construct-search-litera
ls Predicates Variables Context_1957 Context1_1957] [let SearchClauses [shen-con
struct-search-clauses Predicates V1598 Variables] [let SideLiterals [shen-constr
uct-side-literals V1596] [let PremissLiterals [map [lambda X [shen-construct-pre
miss-literal X [empty? V1598]]] V1597] [append SearchLiterals [append SideLitera
ls PremissLiterals]]]]]]]]]

null



Evaluating: [defun shen-construct-search-literals [V1604 V1605 V1606 V1607] [con
d [[and [= [] V1604] [= [] V1605]] []] [true [shen-csl-help V1604 V1605 V1606 V1
607]]]]

null



Evaluating: [defun shen-csl-help [V1610 V1611 V1612 V1613] [cond [[and [= [] V16
10] [= [] V1611]] [cons [cons bind [cons ContextOut_1957 [cons V1612 []]]] []]]
[[and [cons? V1610] [cons? V1611]] [cons [cons [hd V1610] [cons V1612 [cons V161
3 [hd V1611]]]] [shen-csl-help [tl V1610] [tl V1611] V1613 [gensym Context]]]] [
true [shen-sys-error shen-csl-help]]]]

null



Evaluating: [defun shen-construct-search-clauses [V1614 V1615 V1616] [cond [[and
 [= [] V1614] [and [= [] V1615] [= [] V1616]]] shen-skip] [[and [cons? V1614] [a
nd [cons? V1615] [cons? V1616]]] [do [shen-construct-search-clause [hd V1614] [h
d V1615] [hd V1616]] [shen-construct-search-clauses [tl V1614] [tl V1615] [tl V1
616]]]] [true [shen-sys-error shen-construct-search-clauses]]]]

null



Evaluating: [defun shen-construct-search-clause [V1617 V1618 V1619] [shen-s-prol
og [cons [shen-construct-base-search-clause V1617 V1618 V1619] [cons [shen-const
ruct-recursive-search-clause V1617 V1618 V1619] []]]]]

null



Evaluating: [defun shen-construct-base-search-clause [V1620 V1621 V1622] [cons [
cons V1620 [cons [cons [shen-mode-ify V1621] In_1957] [cons In_1957 V1622]]] [co
ns :- [cons [] []]]]]

null



Evaluating: [defun shen-construct-recursive-search-clause [V1623 V1624 V1625] [c
ons [cons V1623 [cons [cons Assumption_1957 Assumptions_1957] [cons [cons Assump
tion_1957 Out_1957] V1625]]] [cons :- [cons [cons [cons V1623 [cons Assumptions_
1957 [cons Out_1957 V1625]]] []] []]]]]

null



Evaluating: [defun shen-construct-side-literals [V1630] [cond [[= [] V1630] []]
[[and [cons? V1630] [and [cons? [hd V1630]] [and [= if [hd [hd V1630]]] [and [co
ns? [tl [hd V1630]]] [= [] [tl [tl [hd V1630]]]]]]]] [cons [cons when [tl [hd V1
630]]] [shen-construct-side-literals [tl V1630]]]] [[and [cons? V1630] [and [con
s? [hd V1630]] [and [= let [hd [hd V1630]]] [and [cons? [tl [hd V1630]]] [and [c
ons? [tl [tl [hd V1630]]]] [= [] [tl [tl [tl [hd V1630]]]]]]]]]] [cons [cons is
[tl [hd V1630]]] [shen-construct-side-literals [tl V1630]]]] [[cons? V1630] [she
n-construct-side-literals [tl V1630]]] [true [shen-sys-error shen-construct-side
-literals]]]]

null



Evaluating: [defun shen-construct-premiss-literal [V1635 V1636] [cond [[tuple? V
1635] [cons shen-t* [cons [shen-recursive_cons_form [snd V1635]] [cons [shen-con
struct-context V1636 [fst V1635]] []]]]] [[= ! V1635] [cons cut [cons Throwcontr
ol []]]] [true [shen-sys-error shen-construct-premiss-literal]]]]

null



Evaluating: [defun shen-construct-context [V1637 V1638] [cond [[and [= true V163
7] [= [] V1638]] Context_1957] [[and [= false V1637] [= [] V1638]] ContextOut_19
57] [[cons? V1638] [cons cons [cons [shen-recursive_cons_form [hd V1638]] [cons
[shen-construct-context V1637 [tl V1638]] []]]]] [true [shen-sys-error shen-cons
truct-context]]]]

null



Evaluating: [defun shen-recursive_cons_form [V1639] [cond [[cons? V1639] [cons c
ons [cons [shen-recursive_cons_form [hd V1639]] [cons [shen-recursive_cons_form
[tl V1639]] []]]]] [true V1639]]]

null



Evaluating: [defun preclude [V1640] [let FilterDatatypes [set shen-*datatypes* [
difference [value shen-*datatypes*] V1640]] [value shen-*datatypes*]]]

null



Evaluating: [defun include [V1641] [let ValidTypes [intersection V1641 [value sh
en-*alldatatypes*]] [let NewDatatypes [set shen-*datatypes* [union ValidTypes [v
alue shen-*datatypes*]]] [value shen-*datatypes*]]]]

null



Evaluating: [defun preclude-all-but [V1642] [preclude [difference [value shen-*a
lldatatypes*] V1642]]]

null



Evaluating: [defun include-all-but [V1643] [include [difference [value shen-*all
datatypes*] V1643]]]

null



Evaluating: [defun shen-synonyms-help [V1648] [cond [[= [] V1648] synonyms] [[an
d [cons? V1648] [cons? [tl V1648]]] [do [shen-pushnew [cons [hd V1648] [hd [tl V
1648]]] shen-*synonyms*] [shen-synonyms-help [tl [tl V1648]]]]] [true [interror
odd number of synonyms
 [@p [] []]]]]]

null



Evaluating: [defun shen-pushnew [V1649 V1650] [if [element? V1649 [value V1650]]
 [value V1650] [set V1650 [cons V1649 [value V1650]]]]]

null



Evaluating:                                                    The License



 The user is free to produce commercial applications with the software, to distr
ibute these applications in source or binary  form, and to charge monies for the
m as he sees fit and in concordance with the laws of the land subject to the fol
lowing  license.



 1. The license applies to all the software and all derived software and must ap
pear on such.

 2. It is illegal to distribute the software without this license attached to it
 and use of the software implies agreement

    with the license as such. It is illegal for anyone who is not the copyright
holder to tamper with or change the license.

 3. Neither the names of Lambda Associates or the copyright holder may be used t
o endorse or promote products built using

     the software without specific prior written permission from the copyright h
older.

 4. That possession of this license does not confer on the copyright holder any
special contractual obligation towards the    user. That in no event shall the c
opyright holder be liable for any direct, indirect, incidental, special, exempla
ry or   consequential damages (including but not limited to procurement of subst
itute goods or services, loss of use, data, or    profits; or business interrupt
ion), however caused and on any theory of liability, whether in contract, strict
 liability   or tort (including negligence) arising in any way out of the use of
 the software, even if advised of the possibility of   such damage.

5. It is permitted for the user to change the software, for the purpose of impro
ving performance, correcting an error, or    porting to a new platform, and dist
ribute the modified version of Shen (hereafter the modified version) provided th
e     resulting program conforms in all respects to the Shen standard and is iss
ued under that title. The user must it clear   with his distribution that he/she
 is the author of the changes and what these changes are and why.

6. Derived versions of this software in whatever form are subject to the same re
strictions. In particular it is not          permitted to make derived copies of
 this software which do not conform to the Shen standard or appear under a diffe
rent title.

7. It is permitted to distribute versions of Shen which incorporate libraries, g
raphics or other facilities which are not    part of the Shen standard.



For an explication of this license see http://www.lambdassociates.org/News/june1
1/license.htm which explains this license in full.

                                                   The License



 The user is free to produce




Evaluating: [defun shen-typecheck [V761 V762] [let Curry [shen-curry V761] [let
ProcessN [shen-start-new-prolog-process] [let Type [shen-insert-prolog-variables
 [shen-normalise-type [shen-curry-type V762]] ProcessN] [let Continuation [freez
e [return Type ProcessN shen-void]] [shen-th* Curry Type [] ProcessN Continuatio
n]]]]]]

null



Evaluating: [defun shen-curry [V763] [cond [[and [cons? V763] [shen-special? [hd
 V763]]] [cons [hd V763] [map [lambda X [shen-curry X]] [tl V763]]]] [[and [cons
? V763] [and [cons? [tl V763]] [shen-extraspecial? [hd V763]]]] V763] [[and [con
s? V763] [and [cons? [tl V763]] [cons? [tl [tl V763]]]]] [shen-curry [cons [cons
 [hd V763] [cons [hd [tl V763]] []]] [tl [tl V763]]]]] [[and [cons? V763] [and [
cons? [tl V763]] [= [] [tl [tl V763]]]]] [cons [shen-curry [hd V763]] [cons [she
n-curry [hd [tl V763]]] []]]] [true V763]]]

null



Evaluating: [defun shen-special? [V764] [element? V764 [value shen-*special*]]]

null



Evaluating: [defun shen-extraspecial? [V765] [element? V765 [value shen-*extrasp
ecial*]]]

null



Evaluating: [defun shen-t* [V550 V551 V552 V553] [let Throwcontrol [shen-catchpo
int] [shen-cutpoint Throwcontrol [let Case [let Error [shen-newpv V552] [do [she
n-incinfs] [fwhen [shen-maxinfexceeded?] V552 [freeze [bind Error [shen-errormax
infs] V552 V553]]]]] [if [= Case false] [let Case [let V544 [shen-lazyderef V550
 V552] [if [= fail V544] [do [shen-incinfs] [cut Throwcontrol V552 [freeze [shen
-prolog-failure V552 V553]]]] false]] [if [= Case false] [let Case [let V545 [sh
en-lazyderef V550 V552] [if [cons? V545] [let X [hd V545] [let V546 [shen-lazyde
ref [tl V545] V552] [if [cons? V546] [let V547 [shen-lazyderef [hd V546] V552] [
if [= : V547] [let V548 [shen-lazyderef [tl V546] V552] [if [cons? V548] [let A
[hd V548] [let V549 [shen-lazyderef [tl V548] V552] [if [= [] V549] [do [shen-in
cinfs] [cut Throwcontrol V552 [freeze [shen-th* X A V551 V552 V553]]]] false]]]
false]] false]] false]]] false]] [if [= Case false] [let Hyps [shen-newpv V552]
[let Datatypes [shen-newpv V552] [do [shen-incinfs] [shen-show V550 Hyps V552 [f
reeze [bind Datatypes [value shen-*datatypes*] V552 [freeze [shen-udefs* V550 V5
51 Datatypes V552 V553]]]]]]]] Case]] Case]] Case]]]]]

null



Evaluating: [defun shen-prolog-failure [V584 V585] false]

null



Evaluating: [defun shen-maxinfexceeded? [] [> [inferences shen-skip] [value shen
-*maxinferences*]]]

null



Evaluating: [defun shen-errormaxinfs [] [simple-error maximum inferences exceede
d
]]

null



Evaluating: [defun shen-udefs* [V773 V774 V775 V776 V777] [let Case [let V749 [s
hen-lazyderef V775 V776] [if [cons? V749] [let D [hd V749] [do [shen-incinfs] [c
all [cons D [cons V773 [cons V774 []]]] V776 V777]]] false]] [if [= Case false]
[let V750 [shen-lazyderef V775 V776] [if [cons? V750] [let Ds [tl V750] [do [she
n-incinfs] [shen-udefs* V773 V774 Ds V776 V777]]] false]] Case]]]

null

*** - Program stack overflow. RESET
[1]> (kl-file-to-java "kl/toplevel.kl")



Evaluating:                                                    The License

 The user is free to produce commercial applications with the software, to distr
ibute these applications in source or binary  form, and to charge monies for the
m as he sees fit and in concordance with the laws of the land subject to the fol
lowing  license.

 1. The license applies to all the software and all derived software and must ap
pear on such.
 2. It is illegal to distribute the software without this license attached to it
 and use of the software implies agreement
    with the license as such. It is illegal for anyone who is not the copyright
holder to tamper with or change the license.
 3. Neither the names of Lambda Associates or the copyright holder may be used t
o endorse or promote products built using
     the software without specific prior written permission from the copyright h
older.
 4. That possession of this license does not confer on the copyright holder any
special contractual obligation towards the    user. That in no event shall the c
opyright holder be liable for any direct, indirect, incidental, special, exempla
ry or   consequential damages (including but not limited to procurement of subst
itute goods or services, loss of use, data, or    profits; or business interrupt
ion), however caused and on any theory of liability, whether in contract, strict
 liability   or tort (including negligence) arising in any way out of the use of
 the software, even if advised of the possibility of   such damage.
5. It is permitted for the user to change the software, for the purpose of impro
ving performance, correcting an error, or    porting to a new platform, and dist
ribute the modified version of Shen (hereafter the modified version) provided th
e     resulting program conforms in all respects to the Shen standard and is iss
ued under that title. The user must make it clear   with his distribution that h
e/she is the author of the changes and what these changes are and why.
6. Derived versions of this software in whatever form are subject to the same re
strictions. In particular it is not          permitted to make derived copies of
 this software which do not conform to the Shen standard or appear under a diffe
rent title.
7. It is permitted to distribute versions of Shen which incorporate libraries, g
raphics or other facilities which are not    part of the Shen standard.

For an explication of this license see http://www.lambdassociates.org/News/june1
1/license.htm which explains this license in full.

                                                   The License

 The user is free to produce comm




Evaluating: [defun shen-shen [] [do [shen-credits] [shen-loop]]]

null



Evaluating: [defun shen-loop [] [do [shen-initialise_environment] [do [shen-prom
pt] [do [trap-error [shen-read-evaluate-print] [lambda E [pr [error-to-string E]
 [value *stoutput*]]]] [shen-loop]]]]]

null



Evaluating: [defun version [V568] [set *version* V568]]

null



Evaluating: [version version 6.1]

version 6.1



Evaluating: [defun shen-credits [] [do [intoutput
Shen 2010, copyright (C) 2010 Mark Tarver
 []] [do [intoutput www.shenlanguage.org, ~A
 [@p [value *version*] []]] [do [intoutput running under ~A, implementation: ~A
[@p [value *language*] [@p [value *implementation*] []]]] [intoutput
port ~A ported by ~A
 [@p [value *port*] [@p [value *porters*] []]]]]]]]

null



Evaluating: [defun shen-initialise_environment [] [shen-multiple-set [cons shen-
*call* [cons 0 [cons shen-*infs* [cons 0 [cons shen-*process-counter* [cons 0 [c
ons shen-*catch* [cons 0 []]]]]]]]]]]

null



Evaluating: [defun shen-multiple-set [V569] [cond [[= [] V569] []] [[and [cons?
V569] [cons? [tl V569]]] [do [set [hd V569] [hd [tl V569]]] [shen-multiple-set [
tl [tl V569]]]]] [true [shen-sys-error shen-multiple-set]]]]

null



Evaluating: [defun destroy [V570] [declare V570 []]]

null



Evaluating: [set shen-*history* []]

()



Evaluating: [defun shen-read-evaluate-print [] [let Lineread [shen-toplineread]
[let History [value shen-*history*] [let NewLineread [shen-retrieve-from-history
-if-needed Lineread History] [let NewHistory [shen-update_history NewLineread Hi
story] [let Parsed [fst NewLineread] [shen-toplevel Parsed]]]]]]]

null



Evaluating: [defun shen-retrieve-from-history-if-needed [V580 V581] [cond [[and
[tuple? V580] [and [cons? [snd V580]] [and [cons? [tl [snd V580]]] [and [= [] [t
l [tl [snd V580]]]] [and [cons? V581] [and [= [hd [snd V580]] [shen-exclamation]
] [= [hd [tl [snd V580]]] [shen-exclamation]]]]]]]] [let PastPrint [shen-prbytes
 [snd [hd V581]]] [hd V581]]] [[and [tuple? V580] [and [cons? [snd V580]] [= [hd
 [snd V580]] [shen-exclamation]]]] [let Key? [shen-make-key [tl [snd V580]] V581
] [let Find [head [shen-find-past-inputs Key? V581]] [let PastPrint [shen-prbyte
s [snd Find]] Find]]]] [[and [tuple? V580] [and [cons? [snd V580]] [and [= [] [t
l [snd V580]]] [= [hd [snd V580]] [shen-percent]]]]] [do [shen-print-past-inputs
 [lambda X true] [reverse V581] 0] [abort]]] [[and [tuple? V580] [and [cons? [sn
d V580]] [= [hd [snd V580]] [shen-percent]]]] [let Key? [shen-make-key [tl [snd
V580]] V581] [let Pastprint [shen-print-past-inputs Key? [reverse V581] 0] [abor
t]]]] [true V580]]]

null



Evaluating: [defun shen-percent [] 37]

null



Evaluating: [defun shen-exclamation [] 33]

null



Evaluating: [defun shen-prbytes [V582] [do [map [lambda Byte [pr [n->string Byte
] [stinput 0]]] V582] [nl 1]]]

null



Evaluating: [defun shen-update_history [V583 V584] [set shen-*history* [cons V58
3 V584]]]

null



Evaluating: [defun shen-toplineread [] [shen-toplineread_loop [read-byte [stinpu
t 0]] []]]

null



Evaluating: [defun shen-toplineread_loop [V586 V587] [cond [[= V586 [shen-hat]]
[interror line read aborted []]] [[element? V586 [cons [shen-newline] [cons [she
n-carriage-return] []]]] [let Line [compile [lambda V588 [shen-<st_input> V588]]
 V587 []] [if [or [= Line [fail]] [empty? Line]] [shen-toplineread_loop [read-by
te [stinput 0]] [append V587 [cons V586 []]]] [@p Line V587]]]] [true [shen-topl
ineread_loop [read-byte [stinput 0]] [append V587 [cons V586 []]]]]]]

null



Evaluating: [defun shen-hat [] 94]

null



Evaluating: [defun shen-newline [] 10]

null



Evaluating: [defun shen-carriage-return [] 13]

null



Evaluating: [defun tc [V593] [cond [[= + V593] [set shen-*tc* true]] [[= - V593]
 [set shen-*tc* false]] [true [interror tc expects a + or - []]]]]

null



Evaluating: [defun shen-prompt [] [if [value shen-*tc*] [intoutput

(~A+)  [@p [length [value shen-*history*]] []]] [intoutput

(~A-)  [@p [length [value shen-*history*]] []]]]]

null



Evaluating: [defun shen-toplevel [V594] [shen-toplevel_evaluate V594 [value shen
-*tc*]]]

null



Evaluating: [defun shen-find-past-inputs [V595 V596] [let F [shen-find V595 V596
] [if [empty? F] [interror input not found
 []] F]]]

null



Evaluating: [defun shen-make-key [V597 V598] [let Atom [hd [compile [lambda V599
 [shen-<st_input> V599]] V597 []]] [if [integer? Atom] [lambda X [= X [nth [+ At
om 1] [reverse V598]]]] [lambda X [shen-prefix? V597 [shen-trim-gubbins [snd X]]
]]]]]

null



Evaluating: [defun shen-trim-gubbins [V600] [cond [[and [cons? V600] [= [hd V600
] [shen-space]]] [shen-trim-gubbins [tl V600]]] [[and [cons? V600] [= [hd V600]
[shen-newline]]] [shen-trim-gubbins [tl V600]]] [[and [cons? V600] [= [hd V600]
[shen-carriage-return]]] [shen-trim-gubbins [tl V600]]] [[and [cons? V600] [= [h
d V600] [shen-tab]]] [shen-trim-gubbins [tl V600]]] [[and [cons? V600] [= [hd V6
00] [shen-left-round]]] [shen-trim-gubbins [tl V600]]] [true V600]]]

null



Evaluating: [defun shen-space [] 32]

null



Evaluating: [defun shen-tab [] 9]

null



Evaluating: [defun shen-left-round [] 40]

null



Evaluating: [defun shen-find [V607 V608] [cond [[= [] V608] []] [[and [cons? V60
8] [V607 [hd V608]]] [cons [hd V608] [shen-find V607 [tl V608]]]] [[cons? V608]
[shen-find V607 [tl V608]]] [true [shen-sys-error shen-find]]]]

null



Evaluating: [defun shen-prefix? [V619 V620] [cond [[= [] V619] true] [[and [cons
? V619] [and [cons? V620] [= [hd V620] [hd V619]]]] [shen-prefix? [tl V619] [tl
V620]]] [true false]]]

null



Evaluating: [defun shen-print-past-inputs [V630 V631 V632] [cond [[= [] V631] _]
 [[and [cons? V631] [not [V630 [hd V631]]]] [shen-print-past-inputs V630 [tl V63
1] [+ V632 1]]] [[and [cons? V631] [tuple? [hd V631]]] [do [intoutput ~A.  [@p V
632 []]] [do [shen-prbytes [snd [hd V631]]] [shen-print-past-inputs V630 [tl V63
1] [+ V632 1]]]]] [true [shen-sys-error shen-print-past-inputs]]]]

null



Evaluating: [defun shen-toplevel_evaluate [V633 V634] [cond [[and [cons? V633] [
and [cons? [tl V633]] [and [= : [hd [tl V633]]] [and [cons? [tl [tl V633]]] [and
 [= [] [tl [tl [tl V633]]]] [= true V634]]]]]] [shen-typecheck-and-evaluate [hd
V633] [hd [tl [tl V633]]]]] [[and [cons? V633] [cons? [tl V633]]] [do [shen-topl
evel_evaluate [cons [hd V633] []] V634] [do [nl 1] [shen-toplevel_evaluate [tl V
633] V634]]]] [[and [cons? V633] [and [= [] [tl V633]] [= true V634]]] [shen-typ
echeck-and-evaluate [hd V633] [gensym A]]] [[and [cons? V633] [and [= [] [tl V63
3]] [= false V634]]] [let Eval [shen-eval-without-macros [hd V633]] [print Eval]
]] [true [shen-sys-error shen-toplevel_evaluate]]]]

null



Evaluating: [defun shen-typecheck-and-evaluate [V635 V636] [let Typecheck [shen-
typecheck V635 V636] [if [= Typecheck false] [interror type error
 []] [let Eval [shen-eval-without-macros V635] [let Type [shen-pretty-type Typec
heck] [intoutput ~S : ~R [@p Eval [@p Type []]]]]]]]]

null



Evaluating: [defun shen-pretty-type [V637] [shen-mult_subst [value shen-*alphabe
t*] [shen-extract-pvars V637] V637]]

null



Evaluating: [defun shen-extract-pvars [V642] [cond [[shen-pvar? V642] [cons V642
 []]] [[cons? V642] [union [shen-extract-pvars [hd V642]] [shen-extract-pvars [t
l V642]]]] [true []]]]

null



Evaluating: [defun shen-mult_subst [V647 V648 V649] [cond [[= [] V647] V649] [[=
 [] V648] V649] [[and [cons? V647] [cons? V648]] [shen-mult_subst [tl V647] [tl
V648] [subst [hd V647] [hd V648] V649]]] [true [shen-sys-error shen-mult_subst]]
]]

null
("                                                   The License

 The user is free to produce comm

"
 "null
"
 "null
"
 "null
"
 "version 6.1
"
 "null
"
 "null
"
 "null
"
 "null
"
 "()
"
 "null
"
 "null
"
 "null
"
 "null
"
 "null
"
 "null
"
 "null
"
 "null
"
 "null
"
 "null
"
 "null
"
 "null
"
 "null
"
 "null
"
 "null
"
 "null
"
 "null
"
 "null
"
 "null
"
 "null
"
 "null
"
 "null
"
 "null
"
 "null
"
 "null
"
 "null
"
 "null
"
 "null
")
[2]> (kl-file-to-java "kl/track.kl")



Evaluating:                                                    The License

 The user is free to produce commercial applications with the software, to distr
ibute these applications in source or binary  form, and to charge monies for the
m as he sees fit and in concordance with the laws of the land subject to the fol
lowing  license.

 1. The license applies to all the software and all derived software and must ap
pear on such.
 2. It is illegal to distribute the software without this license attached to it
 and use of the software implies agreement
    with the license as such. It is illegal for anyone who is not the copyright
holder to tamper with or change the license.
 3. Neither the names of Lambda Associates or the copyright holder may be used t
o endorse or promote products built using
     the software without specific prior written permission from the copyright h
older.
 4. That possession of this license does not confer on the copyright holder any
special contractual obligation towards the    user. That in no event shall the c
opyright holder be liable for any direct, indirect, incidental, special, exempla
ry or   consequential damages (including but not limited to procurement of subst
itute goods or services, loss of use, data, or    profits; or business interrupt
ion), however caused and on any theory of liability, whether in contract, strict
 liability   or tort (including negligence) arising in any way out of the use of
 the software, even if advised of the possibility of   such damage.
5. It is permitted for the user to change the software, for the purpose of impro
ving performance, correcting an error, or    porting to a new platform, and dist
ribute the modified version of Shen (hereafter the modified version) provided th
e     resulting program conforms in all respects to the Shen standard and is iss
ued under that title. The user must make it clear   with his distribution that h
e/she is the author of the changes and what these changes are and why.
6. Derived versions of this software in whatever form are subject to the same re
strictions. In particular it is not          permitted to make derived copies of
 this software which do not conform to the Shen standard or appear under a diffe
rent title.
7. It is permitted to distribute versions of Shen which incorporate libraries, g
raphics or other facilities which are not    part of the Shen standard.

For an explication of this license see http://www.lambdassociates.org/News/june1
1/license.htm which explains this license in full.

                                                   The License

 The user is free to produce comm




Evaluating: [defun shen-f_error [V1123] [do [intoutput partial function ~A;
 [@p V1123 []]] [do [if [and [not [shen-tracked? V1123]] [y-or-n? [intmake-strin
g track ~A?  [@p V1123 []]]]] [shen-track-function [ps V1123]] shen-ok] [simple-
error aborted]]]]

null



Evaluating: [defun shen-tracked? [V1124] [element? V1124 [value shen-*tracking*]
]]

null



Evaluating: [defun track [V1125] [let Source [ps V1125] [shen-track-function Sou
rce]]]

null



Evaluating: [defun shen-track-function [V1126] [cond [[and [cons? V1126] [and [=
 defun [hd V1126]] [and [cons? [tl V1126]] [and [cons? [tl [tl V1126]]] [and [co
ns? [tl [tl [tl V1126]]]] [= [] [tl [tl [tl [tl V1126]]]]]]]]]] [let KL [cons de
fun [cons [hd [tl V1126]] [cons [hd [tl [tl V1126]]] [cons [shen-insert-tracking
-code [hd [tl V1126]] [hd [tl [tl V1126]]] [hd [tl [tl [tl V1126]]]]] []]]]] [le
t Ob [eval KL] [let Tr [set shen-*tracking* [cons Ob [value shen-*tracking*]]] O
b]]]] [true [shen-sys-error shen-track-function]]]]

null



Evaluating: [defun shen-insert-tracking-code [V1127 V1128 V1129] [cons do [cons
[cons set [cons shen-*call* [cons [cons + [cons [cons value [cons shen-*call* []
]] [cons 1 []]]] []]]] [cons [cons do [cons [cons shen-input-track [cons [cons v
alue [cons shen-*call* []]] [cons V1127 [cons [shen-cons_form V1128] []]]]] [con
s [cons do [cons [cons shen-terpri-or-read-char []] [cons [cons let [cons Result
 [cons V1129 [cons [cons do [cons [cons shen-output-track [cons [cons value [con
s shen-*call* []]] [cons V1127 [cons Result []]]]] [cons [cons do [cons [cons se
t [cons shen-*call* [cons [cons - [cons [cons value [cons shen-*call* []]] [cons
 1 []]]] []]]] [cons [cons do [cons [cons shen-terpri-or-read-char []] [cons Res
ult []]]] []]]] []]]] []]]]] []]]] []]]] []]]]]

null



Evaluating: [set shen-*step* false]

false



Evaluating: [defun step [V1134] [cond [[= + V1134] [set shen-*step* true]] [[= -
 V1134] [set shen-*step* false]] [true [interror step expects a + or a -.
 []]]]]

null



Evaluating: [defun spy [V1139] [cond [[= + V1139] [set shen-*spy* true]] [[= - V
1139] [set shen-*spy* false]] [true [interror spy expects a + or a -.
 []]]]]

null



Evaluating: [defun shen-terpri-or-read-char [] [if [value shen-*step*] [shen-che
ck-byte [read-byte [value *stinput*]]] [nl 1]]]

null



Evaluating: [defun shen-check-byte [V1144] [cond [[= V1144 [shen-hat]] [interror
 aborted []]] [true true]]]

null



Evaluating: [defun shen-input-track [V1145 V1146 V1147] [do [intoutput
~A<~A> Inputs to ~A
~A [@p [shen-spaces V1145] [@p V1145 [@p V1146 [@p [shen-spaces V1145] [@p V1147
 []]]]]]] [shen-recursively-print V1147]]]

null



Evaluating: [defun shen-recursively-print [V1148] [cond [[= [] V1148] [intoutput
  ==> []]] [[cons? V1148] [do [print [hd V1148]] [do [intoutput ,  []] [shen-rec
ursively-print [tl V1148]]]]] [true [shen-sys-error shen-recursively-print]]]]

null



Evaluating: [defun shen-spaces [V1149] [cond [[= 0 V1149] ] [true [cn   [shen-sp
aces [- V1149 1]]]]]]

null



Evaluating: [defun shen-output-track [V1150 V1151 V1152] [intoutput
~A<~A> Output from ~A
~A==> ~S [@p [shen-spaces V1150] [@p V1150 [@p V1151 [@p [shen-spaces V1150] [@p
 V1152 []]]]]]]]

null



Evaluating: [defun untrack [V1153] [eval [ps V1153]]]

null



Evaluating: [defun profile [V1154] [shen-profile-help [ps V1154]]]

null



Evaluating: [defun shen-profile-help [V1159] [cond [[and [cons? V1159] [and [= d
efun [hd V1159]] [and [cons? [tl V1159]] [and [cons? [tl [tl V1159]]] [and [cons
? [tl [tl [tl V1159]]]] [= [] [tl [tl [tl [tl V1159]]]]]]]]]] [let G [gensym she
n-f] [let Profile [cons defun [cons [hd [tl V1159]] [cons [hd [tl [tl V1159]]] [
cons [shen-profile-func [hd [tl V1159]] [hd [tl [tl V1159]]] [cons G [hd [tl [tl
 V1159]]]]] []]]]] [let Def [cons defun [cons G [cons [hd [tl [tl V1159]]] [cons
 [subst G [hd [tl V1159]] [hd [tl [tl [tl V1159]]]]] []]]]] [let CompileProfile
[shen-eval-without-macros Profile] [let CompileG [shen-eval-without-macros Def]
[hd [tl V1159]]]]]]]] [true [interror Cannot profile.
 []]]]]

null



Evaluating: [defun unprofile [V1160] [untrack V1160]]

null



Evaluating: [defun shen-profile-func [V1161 V1162 V1163] [cons let [cons Start [
cons [cons get-time [cons run []]] [cons [cons let [cons Result [cons V1163 [con
s [cons let [cons Finish [cons [cons - [cons [cons get-time [cons run []]] [cons
 Start []]]] [cons [cons let [cons Record [cons [cons shen-put-profile [cons V11
61 [cons [cons + [cons [cons shen-get-profile [cons V1161 []]] [cons Finish []]]
] []]]] [cons Result []]]]] []]]]] []]]]] []]]]]]

null



Evaluating: [defun profile-results [V1164] [let Results [shen-get-profile V1164]
 [let Initialise [shen-put-profile V1164 0] [@p V1164 Results]]]]

null



Evaluating: [defun shen-get-profile [V1165] [trap-error [get V1165 profile [valu
e shen-*property-vector*]] [lambda E 0]]]

null



Evaluating: [defun shen-put-profile [V1166 V1167] [put V1166 profile V1167 [valu
e shen-*property-vector*]]]

null
("                                                   The License

 The user is free to produce comm

"
 "null
"
 "null
"
 "null
"
 "null
"
 "null
"
 "false
"
 "null
"
 "null
"
 "null
"
 "null
"
 "null
"
 "null
"
 "null
"
 "null
"
 "null
"
 "null
"
 "null
"
 "null
"
 "null
"
 "null
"
 "null
"
 "null
")
[3]> (kl-file-to-java "kl/types.kl")



Evaluating:                                                    The License

 The user is free to produce commercial applications with the software, to distr
ibute these applications in source or binary  form, and to charge monies for the
m as he sees fit and in concordance with the laws of the land subject to the fol
lowing  license.

 1. The license applies to all the software and all derived software and must ap
pear on such.
 2. It is illegal to distribute the software without this license attached to it
 and use of the software implies agreement
    with the license as such. It is illegal for anyone who is not the copyright
holder to tamper with or change the license.
 3. Neither the names of Lambda Associates or the copyright holder may be used t
o endorse or promote products built using
     the software without specific prior written permission from the copyright h
older.
 4. That possession of this license does not confer on the copyright holder any
special contractual obligation towards the    user. That in no event shall the c
opyright holder be liable for any direct, indirect, incidental, special, exempla
ry or   consequential damages (including but not limited to procurement of subst
itute goods or services, loss of use, data, or    profits; or business interrupt
ion), however caused and on any theory of liability, whether in contract, strict
 liability   or tort (including negligence) arising in any way out of the use of
 the software, even if advised of the possibility of   such damage.
5. It is permitted for the user to change the software, for the purpose of impro
ving performance, correcting an error, or    porting to a new platform, and dist
ribute the modified version of Shen (hereafter the modified version) provided th
e     resulting program conforms in all respects to the Shen standard and is iss
ued under that title. The user must make it clear   with his distribution that h
e/she is the author of the changes and what these changes are and why.
6. Derived versions of this software in whatever form are subject to the same re
strictions. In particular it is not          permitted to make derived copies of
 this software which do not conform to the Shen standard or appear under a diffe
rent title.
7. It is permitted to distribute versions of Shen which incorporate libraries, g
raphics or other facilities which are not    part of the Shen standard.

For an explication of this license see http://www.lambdassociates.org/News/june1
1/license.htm which explains this license in full.

                                                   The License

 The user is free to produce comm




Evaluating: [defun declare [V1681 V1682] [let Record [set shen-*signedfuncs* [ad
join V1681 [value shen-*signedfuncs*]]] [let Variancy [trap-error [shen-variancy
-test V1681 V1682] [lambda E shen-skip]] [let Type [shen-rcons_form [shen-normal
ise-type V1682]] [let F* [concat shen-type-signature-of- V1681] [let Parameters
[shen-parameters 1] [let Clause [cons [cons F* [cons X []]] [cons :- [cons [cons
 [cons unify! [cons X [cons Type []]]] []] []]]] [let AUM_instruction [shen-aum
Clause Parameters] [let Code [shen-aum_to_shen AUM_instruction] [let ShenDef [co
ns define [cons F* [append Parameters [append [cons ProcessN [cons Continuation
[]]] [cons -> [cons Code []]]]]]] [let Eval [shen-eval-without-macros ShenDef] V
1681]]]]]]]]]]]

null



Evaluating: [defun shen-normalise-type [V1683] [fix [lambda V1684 [shen-normalis
e-type-help V1684]] V1683]]

null



Evaluating: [defun shen-normalise-type-help [V1685] [cond [[cons? V1685] [shen-n
ormalise-X [map [lambda V1686 [shen-normalise-type-help V1686]] V1685]]] [true [
shen-normalise-X V1685]]]]

null



Evaluating: [defun shen-normalise-X [V1687] [let Val [assoc V1687 [value shen-*s
ynonyms*]] [if [empty? Val] V1687 [tl Val]]]]

null



Evaluating: [defun shen-variancy-test [V1688 V1689] [let TypeF [shen-typecheck V
1688 B] [let Check [if [= symbol TypeF] shen-skip [if [shen-variant? TypeF V1689
] shen-skip [intoutput warning: changing the type of ~A may create errors
 [@p V1688 []]]]] shen-skip]]]

null



Evaluating: [defun shen-variant? [V1698 V1699] [cond [[= V1699 V1698] true] [[an
d [cons? V1698] [and [cons? V1699] [= [hd V1699] [hd V1698]]]] [shen-variant? [t
l V1698] [tl V1699]]] [[and [cons? V1698] [and [cons? V1699] [and [shen-pvar? [h
d V1698]] [variable? [hd V1699]]]]] [shen-variant? [subst shen-a [hd V1698] [tl
V1698]] [subst shen-a [hd V1699] [tl V1699]]]] [[and [cons? V1698] [and [cons? [
hd V1698]] [and [cons? V1699] [cons? [hd V1699]]]]] [shen-variant? [append [hd V
1698] [tl V1698]] [append [hd V1699] [tl V1699]]]] [true false]]]

null



Evaluating: [declare absvector? [cons A [cons --> [cons boolean []]]]]

java.lang.reflect.InvocationTargetException
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.
java:57)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAcces
sorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:601)
        at com.mentics.shen.UpdateImage.runClassForName(UpdateImage.java:238)
        at com.mentics.shen.UpdateImage.run(UpdateImage.java:80)
        at com.mentics.shen.UpdateImage.main(UpdateImage.java:57)
Caused by: java.lang.ClassCastException: com.mentics.shen.Symbol cannot be cast
to com.mentics.shen.Cons
        at shen.gen.ShenMu_reduction.defined(ShenMu_reduction.java:162)
        at shen.gen.ShenMu_reduction.defined(ShenMu_reduction.java:231)
        at shen.gen.ShenAum.defined(ShenAum.java:39)
        at shen.gen.Declare.defined(Declare.java:62)
        at shen.gen.ToEval.run(ToEval.java:10)
        ... 7 more
com.mentics.shen.ShenException: java.lang.reflect.InvocationTargetException
        at com.mentics.shen.UpdateImage.runClassForName(UpdateImage.java:244)
        at com.mentics.shen.UpdateImage.run(UpdateImage.java:80)
        at com.mentics.shen.UpdateImage.main(UpdateImage.java:57)
Caused by: java.lang.reflect.InvocationTargetException
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.
java:57)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAcces
sorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:601)
        at com.mentics.shen.UpdateImage.runClassForName(UpdateImage.java:238)
        ... 2 more
Caused by: java.lang.ClassCastException: com.mentics.shen.Symbol cannot be cast
to com.mentics.shen.Cons
        at shen.gen.ShenMu_reduction.defined(ShenMu_reduction.java:162)
        at shen.gen.ShenMu_reduction.defined(ShenMu_reduction.java:231)
        at shen.gen.ShenAum.defined(ShenAum.java:39)
        at shen.gen.Declare.defined(Declare.java:62)
        at shen.gen.ToEval.run(ToEval.java:10)
        ... 7 more




Evaluating: [declare adjoin [cons A [cons --> [cons [cons [cons list [cons A []]
] [cons --> [cons [cons list [cons A []]] []]]] []]]]]

java.lang.reflect.InvocationTargetException
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.
java:57)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAcces
sorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:601)
        at com.mentics.shen.UpdateImage.runClassForName(UpdateImage.java:238)
        at com.mentics.shen.UpdateImage.run(UpdateImage.java:80)
        at com.mentics.shen.UpdateImage.main(UpdateImage.java:57)
Caused by: java.lang.ClassCastException: com.mentics.shen.Symbol cannot be cast
to com.mentics.shen.Cons
        at shen.gen.ShenMu_reduction.defined(ShenMu_reduction.java:162)
        at shen.gen.ShenMu_reduction.defined(ShenMu_reduction.java:231)
        at shen.gen.ShenAum.defined(ShenAum.java:39)
        at shen.gen.Declare.defined(Declare.java:62)
        at shen.gen.ToEval.run(ToEval.java:10)
        ... 7 more
com.mentics.shen.ShenException: java.lang.reflect.InvocationTargetException
        at com.mentics.shen.UpdateImage.runClassForName(UpdateImage.java:244)
        at com.mentics.shen.UpdateImage.run(UpdateImage.java:80)
        at com.mentics.shen.UpdateImage.main(UpdateImage.java:57)
Caused by: java.lang.reflect.InvocationTargetException
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.
java:57)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAcces
sorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:601)
        at com.mentics.shen.UpdateImage.runClassForName(UpdateImage.java:238)
        ... 2 more
Caused by: java.lang.ClassCastException: com.mentics.shen.Symbol cannot be cast
to com.mentics.shen.Cons
        at shen.gen.ShenMu_reduction.defined(ShenMu_reduction.java:162)
        at shen.gen.ShenMu_reduction.defined(ShenMu_reduction.java:231)
        at shen.gen.ShenAum.defined(ShenAum.java:39)
        at shen.gen.Declare.defined(Declare.java:62)
        at shen.gen.ToEval.run(ToEval.java:10)
        ... 7 more




Evaluating: [declare and [cons boolean [cons --> [cons [cons boolean [cons --> [
cons boolean []]]] []]]]]

java.lang.reflect.InvocationTargetException
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.
java:57)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAcces
sorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:601)
        at com.mentics.shen.UpdateImage.runClassForName(UpdateImage.java:238)
        at com.mentics.shen.UpdateImage.run(UpdateImage.java:80)
        at com.mentics.shen.UpdateImage.main(UpdateImage.java:57)
Caused by: java.lang.ClassCastException: com.mentics.shen.Symbol cannot be cast
to com.mentics.shen.Cons
        at shen.gen.ShenMu_reduction.defined(ShenMu_reduction.java:162)
        at shen.gen.ShenMu_reduction.defined(ShenMu_reduction.java:231)
        at shen.gen.ShenAum.defined(ShenAum.java:39)
        at shen.gen.Declare.defined(Declare.java:62)
        at shen.gen.ToEval.run(ToEval.java:10)
        ... 7 more
com.mentics.shen.ShenException: java.lang.reflect.InvocationTargetException
        at com.mentics.shen.UpdateImage.runClassForName(UpdateImage.java:244)
        at com.mentics.shen.UpdateImage.run(UpdateImage.java:80)
        at com.mentics.shen.UpdateImage.main(UpdateImage.java:57)
Caused by: java.lang.reflect.InvocationTargetException
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.
java:57)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAcces
sorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:601)
        at com.mentics.shen.UpdateImage.runClassForName(UpdateImage.java:238)
        ... 2 more
Caused by: java.lang.ClassCastException: com.mentics.shen.Symbol cannot be cast
to com.mentics.shen.Cons
        at shen.gen.ShenMu_reduction.defined(ShenMu_reduction.java:162)
        at shen.gen.ShenMu_reduction.defined(ShenMu_reduction.java:231)
        at shen.gen.ShenAum.defined(ShenAum.java:39)
        at shen.gen.Declare.defined(Declare.java:62)
        at shen.gen.ToEval.run(ToEval.java:10)
        ... 7 more




Evaluating: [declare append [cons [cons list [cons A []]] [cons --> [cons [cons
[cons list [cons A []]] [cons --> [cons [cons list [cons A []]] []]]] []]]]]

java.lang.reflect.InvocationTargetException
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.
java:57)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAcces
sorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:601)
        at com.mentics.shen.UpdateImage.runClassForName(UpdateImage.java:238)
        at com.mentics.shen.UpdateImage.run(UpdateImage.java:80)
        at com.mentics.shen.UpdateImage.main(UpdateImage.java:57)
Caused by: java.lang.ClassCastException: com.mentics.shen.Symbol cannot be cast
to com.mentics.shen.Cons
        at shen.gen.ShenMu_reduction.defined(ShenMu_reduction.java:162)
        at shen.gen.ShenMu_reduction.defined(ShenMu_reduction.java:231)
        at shen.gen.ShenAum.defined(ShenAum.java:39)
        at shen.gen.Declare.defined(Declare.java:62)
        at shen.gen.ToEval.run(ToEval.java:10)
        ... 7 more
com.mentics.shen.ShenException: java.lang.reflect.InvocationTargetException
        at com.mentics.shen.UpdateImage.runClassForName(UpdateImage.java:244)
        at com.mentics.shen.UpdateImage.run(UpdateImage.java:80)
        at com.mentics.shen.UpdateImage.main(UpdateImage.java:57)
Caused by: java.lang.reflect.InvocationTargetException
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.
java:57)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAcces
sorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:601)
        at com.mentics.shen.UpdateImage.runClassForName(UpdateImage.java:238)
        ... 2 more
Caused by: java.lang.ClassCastException: com.mentics.shen.Symbol cannot be cast
to com.mentics.shen.Cons
        at shen.gen.ShenMu_reduction.defined(ShenMu_reduction.java:162)
        at shen.gen.ShenMu_reduction.defined(ShenMu_reduction.java:231)
        at shen.gen.ShenAum.defined(ShenAum.java:39)
        at shen.gen.Declare.defined(Declare.java:62)
        at shen.gen.ToEval.run(ToEval.java:10)
        ... 7 more




Evaluating: [declare arity [cons A [cons --> [cons number []]]]]

java.lang.reflect.InvocationTargetException
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.
java:57)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAcces
sorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:601)
        at com.mentics.shen.UpdateImage.runClassForName(UpdateImage.java:238)
        at com.mentics.shen.UpdateImage.run(UpdateImage.java:80)
        at com.mentics.shen.UpdateImage.main(UpdateImage.java:57)
Caused by: java.lang.ClassCastException: com.mentics.shen.Symbol cannot be cast
to com.mentics.shen.Cons
        at shen.gen.ShenMu_reduction.defined(ShenMu_reduction.java:162)
        at shen.gen.ShenMu_reduction.defined(ShenMu_reduction.java:231)
        at shen.gen.ShenAum.defined(ShenAum.java:39)
        at shen.gen.Declare.defined(Declare.java:62)
        at shen.gen.ToEval.run(ToEval.java:10)
        ... 7 more
com.mentics.shen.ShenException: java.lang.reflect.InvocationTargetException
        at com.mentics.shen.UpdateImage.runClassForName(UpdateImage.java:244)
        at com.mentics.shen.UpdateImage.run(UpdateImage.java:80)
        at com.mentics.shen.UpdateImage.main(UpdateImage.java:57)
Caused by: java.lang.reflect.InvocationTargetException
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.
java:57)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAcces
sorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:601)
        at com.mentics.shen.UpdateImage.runClassForName(UpdateImage.java:238)
        ... 2 more
Caused by: java.lang.ClassCastException: com.mentics.shen.Symbol cannot be cast
to com.mentics.shen.Cons
        at shen.gen.ShenMu_reduction.defined(ShenMu_reduction.java:162)
        at shen.gen.ShenMu_reduction.defined(ShenMu_reduction.java:231)
        at shen.gen.ShenAum.defined(ShenAum.java:39)
        at shen.gen.Declare.defined(Declare.java:62)
        at shen.gen.ToEval.run(ToEval.java:10)
        ... 7 more




Evaluating: [declare assoc [cons A [cons --> [cons [cons [cons list [cons [cons
list [cons A []]] []]] [cons --> [cons [cons list [cons A []]] []]]] []]]]]

java.lang.reflect.InvocationTargetException
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.
java:57)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAcces
sorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:601)
        at com.mentics.shen.UpdateImage.runClassForName(UpdateImage.java:238)
        at com.mentics.shen.UpdateImage.run(UpdateImage.java:80)
        at com.mentics.shen.UpdateImage.main(UpdateImage.java:57)
Caused by: java.lang.ClassCastException: com.mentics.shen.Symbol cannot be cast
to com.mentics.shen.Cons
        at shen.gen.ShenMu_reduction.defined(ShenMu_reduction.java:162)
        at shen.gen.ShenMu_reduction.defined(ShenMu_reduction.java:231)
        at shen.gen.ShenAum.defined(ShenAum.java:39)
        at shen.gen.Declare.defined(Declare.java:62)
        at shen.gen.ToEval.run(ToEval.java:10)
        ... 7 more
com.mentics.shen.ShenException: java.lang.reflect.InvocationTargetException
        at com.mentics.shen.UpdateImage.runClassForName(UpdateImage.java:244)
        at com.mentics.shen.UpdateImage.run(UpdateImage.java:80)
        at com.mentics.shen.UpdateImage.main(UpdateImage.java:57)
Caused by: java.lang.reflect.InvocationTargetException
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.
java:57)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAcces
sorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:601)
        at com.mentics.shen.UpdateImage.runClassForName(UpdateImage.java:238)
        ... 2 more
Caused by: java.lang.ClassCastException: com.mentics.shen.Symbol cannot be cast
to com.mentics.shen.Cons
        at shen.gen.ShenMu_reduction.defined(ShenMu_reduction.java:162)
        at shen.gen.ShenMu_reduction.defined(ShenMu_reduction.java:231)
        at shen.gen.ShenAum.defined(ShenAum.java:39)
        at shen.gen.Declare.defined(Declare.java:62)
        at shen.gen.ToEval.run(ToEval.java:10)
        ... 7 more




Evaluating: [declare boolean? [cons A [cons --> [cons boolean []]]]]

java.lang.reflect.InvocationTargetException
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.
java:57)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAcces
sorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:601)
        at com.mentics.shen.UpdateImage.runClassForName(UpdateImage.java:238)
        at com.mentics.shen.UpdateImage.run(UpdateImage.java:80)
        at com.mentics.shen.UpdateImage.main(UpdateImage.java:57)
Caused by: java.lang.ClassCastException: com.mentics.shen.Symbol cannot be cast
to com.mentics.shen.Cons
        at shen.gen.ShenMu_reduction.defined(ShenMu_reduction.java:162)
        at shen.gen.ShenMu_reduction.defined(ShenMu_reduction.java:231)
        at shen.gen.ShenAum.defined(ShenAum.java:39)
        at shen.gen.Declare.defined(Declare.java:62)
        at shen.gen.ToEval.run(ToEval.java:10)
        ... 7 more
com.mentics.shen.ShenException: java.lang.reflect.InvocationTargetException
        at com.mentics.shen.UpdateImage.runClassForName(UpdateImage.java:244)
        at com.mentics.shen.UpdateImage.run(UpdateImage.java:80)
        at com.mentics.shen.UpdateImage.main(UpdateImage.java:57)
Caused by: java.lang.reflect.InvocationTargetException
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.
java:57)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAcces
sorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:601)
        at com.mentics.shen.UpdateImage.runClassForName(UpdateImage.java:238)
        ... 2 more
Caused by: java.lang.ClassCastException: com.mentics.shen.Symbol cannot be cast
to com.mentics.shen.Cons
        at shen.gen.ShenMu_reduction.defined(ShenMu_reduction.java:162)
        at shen.gen.ShenMu_reduction.defined(ShenMu_reduction.java:231)
        at shen.gen.ShenAum.defined(ShenAum.java:39)
        at shen.gen.Declare.defined(Declare.java:62)
        at shen.gen.ToEval.run(ToEval.java:10)
        ... 7 more




Evaluating: [declare bound? [cons symbol [cons --> [cons boolean []]]]]

java.lang.reflect.InvocationTargetException
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.
java:57)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAcces
sorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:601)
        at com.mentics.shen.UpdateImage.runClassForName(UpdateImage.java:238)
        at com.mentics.shen.UpdateImage.run(UpdateImage.java:80)
        at com.mentics.shen.UpdateImage.main(UpdateImage.java:57)
Caused by: java.lang.ClassCastException: com.mentics.shen.Symbol cannot be cast
to com.mentics.shen.Cons
        at shen.gen.ShenMu_reduction.defined(ShenMu_reduction.java:162)
        at shen.gen.ShenMu_reduction.defined(ShenMu_reduction.java:231)
        at shen.gen.ShenAum.defined(ShenAum.java:39)
        at shen.gen.Declare.defined(Declare.java:62)
        at shen.gen.ToEval.run(ToEval.java:10)
        ... 7 more
com.mentics.shen.ShenException: java.lang.reflect.InvocationTargetException
        at com.mentics.shen.UpdateImage.runClassForName(UpdateImage.java:244)
        at com.mentics.shen.UpdateImage.run(UpdateImage.java:80)
        at com.mentics.shen.UpdateImage.main(UpdateImage.java:57)
Caused by: java.lang.reflect.InvocationTargetException
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.
java:57)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAcces
sorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:601)
        at com.mentics.shen.UpdateImage.runClassForName(UpdateImage.java:238)
        ... 2 more
Caused by: java.lang.ClassCastException: com.mentics.shen.Symbol cannot be cast
to com.mentics.shen.Cons
        at shen.gen.ShenMu_reduction.defined(ShenMu_reduction.java:162)
        at shen.gen.ShenMu_reduction.defined(ShenMu_reduction.java:231)
        at shen.gen.ShenAum.defined(ShenAum.java:39)
        at shen.gen.Declare.defined(Declare.java:62)
        at shen.gen.ToEval.run(ToEval.java:10)
        ... 7 more




Evaluating: [declare cd [cons string [cons --> [cons string []]]]]

java.lang.reflect.InvocationTargetException
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.
java:57)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAcces
sorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:601)
        at com.mentics.shen.UpdateImage.runClassForName(UpdateImage.java:238)
        at com.mentics.shen.UpdateImage.run(UpdateImage.java:80)
        at com.mentics.shen.UpdateImage.main(UpdateImage.java:57)
Caused by: java.lang.ClassCastException: com.mentics.shen.Symbol cannot be cast
to com.mentics.shen.Cons
        at shen.gen.ShenMu_reduction.defined(ShenMu_reduction.java:162)
        at shen.gen.ShenMu_reduction.defined(ShenMu_reduction.java:231)
        at shen.gen.ShenAum.defined(ShenAum.java:39)
        at shen.gen.Declare.defined(Declare.java:62)
        at shen.gen.ToEval.run(ToEval.java:10)
        ... 7 more
com.mentics.shen.ShenException: java.lang.reflect.InvocationTargetException
        at com.mentics.shen.UpdateImage.runClassForName(UpdateImage.java:244)
        at com.mentics.shen.UpdateImage.run(UpdateImage.java:80)
        at com.mentics.shen.UpdateImage.main(UpdateImage.java:57)
Caused by: java.lang.reflect.InvocationTargetException
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.
java:57)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAcces
sorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:601)
        at com.mentics.shen.UpdateImage.runClassForName(UpdateImage.java:238)
        ... 2 more
Caused by: java.lang.ClassCastException: com.mentics.shen.Symbol cannot be cast
to com.mentics.shen.Cons
        at shen.gen.ShenMu_reduction.defined(ShenMu_reduction.java:162)
        at shen.gen.ShenMu_reduction.defined(ShenMu_reduction.java:231)
        at shen.gen.ShenAum.defined(ShenAum.java:39)
        at shen.gen.Declare.defined(Declare.java:62)
        at shen.gen.ToEval.run(ToEval.java:10)
        ... 7 more




Evaluating: [declare close [cons [cons stream [cons A []]] [cons --> [cons [cons
 list [cons B []]] []]]]]

java.lang.reflect.InvocationTargetException
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.
java:57)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAcces
sorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:601)
        at com.mentics.shen.UpdateImage.runClassForName(UpdateImage.java:238)
        at com.mentics.shen.UpdateImage.run(UpdateImage.java:80)
        at com.mentics.shen.UpdateImage.main(UpdateImage.java:57)
Caused by: java.lang.ClassCastException: com.mentics.shen.Symbol cannot be cast
to com.mentics.shen.Cons
        at shen.gen.ShenMu_reduction.defined(ShenMu_reduction.java:162)
        at shen.gen.ShenMu_reduction.defined(ShenMu_reduction.java:231)
        at shen.gen.ShenAum.defined(ShenAum.java:39)
        at shen.gen.Declare.defined(Declare.java:62)
        at shen.gen.ToEval.run(ToEval.java:10)
        ... 7 more
com.mentics.shen.ShenException: java.lang.reflect.InvocationTargetException
        at com.mentics.shen.UpdateImage.runClassForName(UpdateImage.java:244)
        at com.mentics.shen.UpdateImage.run(UpdateImage.java:80)
        at com.mentics.shen.UpdateImage.main(UpdateImage.java:57)
Caused by: java.lang.reflect.InvocationTargetException
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.
java:57)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAcces
sorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:601)
        at com.mentics.shen.UpdateImage.runClassForName(UpdateImage.java:238)
        ... 2 more
Caused by: java.lang.ClassCastException: com.mentics.shen.Symbol cannot be cast
to com.mentics.shen.Cons
        at shen.gen.ShenMu_reduction.defined(ShenMu_reduction.java:162)
        at shen.gen.ShenMu_reduction.defined(ShenMu_reduction.java:231)
        at shen.gen.ShenAum.defined(ShenAum.java:39)
        at shen.gen.Declare.defined(Declare.java:62)
        at shen.gen.ToEval.run(ToEval.java:10)
        ... 7 more




Evaluating: [declare cn [cons string [cons --> [cons [cons string [cons --> [con
s string []]]] []]]]]

java.lang.reflect.InvocationTargetException
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.
java:57)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAcces
sorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:601)
        at com.mentics.shen.UpdateImage.runClassForName(UpdateImage.java:238)
        at com.mentics.shen.UpdateImage.run(UpdateImage.java:80)
        at com.mentics.shen.UpdateImage.main(UpdateImage.java:57)
Caused by: java.lang.ClassCastException: com.mentics.shen.Symbol cannot be cast
to com.mentics.shen.Cons
        at shen.gen.ShenMu_reduction.defined(ShenMu_reduction.java:162)
        at shen.gen.ShenMu_reduction.defined(ShenMu_reduction.java:231)
        at shen.gen.ShenAum.defined(ShenAum.java:39)
        at shen.gen.Declare.defined(Declare.java:62)
        at shen.gen.ToEval.run(ToEval.java:10)
        ... 7 more
com.mentics.shen.ShenException: java.lang.reflect.InvocationTargetException
        at com.mentics.shen.UpdateImage.runClassForName(UpdateImage.java:244)
        at com.mentics.shen.UpdateImage.run(UpdateImage.java:80)
        at com.mentics.shen.UpdateImage.main(UpdateImage.java:57)
Caused by: java.lang.reflect.InvocationTargetException
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.
java:57)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAcces
sorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:601)
        at com.mentics.shen.UpdateImage.runClassForName(UpdateImage.java:238)
        ... 2 more
Caused by: java.lang.ClassCastException: com.mentics.shen.Symbol cannot be cast
to com.mentics.shen.Cons
        at shen.gen.ShenMu_reduction.defined(ShenMu_reduction.java:162)
        at shen.gen.ShenMu_reduction.defined(ShenMu_reduction.java:231)
        at shen.gen.ShenAum.defined(ShenAum.java:39)
        at shen.gen.Declare.defined(Declare.java:62)
        at shen.gen.ToEval.run(ToEval.java:10)
        ... 7 more




Evaluating: [declare concat [cons symbol [cons --> [cons [cons symbol [cons -->
[cons symbol []]]] []]]]]


*** - READ-CHAR: Ctrl-C: User break
Break 1 [4]>