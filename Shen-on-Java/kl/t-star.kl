"**********************************************************************************
*                           The License						                                      *
* 										                                                                  *
* The user is free to produce commercial applications with the software, to 	          *
* distribute these applications in source or binary  form, and to charge monies         *
* for them as he sees fit and in concordance with the laws of the land subject 	        *
* to the following license.							                                                *
*										                                                                    * 
* 1. The license applies to all the software and all derived software and 	            *
*    must appear on such.							                                                  *
*										                                                                    *
* 2. It is illegal to distribute the software without this license attached	            *
*    to it and use of the software implies agreement with the license as such.          *
*    It is illegal for anyone who is not the copyright holder to tamper with 	          *
*    or change the license.							                                                *
*										                                                                    *
* 3. Neither the names of Lambda Associates or the copyright holder may be used         *
*    to endorse or promote products built using the software without specific 	        *
*    prior written permission from the copyright holder.		                            *
*										                                                                    *
* 4. That possession of this license does not confer on the copyright holder 	          *
*    any special contractual obligation towards the user. That in no event 	            * 
*    shall the copyright holder be liable for any direct, indirect, incidental,        *   
*    special, exemplary or consequential damages (including but not limited             *
*    to procurement of substitute goods or services, loss of use, data, 	              * 
*    interruption), however caused and on any theory of liability, whether in	          * 
*    contract, strict liability or tort (including negligence) arising in any         	*
*    way out of the use of the software, even if advised of the possibility of         	*
*    such damage.						                                                        		* 
*										                                                                    *
* 5. It is permitted for the user to change the software, for the purpose of 	          *
*    improving performance, correcting an error, or porting to a new platform, 	        *
*    and distribute the derived version of Shen provided the resulting program 	        *
*    conforms in all respects to the Shen standard and is issued under that             * 
*    title. The user must make it clear with his distribution that he/she is 	          *
*    the author of the changes and what these changes are and why. 		                  *
*										                                                                    *
* 6. Derived versions of this software in whatever form are subject to the same         *
*    restrictions. In particular it is not permitted to make derived copies of          *
*    this software which do not conform to the Shen standard or appear under a          *
*    different title.								                                                    *
*										                                                                    *
*    It is permitted to distribute versions of Shen which incorporate libraries,        *
*    graphics or other facilities which are not part of the Shen standard.	            *
*										                                                                    *
* For an explication of this license see www.shenlanguage.org/license.htm which         *
* explains this license in full.                                                        *
*				 						                                                                    *
*****************************************************************************************
"(defun shen.typecheck (V2753 V2754) (let Curry (shen.curry V2753) (let ProcessN (shen.start-new-prolog-process) (let Type (shen.insert-prolog-variables (shen.normalise-type (shen.curry-type V2754)) ProcessN) (let Continuation (freeze (return Type ProcessN shen.void)) (shen.t* (cons Curry (cons : (cons Type ()))) () ProcessN Continuation))))))

(defun shen.curry (V2755) (cond ((and (cons? V2755) (shen.special? (hd V2755))) (cons (hd V2755) (map shen.curry (tl V2755)))) ((and (cons? V2755) (and (cons? (tl V2755)) (shen.extraspecial? (hd V2755)))) V2755) ((and (cons? V2755) (and (cons? (tl V2755)) (cons? (tl (tl V2755))))) (shen.curry (cons (cons (hd V2755) (cons (hd (tl V2755)) ())) (tl (tl V2755))))) ((and (cons? V2755) (and (cons? (tl V2755)) (= () (tl (tl V2755))))) (cons (shen.curry (hd V2755)) (cons (shen.curry (hd (tl V2755))) ()))) (true V2755)))

(defun shen.special? (V2756) (element? V2756 (value shen.*special*)))

(defun shen.extraspecial? (V2757) (element? V2757 (value shen.*extraspecial*)))

(defun shen.t* (V2758 V2759 V2760 V2761) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let Error (shen.newpv V2760) (do (shen.incinfs) (fwhen (shen.maxinfexceeded?) V2760 (freeze (bind Error (shen.errormaxinfs) V2760 V2761))))) (if (= Case false) (let Case (let V2747 (shen.lazyderef V2758 V2760) (if (= fail V2747) (do (shen.incinfs) (cut Throwcontrol V2760 (freeze (shen.prolog-failure V2760 V2761)))) false)) (if (= Case false) (let Case (let V2748 (shen.lazyderef V2758 V2760) (if (cons? V2748) (let X (hd V2748) (let V2749 (shen.lazyderef (tl V2748) V2760) (if (cons? V2749) (let V2750 (shen.lazyderef (hd V2749) V2760) (if (= : V2750) (let V2751 (shen.lazyderef (tl V2749) V2760) (if (cons? V2751) (let A (hd V2751) (let V2752 (shen.lazyderef (tl V2751) V2760) (if (= () V2752) (do (shen.incinfs) (fwhen (shen.type-theory-enabled?) V2760 (freeze (cut Throwcontrol V2760 (freeze (shen.th* X A V2759 V2760 V2761)))))) false))) false)) false)) false))) false)) (if (= Case false) (let Datatypes (shen.newpv V2760) (do (shen.incinfs) (shen.show V2758 V2759 V2760 (freeze (bind Datatypes (value shen.*datatypes*) V2760 (freeze (shen.udefs* V2758 V2759 Datatypes V2760 V2761))))))) Case)) Case)) Case)))))

(defun shen.type-theory-enabled? () (value shen.*shen-type-theory-enabled?*))

(defun enable-type-theory (V2766) (cond ((= + V2766) (set shen.*shen-type-theory-enabled?* true)) ((= - V2766) (set shen.*shen-type-theory-enabled?* false)) (true (simple-error "enable-type-theory expects a + or a -
"))))

(defun shen.prolog-failure (V2775 V2776) false)

(defun shen.maxinfexceeded? () (> (inferences) (value shen.*maxinferences*)))

(defun shen.errormaxinfs () (simple-error "maximum inferences exceeded~%"))

(defun shen.udefs* (V2777 V2778 V2779 V2780 V2781)  (let Case    (let V2743 (shen.lazyderef V2779 V2780)      (if (cons? V2743) (let D (hd V2743) (do (shen.incinfs) (call (cons D (cons V2777 (cons V2778 ()))) V2780 V2781))) false))      (if (= Case false) (let V2744 (shen.lazyderef V2779 V2780) (if (cons? V2744) (let Ds (tl V2744) (do (shen.incinfs) (shen.udefs* V2777 V2778 Ds V2780 V2781))) false)) Case)))

(defun shen.show (V2803 V2804 V2805 V2806) (cond ((value shen.*spy*) (do (shen.line) (do (shen.show-p (shen.deref V2803 V2805)) (do (nl 1) (do (nl 1) (do (shen.show-assumptions (shen.deref V2804 V2805) 1) (do (pr "
> " (stoutput)) (do (shen.pause-for-user (value *language*)) (thaw V2806))))))))) (true (thaw V2806))))

(defun shen.line () (let Infs (inferences) (pr (cn "____________________________________________________________ " (shen.app Infs (cn " inference" (shen.app (if (= 1 Infs) "" "s") " 
?- " shen.a)) shen.a)) (stoutput))))

(defun shen.show-p (V2807) (cond ((and (cons? V2807) (and (cons? (tl V2807)) (and (= : (hd (tl V2807))) (and (cons? (tl (tl V2807))) (= () (tl (tl (tl V2807)))))))) (pr (shen.app (hd V2807) (cn " : " (shen.app (hd (tl (tl V2807))) "" shen.r)) shen.r) (stoutput))) (true (pr (shen.app V2807 "" shen.r) (stoutput)))))

(defun shen.show-assumptions (V2810 V2811) (cond ((= () V2810) shen.skip) ((cons? V2810) (do (pr (shen.app V2811 ". " shen.a) (stoutput)) (do (shen.show-p (hd V2810)) (do (nl 1) (shen.show-assumptions (tl V2810) (+ V2811 1)))))) (true (shen.sys-error shen.show-assumptions))))

(defun shen.pause-for-user (V2816) (cond ((= "Common Lisp" V2816) (let I (FORMAT () "~C" (READ-CHAR)) (if (= I "a") (simple-error "input aborted
") (nl 1)))) (true (let I (shen.read-char) (if (= I "a") (simple-error "input aborted
") (nl 1))))))

(defun shen.read-char () (shen.read-char-h (read-byte (stinput)) 0))

(defun shen.read-char-h (V2819 V2820) (cond ((and (= -1 V2819) (= 0 V2820)) (shen.read-char-h (read-byte (stinput)) 1)) ((= 0 V2820) (shen.read-char-h (read-byte (stinput)) 0)) ((and (= -1 V2819) (= 1 V2820)) (shen.read-char-h (read-byte (stinput)) 1)) ((= 1 V2820) (n->string V2819)) (true (shen.sys-error shen.read-char-h))))

(defun shen.typedf? (V2821) (element? V2821 (value shen.*signedfuncs*)))

(defun shen.sigf (V2822) (concat shen.type-signature-of- V2822))

(defun shen.placeholder () (gensym &&))

(defun shen.base (V2823 V2824 V2825 V2826) (let Case (let V2521 (shen.lazyderef V2824 V2825) (if (= number V2521) (do (shen.incinfs) (fwhen (number? (shen.lazyderef V2823 V2825)) V2825 V2826)) (if (shen.pvar? V2521) (do (shen.bindv V2521 number V2825) (let Result (do (shen.incinfs) (fwhen (number? (shen.lazyderef V2823 V2825)) V2825 V2826)) (do (shen.unbindv V2521 V2825) Result))) false))) (if (= Case false) (let Case (let V2522 (shen.lazyderef V2824 V2825) (if (= boolean V2522) (do (shen.incinfs) (fwhen (boolean? (shen.lazyderef V2823 V2825)) V2825 V2826)) (if (shen.pvar? V2522) (do (shen.bindv V2522 boolean V2825) (let Result (do (shen.incinfs) (fwhen (boolean? (shen.lazyderef V2823 V2825)) V2825 V2826)) (do (shen.unbindv V2522 V2825) Result))) false))) (if (= Case false) (let Case (let V2523 (shen.lazyderef V2824 V2825) (if (= string V2523) (do (shen.incinfs) (fwhen (string? (shen.lazyderef V2823 V2825)) V2825 V2826)) (if (shen.pvar? V2523) (do (shen.bindv V2523 string V2825) (let Result (do (shen.incinfs) (fwhen (string? (shen.lazyderef V2823 V2825)) V2825 V2826)) (do (shen.unbindv V2523 V2825) Result))) false))) (if (= Case false) (let Case (let V2524 (shen.lazyderef V2824 V2825) (if (= symbol V2524) (do (shen.incinfs) (fwhen (symbol? (shen.lazyderef V2823 V2825)) V2825 (freeze (fwhen (not (shen.placeholder? (shen.lazyderef V2823 V2825))) V2825 V2826)))) (if (shen.pvar? V2524) (do (shen.bindv V2524 symbol V2825) (let Result (do (shen.incinfs) (fwhen (symbol? (shen.lazyderef V2823 V2825)) V2825 (freeze (fwhen (not (shen.placeholder? (shen.lazyderef V2823 V2825))) V2825 V2826)))) (do (shen.unbindv V2524 V2825) Result))) false))) (if (= Case false) (let V2525 (shen.lazyderef V2823 V2825) (if (= () V2525) (let V2526 (shen.lazyderef V2824 V2825) (if (cons? V2526) (let V2527 (shen.lazyderef (hd V2526) V2825) (if (= list V2527) (let V2528 (shen.lazyderef (tl V2526) V2825) (if (cons? V2528) (let A (hd V2528) (let V2529 (shen.lazyderef (tl V2528) V2825) (if (= () V2529) (do (shen.incinfs) (thaw V2826)) (if (shen.pvar? V2529) (do (shen.bindv V2529 () V2825) (let Result (do (shen.incinfs) (thaw V2826)) (do (shen.unbindv V2529 V2825) Result))) false)))) (if (shen.pvar? V2528) (let A (shen.newpv V2825) (do (shen.bindv V2528 (cons A ()) V2825) (let Result (do (shen.incinfs) (thaw V2826)) (do (shen.unbindv V2528 V2825) Result)))) false))) (if (shen.pvar? V2527) (do (shen.bindv V2527 list V2825) (let Result (let V2530 (shen.lazyderef (tl V2526) V2825) (if (cons? V2530) (let A (hd V2530) (let V2531 (shen.lazyderef (tl V2530) V2825) (if (= () V2531) (do (shen.incinfs) (thaw V2826)) (if (shen.pvar? V2531) (do (shen.bindv V2531 () V2825) (let Result (do (shen.incinfs) (thaw V2826)) (do (shen.unbindv V2531 V2825) Result))) false)))) (if (shen.pvar? V2530) (let A (shen.newpv V2825) (do (shen.bindv V2530 (cons A ()) V2825) (let Result (do (shen.incinfs) (thaw V2826)) (do (shen.unbindv V2530 V2825) Result)))) false))) (do (shen.unbindv V2527 V2825) Result))) false))) (if (shen.pvar? V2526) (let A (shen.newpv V2825) (do (shen.bindv V2526 (cons list (cons A ())) V2825) (let Result (do (shen.incinfs) (thaw V2826)) (do (shen.unbindv V2526 V2825) Result)))) false))) false)) Case)) Case)) Case)) Case)))

(defun shen.placeholder? (V2827) (and (symbol? V2827) (shen.placeholder-help? (str V2827))))

(defun shen.placeholder-help? (V2834) (cond ((and (shen.+string? V2834) (and (= "&" (pos V2834 0)) (and (shen.+string? (tlstr V2834)) (= "&" (pos (tlstr V2834) 0))))) true) (true false)))

(defun shen.by_hypothesis (V2835 V2836 V2837 V2838 V2839) (let Case (let V2512 (shen.lazyderef V2837 V2838) (if (cons? V2512) (let V2513 (shen.lazyderef (hd V2512) V2838) (if (cons? V2513) (let Y (hd V2513) (let V2514 (shen.lazyderef (tl V2513) V2838) (if (cons? V2514) (let V2515 (shen.lazyderef (hd V2514) V2838) (if (= : V2515) (let V2516 (shen.lazyderef (tl V2514) V2838) (if (cons? V2516) (let B (hd V2516) (let V2517 (shen.lazyderef (tl V2516) V2838) (if (= () V2517) (do (shen.incinfs) (identical V2835 Y V2838 (freeze (unify! V2836 B V2838 V2839)))) false))) false)) false)) false))) false)) false)) (if (= Case false) (let V2518 (shen.lazyderef V2837 V2838) (if (cons? V2518) (let Hyp (tl V2518) (do (shen.incinfs) (shen.by_hypothesis V2835 V2836 Hyp V2838 V2839))) false)) Case)))

(defun shen.t*-def (V2840 V2841 V2842 V2843 V2844) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let V2506 (shen.lazyderef V2840 V2843) (if (cons? V2506) (let V2507 (shen.lazyderef (hd V2506) V2843) (if (= define V2507) (let V2508 (shen.lazyderef (tl V2506) V2843) (if (cons? V2508) (let F (hd V2508) (let X (tl V2508) (let Error (shen.newpv V2843) (let Sig+Rules (shen.newpv V2843) (let Vars (shen.newpv V2843) (let Rules (shen.newpv V2843) (let Sig&& (shen.newpv V2843) (let Declare (shen.newpv V2843) (let Sig (shen.newpv V2843) (do (shen.incinfs) (bind Sig+Rules (compile shen.<sig+rules> (shen.lazyderef X V2843) ()) V2843 (freeze (bind Error (if (= (shen.lazyderef Sig+Rules V2843) (fail)) (shen.errordef (shen.lazyderef F V2843)) shen.skip) V2843 (freeze (bind Sig (hd (shen.lazyderef Sig+Rules V2843)) V2843 (freeze (bind Rules (tl (shen.lazyderef Sig+Rules V2843)) V2843 (freeze (bind Vars (shen.extract_vars (shen.lazyderef Sig V2843)) V2843 (freeze (bind Sig&& (shen.placeholders (shen.lazyderef Sig V2843) (shen.lazyderef Vars V2843)) V2843 (freeze (cut Throwcontrol V2843 (freeze (shen.t*-rules Rules Sig&& 1 F (cons (cons F (cons : (cons Sig&& ()))) V2842) V2843 (freeze (bind Declare (declare (shen.lazyderef F V2843) (shen.lazyderef Sig V2843)) V2843 (freeze (unify! V2841 Sig V2843 V2844))))))))))))))))))))))))))))) false)) false)) false)))))

(defun shen.<sig+rules> (V2849) (let Result (let Parse_shen.<signature> (shen.<signature> V2849) (if (not (= (fail) Parse_shen.<signature>)) (let Parse_shen.<trules> (shen.<trules> Parse_shen.<signature>) (if (not (= (fail) Parse_shen.<trules>)) (shen.pair (hd Parse_shen.<trules>) (cons (shen.hdtl Parse_shen.<signature>) (shen.hdtl Parse_shen.<trules>))) (fail))) (fail))) (if (= Result (fail)) (fail) Result)))

(defun shen.placeholders (V2854 V2855) (cond ((cons? V2854) (map (lambda Z (shen.placeholders Z V2855)) V2854)) ((element? V2854 V2855) (concat && V2854)) (true V2854)))

(defun shen.<trules> (V2860) (let Result (let Parse_shen.<trule> (shen.<trule> V2860) (if (not (= (fail) Parse_shen.<trule>)) (let Parse_shen.<trules> (shen.<trules> Parse_shen.<trule>) (if (not (= (fail) Parse_shen.<trules>)) (shen.pair (hd Parse_shen.<trules>) (cons (shen.hdtl Parse_shen.<trule>) (shen.hdtl Parse_shen.<trules>))) (fail))) (fail))) (if (= Result (fail)) (let Result (let Parse_shen.<trule> (shen.<trule> V2860) (if (not (= (fail) Parse_shen.<trule>)) (shen.pair (hd Parse_shen.<trule>) (cons (shen.hdtl Parse_shen.<trule>) ())) (fail))) (if (= Result (fail)) (fail) Result)) Result)))

(defun shen.<trule> (V2865) (let Result (let Parse_shen.<patterns> (shen.<patterns> V2865) (if (not (= (fail) Parse_shen.<patterns>)) (let Parse_shen.<arrow> (shen.<arrow> Parse_shen.<patterns>) (if (not (= (fail) Parse_shen.<arrow>)) (let Parse_shen.<action> (shen.<action> Parse_shen.<arrow>) (if (not (= (fail) Parse_shen.<action>)) (let Parse_shen.<guard?> (shen.<guard?> Parse_shen.<action>) (if (not (= (fail) Parse_shen.<guard?>)) (shen.pair (hd Parse_shen.<guard?>) (let Parse_Vars (shen.extract_vars (shen.hdtl Parse_shen.<patterns>)) (let Parse_Patterns (shen.placeholders (shen.hdtl Parse_shen.<patterns>) Parse_Vars) (let Parse_Action (shen.placeholders (shen.curry (shen.hdtl Parse_shen.<action>)) Parse_Vars) (let Parse_Guard (shen.placeholders (shen.curry (shen.hdtl Parse_shen.<guard?>)) Parse_Vars) (shen.form-rule Parse_Patterns (shen.hdtl Parse_shen.<arrow>) Parse_Action Parse_Guard)))))) (fail))) (fail))) (fail))) (fail))) (if (= Result (fail)) (fail) Result)))

(defun shen.form-rule (V2866 V2867 V2868 V2869) (cond ((= shen.forward V2867) (cons V2866 (cons (if (= V2869 shen.skip) V2868 (cons where (cons V2869 (cons V2868 ())))) ()))) ((and (= shen.backward V2867) (and (cons? V2868) (and (cons? (hd V2868)) (and (= fail-if (hd (hd V2868))) (and (cons? (tl (hd V2868))) (and (= () (tl (tl (hd V2868)))) (and (cons? (tl V2868)) (= () (tl (tl V2868)))))))))) (cons V2866 (cons (if (= V2869 shen.skip) (cons where (cons (cons not (cons (cons (hd (tl (hd V2868))) (tl V2868)) ())) (tl V2868))) (cons where (cons (cons (cons and (cons V2869 ())) (cons (cons not (cons (cons (hd (tl (hd V2868))) (tl V2868)) ())) ())) (tl V2868)))) ()))) ((= shen.backward V2867) (cons V2866 (cons (if (= V2869 shen.skip) (cons where (cons (cons not (cons (cons (cons == (cons V2868 ())) (cons (cons fail ()) ())) ())) (cons V2868 ()))) (cons where (cons (cons (cons and (cons V2869 ())) (cons (cons not (cons (cons (cons == (cons V2868 ())) (cons (cons fail ()) ())) ())) ())) (cons V2868 ())))) ()))) (true (shen.sys-error shen.form-rule))))

(defun shen.<guard?> (V2874) (let Result (if (and (cons? (hd V2874)) (= where (hd (hd V2874)))) (let Parse_shen.<guard> (shen.<guard> (shen.pair (tl (hd V2874)) (shen.hdtl V2874))) (if (not (= (fail) Parse_shen.<guard>)) (shen.pair (hd Parse_shen.<guard>) (shen.hdtl Parse_shen.<guard>)) (fail))) (fail)) (if (= Result (fail)) (let Result (let Parse_<e> (<e> V2874) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) shen.skip) (fail))) (if (= Result (fail)) (fail) Result)) Result)))

(defun shen.<arrow> (V2879) (let Result (if (and (cons? (hd V2879)) (= -> (hd (hd V2879)))) (shen.pair (hd (shen.pair (tl (hd V2879)) (shen.hdtl V2879))) shen.forward) (fail)) (if (= Result (fail)) (let Result (if (and (cons? (hd V2879)) (= <- (hd (hd V2879)))) (shen.pair (hd (shen.pair (tl (hd V2879)) (shen.hdtl V2879))) shen.backward) (fail)) (if (= Result (fail)) (fail) Result)) Result)))

(defun shen.errordef (V2880) (simple-error (cn "syntax error in " (shen.app V2880 "
" shen.a))))

(defun shen.t*-rules (V2881 V2882 V2883 V2884 V2885 V2886 V2887) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V2501 (shen.lazyderef V2881 V2886) (if (= () V2501) (do (shen.incinfs) (thaw V2887)) false)) (if (= Case false) (let V2502 (shen.lazyderef V2881 V2886) (if (cons? V2502) (let Rule (hd V2502) (let Rules (tl V2502) (let M (shen.newpv V2886) (do (shen.incinfs) (shen.t*-rule Rule V2882 V2883 V2884 V2885 V2886 (freeze (cut Throwcontrol V2886 (freeze (bind M (+ (shen.lazyderef V2883 V2886) 1) V2886 (freeze (shen.t*-rules Rules V2882 M V2884 V2885 V2886 V2887))))))))))) false)) Case)))))

(defun shen.t*-rule (V2888 V2889 V2890 V2891 V2892 V2893 V2894) (let Case (do (shen.incinfs) (shen.t*-ruleh V2888 V2889 V2892 V2893 V2894)) (if (= Case false) (let Error (shen.newpv V2893) (do (shen.incinfs) (bind Error (shen.type-insecure-rule-error-message (shen.lazyderef V2890 V2893) (shen.lazyderef V2891 V2893)) V2893 V2894))) Case)))

(defun shen.t*-ruleh (V2895 V2896 V2897 V2898 V2899) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V2478 (shen.lazyderef V2895 V2898) (if (cons? V2478) (let V2479 (shen.lazyderef (hd V2478) V2898) (if (= () V2479) (let V2480 (shen.lazyderef (tl V2478) V2898) (if (cons? V2480) (let Result (hd V2480) (let V2481 (shen.lazyderef (tl V2480) V2898) (if (= () V2481) (let V2482 (shen.lazyderef V2896 V2898) (if (cons? V2482) (let V2483 (shen.lazyderef (hd V2482) V2898) (if (= --> V2483) (let V2484 (shen.lazyderef (tl V2482) V2898) (if (cons? V2484) (let A (hd V2484) (let V2485 (shen.lazyderef (tl V2484) V2898) (if (= () V2485) (do (shen.incinfs) (cut Throwcontrol V2898 (freeze (shen.th* Result A V2897 V2898 V2899)))) (if (shen.pvar? V2485) (do (shen.bindv V2485 () V2898) (let Result (do (shen.incinfs) (cut Throwcontrol V2898 (freeze (shen.th* Result A V2897 V2898 V2899)))) (do (shen.unbindv V2485 V2898) Result))) false)))) (if (shen.pvar? V2484) (let A (shen.newpv V2898) (do (shen.bindv V2484 (cons A ()) V2898) (let Result (do (shen.incinfs) (cut Throwcontrol V2898 (freeze (shen.th* Result A V2897 V2898 V2899)))) (do (shen.unbindv V2484 V2898) Result)))) false))) (if (shen.pvar? V2483) (do (shen.bindv V2483 --> V2898) (let Result (let V2486 (shen.lazyderef (tl V2482) V2898) (if (cons? V2486) (let A (hd V2486) (let V2487 (shen.lazyderef (tl V2486) V2898) (if (= () V2487) (do (shen.incinfs) (cut Throwcontrol V2898 (freeze (shen.th* Result A V2897 V2898 V2899)))) (if (shen.pvar? V2487) (do (shen.bindv V2487 () V2898) (let Result (do (shen.incinfs) (cut Throwcontrol V2898 (freeze (shen.th* Result A V2897 V2898 V2899)))) (do (shen.unbindv V2487 V2898) Result))) false)))) (if (shen.pvar? V2486) (let A (shen.newpv V2898) (do (shen.bindv V2486 (cons A ()) V2898) (let Result (do (shen.incinfs) (cut Throwcontrol V2898 (freeze (shen.th* Result A V2897 V2898 V2899)))) (do (shen.unbindv V2486 V2898) Result)))) false))) (do (shen.unbindv V2483 V2898) Result))) false))) (if (shen.pvar? V2482) (let A (shen.newpv V2898) (do (shen.bindv V2482 (cons --> (cons A ())) V2898) (let Result (do (shen.incinfs) (cut Throwcontrol V2898 (freeze (shen.th* Result A V2897 V2898 V2899)))) (do (shen.unbindv V2482 V2898) Result)))) false))) false))) false)) false)) false)) (if (= Case false) (let V2488 (shen.lazyderef V2895 V2898) (if (cons? V2488) (let Patterns (hd V2488) (let V2489 (shen.lazyderef (tl V2488) V2898) (if (cons? V2489) (let Result (hd V2489) (let V2490 (shen.lazyderef (tl V2489) V2898) (if (= () V2490) (let NewHyp (shen.newpv V2898) (let B (shen.newpv V2898) (let AllHyp (shen.newpv V2898) (do (shen.incinfs) (shen.t*-patterns Patterns V2896 NewHyp B V2898 (freeze (cut Throwcontrol V2898 (freeze (shen.conc NewHyp V2897 AllHyp V2898 (freeze (cut Throwcontrol V2898 (freeze (shen.th* Result B AllHyp V2898 V2899))))))))))))) false))) false))) false)) Case)))))

(defun shen.type-insecure-rule-error-message (V2900 V2901) (simple-error (cn "type error in rule " (shen.app V2900 (cn " of " (shen.app V2901 "
" shen.a)) shen.a))))

(defun shen.t*-patterns (V2902 V2903 V2904 V2905 V2906 V2907) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V2459 (shen.lazyderef V2902 V2906) (if (= () V2459) (let V2460 (shen.lazyderef V2904 V2906) (if (= () V2460) (do (shen.incinfs) (unify! V2905 V2903 V2906 V2907)) (if (shen.pvar? V2460) (do (shen.bindv V2460 () V2906) (let Result (do (shen.incinfs) (unify! V2905 V2903 V2906 V2907)) (do (shen.unbindv V2460 V2906) Result))) false))) false)) (if (= Case false) (let V2461 (shen.lazyderef V2902 V2906) (if (cons? V2461) (let Pattern2453 (hd V2461) (let Patterns (tl V2461) (let V2462 (shen.lazyderef V2903 V2906) (if (cons? V2462) (let A2454 (hd V2462) (let V2463 (shen.lazyderef (tl V2462) V2906) (if (cons? V2463) (let V2464 (shen.lazyderef (hd V2463) V2906) (if (= --> V2464) (let V2465 (shen.lazyderef (tl V2463) V2906) (if (cons? V2465) (let B (hd V2465) (let V2466 (shen.lazyderef (tl V2465) V2906) (if (= () V2466) (let V2467 (shen.lazyderef V2904 V2906) (if (cons? V2467) (let V2468 (shen.lazyderef (hd V2467) V2906) (if (cons? V2468) (let Pattern (hd V2468) (let V2469 (shen.lazyderef (tl V2468) V2906) (if (cons? V2469) (let V2470 (shen.lazyderef (hd V2469) V2906) (if (= : V2470) (let V2471 (shen.lazyderef (tl V2469) V2906) (if (cons? V2471) (let A (hd V2471) (let V2472 (shen.lazyderef (tl V2471) V2906) (if (= () V2472) (let Hyp (tl V2467) (let Assume (shen.newpv V2906) (do (shen.incinfs) (unify! A A2454 V2906 (freeze (unify! Pattern Pattern2453 V2906 (freeze (shen.t*-assume Pattern Assume V2906 (freeze (cut Throwcontrol V2906 (freeze (shen.th* Pattern A Assume V2906 (freeze (cut Throwcontrol V2906 (freeze (shen.t*-patterns Patterns B Hyp V2905 V2906 V2907)))))))))))))))) (if (shen.pvar? V2472) (do (shen.bindv V2472 () V2906) (let Result (let Hyp (tl V2467) (let Assume (shen.newpv V2906) (do (shen.incinfs) (unify! A A2454 V2906 (freeze (unify! Pattern Pattern2453 V2906 (freeze (shen.t*-assume Pattern Assume V2906 (freeze (cut Throwcontrol V2906 (freeze (shen.th* Pattern A Assume V2906 (freeze (cut Throwcontrol V2906 (freeze (shen.t*-patterns Patterns B Hyp V2905 V2906 V2907)))))))))))))))) (do (shen.unbindv V2472 V2906) Result))) false)))) (if (shen.pvar? V2471) (let A (shen.newpv V2906) (do (shen.bindv V2471 (cons A ()) V2906) (let Result (let Hyp (tl V2467) (let Assume (shen.newpv V2906) (do (shen.incinfs) (unify! A A2454 V2906 (freeze (unify! Pattern Pattern2453 V2906 (freeze (shen.t*-assume Pattern Assume V2906 (freeze (cut Throwcontrol V2906 (freeze (shen.th* Pattern A Assume V2906 (freeze (cut Throwcontrol V2906 (freeze (shen.t*-patterns Patterns B Hyp V2905 V2906 V2907)))))))))))))))) (do (shen.unbindv V2471 V2906) Result)))) false))) (if (shen.pvar? V2470) (do (shen.bindv V2470 : V2906) (let Result (let V2473 (shen.lazyderef (tl V2469) V2906) (if (cons? V2473) (let A (hd V2473) (let V2474 (shen.lazyderef (tl V2473) V2906) (if (= () V2474) (let Hyp (tl V2467) (let Assume (shen.newpv V2906) (do (shen.incinfs) (unify! A A2454 V2906 (freeze (unify! Pattern Pattern2453 V2906 (freeze (shen.t*-assume Pattern Assume V2906 (freeze (cut Throwcontrol V2906 (freeze (shen.th* Pattern A Assume V2906 (freeze (cut Throwcontrol V2906 (freeze (shen.t*-patterns Patterns B Hyp V2905 V2906 V2907)))))))))))))))) (if (shen.pvar? V2474) (do (shen.bindv V2474 () V2906) (let Result (let Hyp (tl V2467) (let Assume (shen.newpv V2906) (do (shen.incinfs) (unify! A A2454 V2906 (freeze (unify! Pattern Pattern2453 V2906 (freeze (shen.t*-assume Pattern Assume V2906 (freeze (cut Throwcontrol V2906 (freeze (shen.th* Pattern A Assume V2906 (freeze (cut Throwcontrol V2906 (freeze (shen.t*-patterns Patterns B Hyp V2905 V2906 V2907)))))))))))))))) (do (shen.unbindv V2474 V2906) Result))) false)))) (if (shen.pvar? V2473) (let A (shen.newpv V2906) (do (shen.bindv V2473 (cons A ()) V2906) (let Result (let Hyp (tl V2467) (let Assume (shen.newpv V2906) (do (shen.incinfs) (unify! A A2454 V2906 (freeze (unify! Pattern Pattern2453 V2906 (freeze (shen.t*-assume Pattern Assume V2906 (freeze (cut Throwcontrol V2906 (freeze (shen.th* Pattern A Assume V2906 (freeze (cut Throwcontrol V2906 (freeze (shen.t*-patterns Patterns B Hyp V2905 V2906 V2907)))))))))))))))) (do (shen.unbindv V2473 V2906) Result)))) false))) (do (shen.unbindv V2470 V2906) Result))) false))) (if (shen.pvar? V2469) (let A (shen.newpv V2906) (do (shen.bindv V2469 (cons : (cons A ())) V2906) (let Result (let Hyp (tl V2467) (let Assume (shen.newpv V2906) (do (shen.incinfs) (unify! A A2454 V2906 (freeze (unify! Pattern Pattern2453 V2906 (freeze (shen.t*-assume Pattern Assume V2906 (freeze (cut Throwcontrol V2906 (freeze (shen.th* Pattern A Assume V2906 (freeze (cut Throwcontrol V2906 (freeze (shen.t*-patterns Patterns B Hyp V2905 V2906 V2907)))))))))))))))) (do (shen.unbindv V2469 V2906) Result)))) false)))) (if (shen.pvar? V2468) (let Pattern (shen.newpv V2906) (let A (shen.newpv V2906) (do (shen.bindv V2468 (cons Pattern (cons : (cons A ()))) V2906) (let Result (let Hyp (tl V2467) (let Assume (shen.newpv V2906) (do (shen.incinfs) (unify! A A2454 V2906 (freeze (unify! Pattern Pattern2453 V2906 (freeze (shen.t*-assume Pattern Assume V2906 (freeze (cut Throwcontrol V2906 (freeze (shen.th* Pattern A Assume V2906 (freeze (cut Throwcontrol V2906 (freeze (shen.t*-patterns Patterns B Hyp V2905 V2906 V2907)))))))))))))))) (do (shen.unbindv V2468 V2906) Result))))) false))) (if (shen.pvar? V2467) (let Pattern (shen.newpv V2906) (let A (shen.newpv V2906) (let Hyp (shen.newpv V2906) (do (shen.bindv V2467 (cons (cons Pattern (cons : (cons A ()))) Hyp) V2906) (let Result (let Assume (shen.newpv V2906) (do (shen.incinfs) (unify! A A2454 V2906 (freeze (unify! Pattern Pattern2453 V2906 (freeze (shen.t*-assume Pattern Assume V2906 (freeze (cut Throwcontrol V2906 (freeze (shen.th* Pattern A Assume V2906 (freeze (cut Throwcontrol V2906 (freeze (shen.t*-patterns Patterns B Hyp V2905 V2906 V2907))))))))))))))) (do (shen.unbindv V2467 V2906) Result)))))) false))) false))) false)) false)) false))) false)))) false)) Case)))))

(defun shen.t*-assume (V2908 V2909 V2910 V2911) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V2450 (shen.lazyderef V2908 V2910) (if (cons? V2450) (let X (hd V2450) (let Y (tl V2450) (let A1 (shen.newpv V2910) (let A2 (shen.newpv V2910) (do (shen.incinfs) (cut Throwcontrol V2910 (freeze (shen.t*-assume X A1 V2910 (freeze (shen.t*-assume Y A2 V2910 (freeze (bind V2909 (append (shen.lazyderef A1 V2910) (shen.lazyderef A2 V2910)) V2910 V2911)))))))))))) false)) (if (= Case false) (let Case (let A (shen.newpv V2910) (do (shen.incinfs) (fwhen (shen.placeholder? (shen.lazyderef V2908 V2910)) V2910 (freeze (bind V2909 (cons (cons (shen.lazyderef V2908 V2910) (cons : (cons (shen.lazyderef A V2910) ()))) ()) V2910 V2911))))) (if (= Case false) (let V2451 (shen.lazyderef V2909 V2910) (if (= () V2451) (do (shen.incinfs) (thaw V2911)) (if (shen.pvar? V2451) (do (shen.bindv V2451 () V2910) (let Result (do (shen.incinfs) (thaw V2911)) (do (shen.unbindv V2451 V2910) Result))) false))) Case)) Case)))))

(defun shen.conc (V2912 V2913 V2914 V2915 V2916) (let Case (let V2446 (shen.lazyderef V2912 V2915) (if (= () V2446) (do (shen.incinfs) (bind V2914 (shen.lazyderef V2913 V2915) V2915 V2916)) false)) (if (= Case false) (let V2447 (shen.lazyderef V2912 V2915) (if (cons? V2447) (let X (hd V2447) (let Y (tl V2447) (let Z (shen.newpv V2915) (do (shen.incinfs) (bind V2914 (cons (shen.lazyderef X V2915) (shen.lazyderef Z V2915)) V2915 (freeze (shen.conc Y V2913 Z V2915 V2916))))))) false)) Case)))

(defun shen.findallhelp (V2917 V2918 V2919 V2920 V2921 V2922) (let Case (do (shen.incinfs) (call V2918 V2921 (freeze (shen.remember V2920 V2917 V2921 (freeze (fwhen false V2921 V2922)))))) (if (= Case false) (do (shen.incinfs) (bind V2919 (value (shen.lazyderef V2920 V2921)) V2921 V2922)) Case)))

(defun shen.remember (V2923 V2924 V2925 V2926) (let B (shen.newpv V2925) (do (shen.incinfs) (bind B (set (shen.deref V2923 V2925) (cons (shen.deref V2924 V2925) (value (shen.deref V2923 V2925)))) V2925 V2926))))

(defun findall (V2927 V2928 V2929 V2930 V2931) (let B (shen.newpv V2930) (let A (shen.newpv V2930) (do (shen.incinfs) (bind A (gensym shen.a) V2930 (freeze (bind B (set (shen.lazyderef A V2930) ()) V2930 (freeze (shen.findallhelp V2927 V2928 V2929 A V2930 V2931)))))))))

(defun shen.t*-defcc (V2932 V2933 V2934 V2935 V2936) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let V2419 (shen.lazyderef V2932 V2935) (if (cons? V2419) (let V2420 (shen.lazyderef (hd V2419) V2935) (if (= defcc V2420) (let V2421 (shen.lazyderef (tl V2419) V2935) (if (cons? V2421) (let F (hd V2421) (let V2422 (shen.lazyderef (tl V2421) V2935) (if (cons? V2422) (let V2423 (shen.lazyderef (hd V2422) V2935) (if (= { V2423) (let V2424 (shen.lazyderef (tl V2422) V2935) (if (cons? V2424) (let V2425 (shen.lazyderef (hd V2424) V2935) (if (cons? V2425) (let V2426 (shen.lazyderef (hd V2425) V2935) (if (= list V2426) (let V2427 (shen.lazyderef (tl V2425) V2935) (if (cons? V2427) (let A (hd V2427) (let V2428 (shen.lazyderef (tl V2427) V2935) (if (= () V2428) (let V2429 (shen.lazyderef (tl V2424) V2935) (if (cons? V2429) (let V2430 (shen.lazyderef (hd V2429) V2935) (if (= ==> V2430) (let V2431 (shen.lazyderef (tl V2429) V2935) (if (cons? V2431) (let B (hd V2431) (let V2432 (shen.lazyderef (tl V2431) V2935) (if (cons? V2432) (let V2433 (shen.lazyderef (hd V2432) V2935) (if (= } V2433) (let Rest (tl V2432) (let Rest& (shen.newpv V2935) (let Rest&& (shen.newpv V2935) (let Rules (shen.newpv V2935) (let ListA&& (shen.newpv V2935) (let B&& (shen.newpv V2935) (let Sig (shen.newpv V2935) (let Declare (shen.newpv V2935) (do (shen.incinfs) (bind Sig (shen.placeholders (cons (cons list (cons (shen.lazyderef A V2935) ())) (cons ==> (cons (shen.lazyderef B V2935) ()))) (shen.extract_vars (cons (cons list (cons (shen.lazyderef A V2935) ())) (cons ==> (cons (shen.lazyderef B V2935) ()))))) V2935 (freeze (bind ListA&& (hd (shen.lazyderef Sig V2935)) V2935 (freeze (bind B&& (hd (tl (tl (shen.lazyderef Sig V2935)))) V2935 (freeze (bind Rest& (shen.plug-wildcards (shen.lazyderef Rest V2935)) V2935 (freeze (bind Rest&& (shen.placeholders (shen.lazyderef Rest& V2935) (shen.extract_vars (shen.lazyderef Rest& V2935))) V2935 (freeze (shen.get-rules Rules Rest&& V2935 (freeze (cut Throwcontrol V2935 (freeze (shen.tc-rules F Rules ListA&& B&& (cons (cons F (cons : (cons Sig ()))) V2934) 1 V2935 (freeze (unify V2933 (cons (cons list (cons A ())) (cons ==> (cons B ()))) V2935 (freeze (bind Declare (declare (shen.lazyderef F V2935) (cons (cons list (cons (shen.lazyderef A V2935) ())) (cons ==> (cons (shen.lazyderef B V2935) ())))) V2935 V2936)))))))))))))))))))))))))))) false)) false))) false)) false)) false)) false))) false)) false)) false)) false)) false)) false))) false)) false)) false)))))

(defun shen.plug-wildcards (V2937) (cond ((cons? V2937) (map shen.plug-wildcards V2937)) ((= V2937 _) (gensym (intern "X"))) (true V2937)))

(defun shen.get-rules (V2938 V2939 V2940 V2941) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V2412 (shen.lazyderef V2938 V2940) (if (= () V2412) (let V2413 (shen.lazyderef V2939 V2940) (if (= () V2413) (do (shen.incinfs) (cut Throwcontrol V2940 V2941)) false)) (if (shen.pvar? V2412) (do (shen.bindv V2412 () V2940) (let Result (let V2414 (shen.lazyderef V2939 V2940) (if (= () V2414) (do (shen.incinfs) (cut Throwcontrol V2940 V2941)) false)) (do (shen.unbindv V2412 V2940) Result))) false))) (if (= Case false) (let V2415 (shen.lazyderef V2938 V2940) (if (cons? V2415) (let Rule (hd V2415) (let Rules (tl V2415) (let Other (shen.newpv V2940) (do (shen.incinfs) (shen.first-rule V2939 Rule Other V2940 (freeze (cut Throwcontrol V2940 (freeze (shen.get-rules Rules Other V2940 V2941))))))))) (if (shen.pvar? V2415) (let Rule (shen.newpv V2940) (let Rules (shen.newpv V2940) (do (shen.bindv V2415 (cons Rule Rules) V2940) (let Result (let Other (shen.newpv V2940) (do (shen.incinfs) (shen.first-rule V2939 Rule Other V2940 (freeze (cut Throwcontrol V2940 (freeze (shen.get-rules Rules Other V2940 V2941))))))) (do (shen.unbindv V2415 V2940) Result))))) false))) Case)))))

(defun shen.first-rule (V2942 V2943 V2944 V2945 V2946) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V2405 (shen.lazyderef V2942 V2945) (if (cons? V2405) (let V2406 (shen.lazyderef (hd V2405) V2945) (if (= ; V2406) (let Other2400 (tl V2405) (let V2407 (shen.lazyderef V2943 V2945) (if (= () V2407) (do (shen.incinfs) (unify! V2944 Other2400 V2945 (freeze (cut Throwcontrol V2945 V2946)))) (if (shen.pvar? V2407) (do (shen.bindv V2407 () V2945) (let Result (do (shen.incinfs) (unify! V2944 Other2400 V2945 (freeze (cut Throwcontrol V2945 V2946)))) (do (shen.unbindv V2407 V2945) Result))) false)))) false)) false)) (if (= Case false) (let V2408 (shen.lazyderef V2942 V2945) (if (cons? V2408) (let X2401 (hd V2408) (let Rest (tl V2408) (let V2409 (shen.lazyderef V2943 V2945) (if (cons? V2409) (let X (hd V2409) (let Rule (tl V2409) (do (shen.incinfs) (unify! X X2401 V2945 (freeze (shen.first-rule Rest Rule V2944 V2945 V2946)))))) (if (shen.pvar? V2409) (let X (shen.newpv V2945) (let Rule (shen.newpv V2945) (do (shen.bindv V2409 (cons X Rule) V2945) (let Result (do (shen.incinfs) (unify! X X2401 V2945 (freeze (shen.first-rule Rest Rule V2944 V2945 V2946)))) (do (shen.unbindv V2409 V2945) Result))))) false))))) false)) Case)))))

(defun shen.tc-rules (V2947 V2948 V2949 V2950 V2951 V2952 V2953 V2954) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V2394 (shen.lazyderef V2948 V2953) (if (= () V2394) (do (shen.incinfs) (thaw V2954)) false)) (if (= Case false) (let V2395 (shen.lazyderef V2948 V2953) (if (cons? V2395) (let Rule (hd V2395) (let Rules (tl V2395) (let V2396 (shen.lazyderef V2949 V2953) (if (cons? V2396) (let V2397 (shen.lazyderef (hd V2396) V2953) (if (= list V2397) (let V2398 (shen.lazyderef (tl V2396) V2953) (if (cons? V2398) (let A (hd V2398) (let V2399 (shen.lazyderef (tl V2398) V2953) (if (= () V2399) (let M (shen.newpv V2953) (do (shen.incinfs) (shen.tc-rule V2947 Rule A V2950 V2951 V2952 V2953 (freeze (bind M (+ (shen.deref V2952 V2953) 1) V2953 (freeze (cut Throwcontrol V2953 (freeze (shen.tc-rules V2947 Rules (cons list (cons A ())) V2950 V2951 M V2953 V2954))))))))) false))) false)) false)) false)))) false)) Case)))))

(defun shen.tc-rule (V2955 V2956 V2957 V2958 V2959 V2960 V2961 V2962) (let Case (do (shen.incinfs) (shen.check-defcc-rule V2956 V2957 V2958 V2959 V2961 V2962)) (if (= Case false) (let Err (shen.newpv V2961) (do (shen.incinfs) (bind Err (simple-error (cn "type error in rule " (shen.app (shen.lazyderef V2960 V2961) (cn " of " (shen.app (shen.lazyderef V2955 V2961) "" shen.a)) shen.a))) V2961 V2962))) Case)))

(defun shen.check-defcc-rule (V2963 V2964 V2965 V2966 V2967 V2968) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Syntax (shen.newpv V2967) (let Semantics (shen.newpv V2967) (let SynHyps (shen.newpv V2967) (do (shen.incinfs) (shen.get-syntax+semantics Syntax Semantics V2963 V2967 (freeze (cut Throwcontrol V2967 (freeze (shen.syntax-hyps Syntax V2966 SynHyps V2964 V2967 (freeze (cut Throwcontrol V2967 (freeze (shen.syntax-check Syntax V2964 SynHyps V2967 (freeze (cut Throwcontrol V2967 (freeze (shen.semantics-check Semantics V2965 SynHyps V2967 V2968))))))))))))))))))))

(defun shen.syntax-hyps (V2969 V2970 V2971 V2972 V2973 V2974) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V2365 (shen.lazyderef V2969 V2973) (if (= () V2365) (do (shen.incinfs) (unify! V2971 V2970 V2973 V2974)) false)) (if (= Case false) (let Case (let V2366 (shen.lazyderef V2969 V2973) (if (cons? V2366) (let V2367 (shen.lazyderef (hd V2366) V2973) (if (cons? V2367) (let X (hd V2367) (let Y (tl V2367) (let Z (tl V2366) (let W (shen.newpv V2973) (do (shen.incinfs) (cut Throwcontrol V2973 (freeze (shen.conc (cons X Y) Z W V2973 (freeze (cut Throwcontrol V2973 (freeze (shen.syntax-hyps W V2970 V2971 V2972 V2973 V2974)))))))))))) false)) false)) (if (= Case false) (let Case (let V2368 (shen.lazyderef V2969 V2973) (if (cons? V2368) (let X2359 (hd V2368) (let Y (tl V2368) (let V2369 (shen.lazyderef V2971 V2973) (if (cons? V2369) (let V2370 (shen.lazyderef (hd V2369) V2973) (if (cons? V2370) (let X (hd V2370) (let V2371 (shen.lazyderef (tl V2370) V2973) (if (cons? V2371) (let V2372 (shen.lazyderef (hd V2371) V2973) (if (= : V2372) (let V2373 (shen.lazyderef (tl V2371) V2973) (if (cons? V2373) (let A2360 (hd V2373) (let V2374 (shen.lazyderef (tl V2373) V2973) (if (= () V2374) (let SynHyps (tl V2369) (do (shen.incinfs) (unify! V2972 A2360 V2973 (freeze (unify! X X2359 V2973 (freeze (fwhen (shen.placeholder? (shen.deref X V2973)) V2973 (freeze (cut Throwcontrol V2973 (freeze (shen.syntax-hyps Y V2970 SynHyps V2972 V2973 V2974))))))))))) (if (shen.pvar? V2374) (do (shen.bindv V2374 () V2973) (let Result (let SynHyps (tl V2369) (do (shen.incinfs) (unify! V2972 A2360 V2973 (freeze (unify! X X2359 V2973 (freeze (fwhen (shen.placeholder? (shen.deref X V2973)) V2973 (freeze (cut Throwcontrol V2973 (freeze (shen.syntax-hyps Y V2970 SynHyps V2972 V2973 V2974))))))))))) (do (shen.unbindv V2374 V2973) Result))) false)))) (if (shen.pvar? V2373) (let A2360 (shen.newpv V2973) (do (shen.bindv V2373 (cons A2360 ()) V2973) (let Result (let SynHyps (tl V2369) (do (shen.incinfs) (unify! V2972 A2360 V2973 (freeze (unify! X X2359 V2973 (freeze (fwhen (shen.placeholder? (shen.deref X V2973)) V2973 (freeze (cut Throwcontrol V2973 (freeze (shen.syntax-hyps Y V2970 SynHyps V2972 V2973 V2974))))))))))) (do (shen.unbindv V2373 V2973) Result)))) false))) (if (shen.pvar? V2372) (do (shen.bindv V2372 : V2973) (let Result (let V2375 (shen.lazyderef (tl V2371) V2973) (if (cons? V2375) (let A2360 (hd V2375) (let V2376 (shen.lazyderef (tl V2375) V2973) (if (= () V2376) (let SynHyps (tl V2369) (do (shen.incinfs) (unify! V2972 A2360 V2973 (freeze (unify! X X2359 V2973 (freeze (fwhen (shen.placeholder? (shen.deref X V2973)) V2973 (freeze (cut Throwcontrol V2973 (freeze (shen.syntax-hyps Y V2970 SynHyps V2972 V2973 V2974))))))))))) (if (shen.pvar? V2376) (do (shen.bindv V2376 () V2973) (let Result (let SynHyps (tl V2369) (do (shen.incinfs) (unify! V2972 A2360 V2973 (freeze (unify! X X2359 V2973 (freeze (fwhen (shen.placeholder? (shen.deref X V2973)) V2973 (freeze (cut Throwcontrol V2973 (freeze (shen.syntax-hyps Y V2970 SynHyps V2972 V2973 V2974))))))))))) (do (shen.unbindv V2376 V2973) Result))) false)))) (if (shen.pvar? V2375) (let A2360 (shen.newpv V2973) (do (shen.bindv V2375 (cons A2360 ()) V2973) (let Result (let SynHyps (tl V2369) (do (shen.incinfs) (unify! V2972 A2360 V2973 (freeze (unify! X X2359 V2973 (freeze (fwhen (shen.placeholder? (shen.deref X V2973)) V2973 (freeze (cut Throwcontrol V2973 (freeze (shen.syntax-hyps Y V2970 SynHyps V2972 V2973 V2974))))))))))) (do (shen.unbindv V2375 V2973) Result)))) false))) (do (shen.unbindv V2372 V2973) Result))) false))) (if (shen.pvar? V2371) (let A2360 (shen.newpv V2973) (do (shen.bindv V2371 (cons : (cons A2360 ())) V2973) (let Result (let SynHyps (tl V2369) (do (shen.incinfs) (unify! V2972 A2360 V2973 (freeze (unify! X X2359 V2973 (freeze (fwhen (shen.placeholder? (shen.deref X V2973)) V2973 (freeze (cut Throwcontrol V2973 (freeze (shen.syntax-hyps Y V2970 SynHyps V2972 V2973 V2974))))))))))) (do (shen.unbindv V2371 V2973) Result)))) false)))) (if (shen.pvar? V2370) (let X (shen.newpv V2973) (let A2360 (shen.newpv V2973) (do (shen.bindv V2370 (cons X (cons : (cons A2360 ()))) V2973) (let Result (let SynHyps (tl V2369) (do (shen.incinfs) (unify! V2972 A2360 V2973 (freeze (unify! X X2359 V2973 (freeze (fwhen (shen.placeholder? (shen.deref X V2973)) V2973 (freeze (cut Throwcontrol V2973 (freeze (shen.syntax-hyps Y V2970 SynHyps V2972 V2973 V2974))))))))))) (do (shen.unbindv V2370 V2973) Result))))) false))) (if (shen.pvar? V2369) (let X (shen.newpv V2973) (let A2360 (shen.newpv V2973) (let SynHyps (shen.newpv V2973) (do (shen.bindv V2369 (cons (cons X (cons : (cons A2360 ()))) SynHyps) V2973) (let Result (do (shen.incinfs) (unify! V2972 A2360 V2973 (freeze (unify! X X2359 V2973 (freeze (fwhen (shen.placeholder? (shen.deref X V2973)) V2973 (freeze (cut Throwcontrol V2973 (freeze (shen.syntax-hyps Y V2970 SynHyps V2972 V2973 V2974)))))))))) (do (shen.unbindv V2369 V2973) Result)))))) false))))) false)) (if (= Case false) (let V2377 (shen.lazyderef V2969 V2973) (if (cons? V2377) (let Y (tl V2377) (do (shen.incinfs) (shen.syntax-hyps Y V2970 V2971 V2972 V2973 V2974))) false)) Case)) Case)) Case)))))

(defun shen.get-syntax+semantics (V2975 V2976 V2977 V2978 V2979) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V2331 (shen.lazyderef V2975 V2978) (if (= () V2331) (let V2332 (shen.lazyderef V2977 V2978) (if (cons? V2332) (let V2333 (shen.lazyderef (hd V2332) V2978) (if (= := V2333) (let V2334 (shen.lazyderef (tl V2332) V2978) (if (cons? V2334) (let Semantics (hd V2334) (let V2335 (shen.lazyderef (tl V2334) V2978) (if (= () V2335) (do (shen.incinfs) (cut Throwcontrol V2978 (freeze (bind V2976 (shen.lazyderef Semantics V2978) V2978 V2979)))) false))) false)) false)) false)) (if (shen.pvar? V2331) (do (shen.bindv V2331 () V2978) (let Result (let V2336 (shen.lazyderef V2977 V2978) (if (cons? V2336) (let V2337 (shen.lazyderef (hd V2336) V2978) (if (= := V2337) (let V2338 (shen.lazyderef (tl V2336) V2978) (if (cons? V2338) (let Semantics (hd V2338) (let V2339 (shen.lazyderef (tl V2338) V2978) (if (= () V2339) (do (shen.incinfs) (cut Throwcontrol V2978 (freeze (bind V2976 (shen.lazyderef Semantics V2978) V2978 V2979)))) false))) false)) false)) false)) (do (shen.unbindv V2331 V2978) Result))) false))) (if (= Case false) (let Case (let V2340 (shen.lazyderef V2975 V2978) (if (= () V2340) (let V2341 (shen.lazyderef V2977 V2978) (if (cons? V2341) (let V2342 (shen.lazyderef (hd V2341) V2978) (if (= := V2342) (let V2343 (shen.lazyderef (tl V2341) V2978) (if (cons? V2343) (let Semantics (hd V2343) (let V2344 (shen.lazyderef (tl V2343) V2978) (if (cons? V2344) (let V2345 (shen.lazyderef (hd V2344) V2978) (if (= where V2345) (let V2346 (shen.lazyderef (tl V2344) V2978) (if (cons? V2346) (let G (hd V2346) (let V2347 (shen.lazyderef (tl V2346) V2978) (if (= () V2347) (do (shen.incinfs) (cut Throwcontrol V2978 (freeze (bind V2976 (cons where (cons (shen.lazyderef G V2978) (cons (shen.lazyderef Semantics V2978) ()))) V2978 V2979)))) false))) false)) false)) false))) false)) false)) false)) (if (shen.pvar? V2340) (do (shen.bindv V2340 () V2978) (let Result (let V2348 (shen.lazyderef V2977 V2978) (if (cons? V2348) (let V2349 (shen.lazyderef (hd V2348) V2978) (if (= := V2349) (let V2350 (shen.lazyderef (tl V2348) V2978) (if (cons? V2350) (let Semantics (hd V2350) (let V2351 (shen.lazyderef (tl V2350) V2978) (if (cons? V2351) (let V2352 (shen.lazyderef (hd V2351) V2978) (if (= where V2352) (let V2353 (shen.lazyderef (tl V2351) V2978) (if (cons? V2353) (let G (hd V2353) (let V2354 (shen.lazyderef (tl V2353) V2978) (if (= () V2354) (do (shen.incinfs) (cut Throwcontrol V2978 (freeze (bind V2976 (cons where (cons (shen.lazyderef G V2978) (cons (shen.lazyderef Semantics V2978) ()))) V2978 V2979)))) false))) false)) false)) false))) false)) false)) false)) (do (shen.unbindv V2340 V2978) Result))) false))) (if (= Case false) (let V2355 (shen.lazyderef V2975 V2978) (if (cons? V2355) (let X2327 (hd V2355) (let Syntax (tl V2355) (let V2356 (shen.lazyderef V2977 V2978) (if (cons? V2356) (let X (hd V2356) (let Rule (tl V2356) (do (shen.incinfs) (unify! X X2327 V2978 (freeze (shen.get-syntax+semantics Syntax V2976 Rule V2978 V2979)))))) false)))) (if (shen.pvar? V2355) (let X2327 (shen.newpv V2978) (let Syntax (shen.newpv V2978) (do (shen.bindv V2355 (cons X2327 Syntax) V2978) (let Result (let V2357 (shen.lazyderef V2977 V2978) (if (cons? V2357) (let X (hd V2357) (let Rule (tl V2357) (do (shen.incinfs) (unify! X X2327 V2978 (freeze (shen.get-syntax+semantics Syntax V2976 Rule V2978 V2979)))))) false)) (do (shen.unbindv V2355 V2978) Result))))) false))) Case)) Case)))))

(defun shen.syntax-check (V2980 V2981 V2982 V2983 V2984) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V2324 (shen.lazyderef V2980 V2983) (if (= () V2324) (do (shen.incinfs) (thaw V2984)) false)) (if (= Case false) (let Case (let V2325 (shen.lazyderef V2980 V2983) (if (cons? V2325) (let X (hd V2325) (let Syntax (tl V2325) (let C (shen.newpv V2983) (let X&& (shen.newpv V2983) (let B (shen.newpv V2983) (do (shen.incinfs) (fwhen (shen.grammar_symbol? (shen.lazyderef X V2983)) V2983 (freeze (cut Throwcontrol V2983 (freeze (shen.t* (cons X (cons : (cons (cons (cons list (cons B ())) (cons ==> (cons C ()))) ()))) V2982 V2983 (freeze (cut Throwcontrol V2983 (freeze (bind X&& (concat && (shen.lazyderef X V2983)) V2983 (freeze (cut Throwcontrol V2983 (freeze (shen.t* (cons X&& (cons : (cons (cons list (cons V2981 ())) ()))) (cons (cons X&& (cons : (cons (cons list (cons B ())) ()))) V2982) V2983 (freeze (cut Throwcontrol V2983 (freeze (shen.syntax-check Syntax V2981 V2982 V2983 V2984))))))))))))))))))))))) false)) (if (= Case false) (let V2326 (shen.lazyderef V2980 V2983) (if (cons? V2326) (let X (hd V2326) (let Syntax (tl V2326) (do (shen.incinfs) (shen.t* (cons X (cons : (cons V2981 ()))) V2982 V2983 (freeze (cut Throwcontrol V2983 (freeze (shen.syntax-check Syntax V2981 V2982 V2983 V2984)))))))) false)) Case)) Case)))))

(defun shen.semantics-check (V2985 V2986 V2987 V2988 V2989) (let Semantics* (shen.newpv V2988) (do (shen.incinfs) (bind Semantics* (shen.curry (shen.rename-semantics (shen.deref V2985 V2988))) V2988 (freeze (shen.t* (cons Semantics* (cons : (cons V2986 ()))) V2987 V2988 V2989))))))

(defun shen.rename-semantics (V2990) (cond ((cons? V2990) (cons (shen.rename-semantics (hd V2990)) (shen.rename-semantics (tl V2990)))) ((shen.grammar_symbol? V2990) (cons shen.<-sem (cons V2990 ()))) (true V2990)))



